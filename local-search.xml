<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MIT6.824 -&gt; Raft</title>
    <link href="/2022/04/03/Raft/"/>
    <url>/2022/04/03/Raft/</url>
    
    <content type="html"><![CDATA[<p>在MIT6.824的课程中，Raft算法在Lab中是一个举足轻重的存在，除了MapReduce，其余三个Lab都基于Raft模块的实现。本文将主要介绍Raft算法。</p><span id="more"></span><p>MIT6.824课程先从Google三驾马车MapReduce、GFS、Bigtable中的两个开始，分别引入分布式场景下的计算与存储问题。对于分布式计算，这是一个无状态的过程，从MapReduce到Spark对其进行各种改进（如一个节点可以同时执行多种Map任务）；对于分布式存储，这个话题更加复杂，状态的维护与对外的展现是一个极其棘手的问题，<strong>GFS</strong>为了追求性能并不能保证多副本的数据一致性，若Secondary chunk server出现错误则已经写入的节点是无法被Primary chunk server纠正的（当然也主要因为业务需求是Web搜索，精确性要求没那么高），而本文的主角<strong>Raft</strong>则是一个能够维护多副本间一致的一个共识算法，并能够轻易对外界服务提供线性一致性的一致性模型保证。</p><blockquote><p>配置变更及日志压缩部分还没仔细好好研究。</p></blockquote><h3 id="Raft-的由来与宗旨"><a href="#Raft-的由来与宗旨" class="headerlink" title="Raft 的由来与宗旨"></a>Raft 的由来与宗旨</h3><p>众所周知，Paxos 是一个非常划时代的共识算法。在 Raft 出现之前的 10 年里，Paxos 几乎统治着共识算法这一领域：因为绝大多数共识算法的实现都是基于 Paxos 或者受其影响，同时 Paxos 也成为了教学领域里讲解共识问题时的示例。</p><p>但是不幸的是，尽管有很多工作都在尝试降低 Paxos 的复杂性，但是它依然十分难以理解。并且，Paxos 自身的算法结构需要进行大幅的修改才能够应用到实际的系统中。这些都导致了工业界和学术界都对 Paxos 算法感到十分头疼。比如 <code>Google Chubby</code> 的论文就提到，因为 Paxos 的描述和现实差距太大，所以最终人们总会实现一套未经证实的类 Paxos 协议。</p><p>基于以上背景，<code>Diego Ongaro</code> 在就读博士期间，深入研究 Paxos 协议后提出了 Raft 协议，旨在提供更为易于理解的共识算法。Raft 的宗旨在于可实践性和可理解性，并且相比 Paxos 几乎没有牺牲多少性能。</p><h3 id="Raft简介"><a href="#Raft简介" class="headerlink" title="Raft简介"></a>Raft简介</h3><p>共识算法的目标就是保证集群上所有节点的状态一致。那么关于这样的副本一致问题主要有两种思路：</p><p>①<strong>状态转移</strong>即完全拷贝节点状态（一般在新节点刚加入集群上时采用此方案）</p><p>②<strong>复制状态机</strong>即仅将来自客户端的操作或其他外部事件从Primary节点传输到其他节点（这也是大多数情况采用的方案）</p><p>  ![state machine](/picture/Distributed/state machine.png)</p><p>对于节点一般有两种操作即读操作与写操作。写操作会改变节点状态，便立刻要<strong>复制状态机</strong>到其他节点上（将写指令同步给其他所有节点）。理想状态下我们希望这种同步可以立即作用于其他节点之上，但由于<strong>不可靠的网络</strong>将出现<strong>分区、冗余、丢失、乱序</strong>等问题。如何保证指令能够在所有节点上都以相同的顺序执行呢？这便是Raft所要解决的问题。</p><h4 id="一个简易的可行方案"><a href="#一个简易的可行方案" class="headerlink" title="一个简易的可行方案"></a>一个简易的可行方案</h4><ol><li><p>首先在多个副本中选出一个Leader节点负责发送同步日志到其他节点，并确定日志顺序。</p></li><li><p>所有需要写日志的请求（在未做ReadIndex等优化时默认读请求也要写日志）均需发送给Leader节点。</p></li><li><p>Leader先将日志写入自己的磁盘，日志需要通过某个参数（Index）定义顺序，并发送给其他节点，超过半数的节点同意了此操作Leader节点便会回复服务调用者真正apply该操作。</p></li><li><p>当Leader节点崩溃时，其他跟随者节点应通过HeartBeat机制重新选举出新的Leader保证集群的正常运行。</p></li><li><p>当集群新加入节点或有节点退出时时，需要将配置信息同步到集群内所有节点。</p></li></ol><h3 id="Raft的详细实现"><a href="#Raft的详细实现" class="headerlink" title="Raft的详细实现"></a>Raft的详细实现</h3><p>根据上文提供的一个简易的可行方案，可以将共识算法这个很难解决的问题分为多个子问题：</p><ul><li><p>1：<code>Leader election </code>选举领导节点统筹全局。</p></li><li><p>2 - 3：<code>Log Replication</code>日志同步 Leader负责从客户端接收请求，并且在集群中扩散同步。</p></li><li><p>4：<code>Safety</code> 各节点间状态机的一致性保证。</p></li><li><p>… …</p></li></ul><blockquote><p>这里简单提一下为什么到此说的所有操作都是以日志形式来记录。Log的作用非常非常大，主要有以下几点：</p><ol><li>方便定义顺序（Index）</li><li>Follower通过Log临时存取操作从而能够等待Commit消息</li><li>Leader也需要存储Log来对Follower进行重传保证消息不丢失</li><li>Log可以在节点重启时帮助恢复状态（Follower需要等待Leader的指示）</li><li>通过Log携带后续将介绍的任期号Term，可以确定日志新旧 / 是否可以被提交等问题（解决了GFS已写入的错误日志无法被纠正的问题）</li></ol><p>总之使用日志机制能够帮助解决非常多的问题，文件系统、数据库也都利用了日志帮助解决可靠的持久化（崩溃后的一致性）、原子性等问题。</p><p><strong>Log = Index + Term + cmd</strong></p></blockquote><h4 id="节点的状态机"><a href="#节点的状态机" class="headerlink" title="节点的状态机"></a>节点的状态机</h4><p>既然Raft节点有Leader状态，自然也有其他Follower状态，节点间状态的变化较为重要。Raft将节点分为<code>Leader</code>、<code>Candidate</code>、<code>Follower</code>三种状态。现在看可能有些不明白，可以等第二遍看就清晰多了。简单来说就是集群内会有一个Leader负责发起心跳，响应客户端，创建日志，同步日志。其余节点都是Follower，但每个节点内部都会有个超时计时器用于检测自己是否还能和Leader互联（当接受到Leader心跳或同步日志请求便会重置该计时器），如果超时Follower便会将自己转变为候选者Candidate向所有节点索要投票（Term任期号也加一），一旦超过半数的节点同意便会成为当选Leader（后续会什么条件下节点会同意投票），否则可能会再次等待超时器超时重新参选或被其他Leader的消息（含有更新的任期号）打回Follower。</p><blockquote><p>Term任期号保证了安全性，一个任期每个节点只有一张票即能保证半数以上票真的是半数以上的节点投出的，这样便能保证对于一个给定任期号最多只有一个领导者。</p><p>Term 在 Raft 算法中充当逻辑时钟。可以作为感受节点状态是否过期的标志。</p></blockquote><p>  ![state transfer](/picture/Distributed/state transfer.png)</p><p>在博士论文和实际生产系统中，其实又增加了两种身份：</p><ul><li><code>Learner</code>：不具有选举权，参与日志复制过程但不计数的节点。可以作为新节点加入集群时的过渡状态以提升可用性，也可以作为一种类似于 binlog 的对 Leader 日志流进行订阅的角色，比如可以参考 PingCAP 公司 tikv 和 tiflash 的架构。</li><li><code>Pre candidate</code>：刚刚发起竞选，还在等待 <code>Pre-Vote</code> 结果的临时状态， 取决于 <code>Pre-Vote</code> 的结果，可能进化为 candidate，可能退化为 follower。</li></ul><h4 id="节点状态的数据结构"><a href="#节点状态的数据结构" class="headerlink" title="节点状态的数据结构"></a>节点状态的数据结构</h4><p>每一个节点都应该有的持久化状态：</p><ul><li><code>currentTerm</code>：当前任期，保证重启后任期不丢失。</li><li><code>votedFor</code>：在当前 term，给哪个节点投了票，值为 null 或 <code>candidate id</code>。即使节点重启，Raft 算法也能保证每个任期最多只有一个 leader。</li><li><code>log[]</code>：已经 committed 的日志，保证状态机可恢复。</li></ul><p>每一个节点都应该有的非持久化状态：</p><ul><li><code>commitIndex</code>：已提交的最大 index。leader 节点重启后可以通过 appendEntries RPC 逐渐得到不同节点的 matchIndex，从而确认 commitIndex，follower 只需等待 leader 传递过来的 commitIndex 即可。</li><li><code>lastApplied</code>：已被状态机应用的最大 index。raft 算法假设了状态机本身是易失的，所以重启后状态机的状态可以通过 log[] （部分 log 可以压缩为 snapshot) 来恢复。（不持久化即从0开始apply到恢复的commitIndex）</li></ul><blockquote><p>对于为什么这两个状态在Raft论文中被定义为非持久化的：</p><p>CommitIndex 能够很快的被传播、恢复，这不是一个问题。</p><p>ApplyIndex 和状态机有关，你的状态机如果是持久化的，你也需要持久化 ApplyIndex 来保存这个状态。</p><p>当然，实际工程中对 StateMachine 的假定一般都是 Non-Volatile 的，比如 RocksDB 什么的。这样的设计下状态机不仅能够自恢复，而且自恢复往往更高效（往往只需要重放少数 WAL 即可），此时便可以考虑持久化 commitIndex 和 applyIndex 了。其实持久化 commitIndex 还好，但持久化 applyIndex 会比较麻烦，因为要想保证 safety 就需要保证状态机的更新和 applyIndex 的更新能够做到原子性，否则重启时可能会出现日志多 apply 或者少 apply 的现象。在 TiKV 的实现中，状态机的更新和 applyIndex 的更新是打包成了一条事务去做处理的，这样才算是比较优雅的解决了这个问题。</p></blockquote><p>Leader 的非持久化状态：</p><ul><li><p><code>nextIndex[]</code>：保存对于每个Follower应该发送的下一份 <code>entry index</code>；初始化为本地 lastIndex + 1，如果发送给Follower对应不上会进行相应的回退。</p></li><li><p><code>matchIndex[]</code>保存对于每个Follower已确认的Log Index，即已经同步到每一个 follower 的 <code>entry index</code>。初始化为 0，根据复制状态不断递增。</p><blockquote><p>每次选举后，Leader 的此两个数组都应该立刻重新初始化并开始构建。</p></blockquote></li></ul><h4 id="节点选举"><a href="#节点选举" class="headerlink" title="节点选举"></a>节点选举</h4><p>在<strong>节点的状态机</strong>部分已经基本介绍了什么时候会开始进行选举。这里主要介绍这个子问题中什么情况可以投赞成票选举节点成为Leader。</p><p><strong>① 安全选举限制</strong>（不能只比CandidateTerm哟）</p><p>Leader必须得确保拥有所有已commit的日志。当 Candidate 发送 RequestVoteRPC 时，会带上最后一个 log entry 的信息。 所有的节点收到该请求后，都会比对自己的日志，如果发现自己的日志更新一些，则会拒绝投票给该 Candidate。（Pre-Vote 同理，如果 follower 认为 Pre-Candidate 没有资格的话，会拒绝 PreVote）</p><blockquote><p>针对分区后部分节点会因为永远当不上Leader疯狂递增Term任期号，如果网络恢复后进入集群会更新整个集群的Term，并强行让Leader让出位置。Raft通过Pre-vote机制避免此问题，一个成员可以给所有人发探测包，如果能收到至少多数派的回复，就可以确认自己是否被网络分区，如果自己与多数派连通，那么可以发起选举。即一个 Candidate 必须在获得了多数赞同的情形下， 才会增加自己的 term，当然了Pre-Vote并不会改变其他节点的状态（Term、votefor等）。</p></blockquote><p>判断日志新旧的方式：获取请求的 entry 后，比对自己日志中的最后一个 entry。 首先比对 term，如果自己的 term 更大，则拒绝请求。 如果 term 一样，则比对 index，如果自己的 index 更大（说明自己的日志更长），则拒绝请求。</p><p><strong>但是光有这个限制并不能解决下面这个问题</strong>。</p><p>  <img src="/picture/Distributed/Figure8.png" alt="Figure 8"></p><p>此问题代表要限定的另一个规则 <strong>② Leader不能提交之前任期的日志，只能通过提交自己任期的日志，从而间接提交之前任期的日志。</strong></p><p>先看图中错误的例子：</p><p>(a). S1 是任期 2 的 Leader，日志已经复制到了 S2。</p><p>(b). S1 宕机，S5 获得 S3、S4 和 S5 的选票成为 Leader，然后写了一条日志 &lt;index=2 , term=3&gt;。</p><p>(c). S5 刚写完就宕机了，S1 重新当选 Leader，currentTerm = 4，<strong>此刻还没有新的请求进来</strong>，S1 将 &lt;index=2 , term = 2&gt;的日志复制到了 S3，多数派达成，S1 提交了这个日志（注意，<strong>term=2 不是当前任期的日志，我们在讨论错误的情况</strong>）。然后请求进来，刚写了本地 &lt;index=3 , term=4&gt; 的日志，S1 就故障了。</p><p>(d1). 这时候 S5 可以通过来自 S2、S3、S4 和自己的投票，重新成为 Leader(currentTerm&gt;=5)，并将 index=2 &amp;&amp; term=3 的日志复制到其他所有节点并提交，此时 <strong>index=2 的日志提交了两次！</strong>一次 term=2，一次term=3，这是绝对不允许发生的，已经提交的日志不能够被覆盖！</p><p>(d2). 这里的情况是，S1 在宕机之前将自己 term=4 的日志复制到了大多数机器上，这样 S5 就不可能选举成功。这是 S1 不发生故障，正确复制的情况。</p><p>所以，<strong>我们要增加提交的约束，不让 (d1) 这种情况发生</strong>。这个约束就是，<strong>Leader 只能提交自己任期的日志</strong>，不然则会出现已提交日志被覆盖的情况。</p><blockquote><p>虽然加了这个约束不会重复提交了，但如果一直没新的请求进来，&lt;index=2 , term=3&gt; 岂不是就一直不能提交？那这里不就阻塞了吗？如果这里是 kv 数据库，问题就很明显了。假设 (c) 或 (d) 中 index=2 那条日志里的 Command 是 <code>Set(&quot;k&quot;, &quot;1&quot;)</code>，S5 当选 Leader 后，客户端来查询 <code>Get(&quot;k&quot;)</code>（已经优化到读请求不写Log了），Leader 查到日志有记录但又不能回复 <code>1</code> 给客户端（因为按照约束这条日志未提交），线性一致性要求不能返回陈旧的数据，Leader 迫切地需要知道这条日志到底能不能提交。</p><p>所以 raft 论文提到了引入 no-op 日志来解决这个问题。这个在 etcd 中有实现。</p><p><strong>no-op</strong> 日志即只有 index 和 term 信息，command 信息为空。也是要写到磁盘存储的。</p><p>具体流程是在 Leader 刚选举成功的时候，立即追加一条 no-op 日志，并立即复制到其它节点，no-op 日志一经提交，Leader 前面那些未提交的日志全部间接提交，问题就解决了。像上面的 kv 数据库，有了 no-op 日志之后，Leader 就能快速响应客户端查询了。</p><p>本质上，no-op 日志使 Leader 隐式地快速提交之前任期未提交的日志，确认当前 <code>commitIndex</code>，这样系统才会快速对外正常工作。</p><blockquote><p>同时no-op还可以解决配置变更带来的可能的数据丢失问题 <a href="https://zhuanlan.zhihu.com/p/359206808">详见此文章</a></p></blockquote></blockquote><p>最后对于节点的选举再说明一点，为了防止在同一时间有太多的 Follower 转变为 Candidate 导致无法选出绝对多数， Raft 采用了随机选举超时（<code>randomized election timeouts</code>）的机制， 即每个节点设定超市计时器的超时时间有一定添加一定随机值，可以有效避免同时选举的活锁问题。</p><h4 id="日志同步"><a href="#日志同步" class="headerlink" title="日志同步"></a>日志同步</h4><p>Leader 被选举后，则负责所有的客户端请求。每一个客户端请求都包含一个命令，该命令可以被作用到状态机上。</p><p>Leader 收到客户端请求后，会生成一个log entry，包含 <code>&lt;Index, Term, cmd&gt;</code>，再将这个log entry 添加到自己的日志末尾后，向所有的节点广播该log entry。</p><p>Follower 如果同意接受该 log entry，则在将 log entry 添加到自己的日志后，返回同意。</p><p>如果 Leader 收到了多数的成功答复，则将该 log entry 应用到自己的状态机上， 之后可以称该log entry 是 committed 的。该 committed 信息会随着随后的 AppendEntries 或 Heartbeat RPC 被传达到其他节点。</p><p><strong>不一致的Follower节点会一步步与Leader节点变为一致</strong>，在这里Raft有两点保证：</p><ul><li>如果在两个日志（节点）里，有两个 entry 拥有相同的 index 和 term，那么它们一定有相同的 cmd；</li><li>如果在两个日志（节点）里，有两个 entry 拥有相同的 index 和 term，那么它们前面的 entry 也一定相同。</li></ul><p>通过“仅有 Leader 可以生成 entry”来确保第一个性质， 第二个性质则通过<strong>一致性检查</strong>（consistency check）来保证，该检查包含几个步骤：</p><p>Leader在同步日志的RPC中还得包含真正需要发送的日志的上一条entry，Follower会进行对比自己的日志，如果发现不符则会拒绝这次AppendEntries RPC，Leader普通做法是对于该Follower的nextIndex进行减一再进行重试，对其的优化的<strong>nextIndex快速回退方法</strong>是Follower会多返回两个参数<code>ConflictIndex &amp; ConflictTerm</code>：</p><p>ConflictTerm = log[prevLogIndex].Term，并且查找其log中term等于 conflictTerm的第一个log的下标设置为ConflictIndex。</p><p>Leader接收到回复分为三种情况：</p><ol><li><p>若Leader中无这个ConflictTerm，此情形，Follower的整个ConflictTerm均得删除。所以，我们可以设置nextIndex为此Follower的ConflictTerm的第一个index即ConflictIndex。</p></li><li><p>若Leader中有这个冲突Term，此情形，Follower的这个ConflictTerm中不一定所有的index都冲突<br>所以，我们可以设置nextIndex为Leader log中ConfictTerm最后出现的位置的后一个Index。（Index + Term可以唯一确定cmd！！）</p></li><li><p>这是Follower都没有prevLogIndex的场景，这里ConflictTerm会返回-1， Leader应该回退到Follower最后一条Log条目的下一条。</p></li></ol><h4 id="⚠️Safety安全性"><a href="#⚠️Safety安全性" class="headerlink" title="⚠️Safety安全性"></a>⚠️Safety安全性</h4><p>对于Raft算法的安全性（各状态机状态一致性保证）有五条公理：</p><ol><li><p>选举安全特性：对于一个给定任期号，最多只有一个Leader（因为一个任期每个节点只有一张票，且过半数票才能当选Leader）。</p></li><li><p>领导人只附加原则：领导人绝不会删除或覆盖自己的日志，只会增加。</p></li><li><p>日志匹配原则：如果两个节点日志在相同index上term相同，则0～index的日志完全相同。</p></li></ol><blockquote><p>由<code>1</code>和<code>2</code>可以推出<code>3</code>。因为集群在任一时刻只有一个Leader，所以一个任期内只会在同一个index上写入一次日志。又因为Leader不会覆盖和删除自己的日志，日志一旦写入就不允许更改，所以只要term和index相同，那么在任何节点上的日志也都相同。因为跟随者每次都会根据Leader发来的PreLogIndex和PrevLogTerm寻找日志共识点，所以根据递归性质0～index的所有日志都匹配。</p></blockquote><ol start="4"><li><p>领导人完全特性：如果某个日志条目在某个任期号中已经被提交，那么之后的新Leader必然拥有此日志（具体实现见节点选取章节的两个限制）</p></li><li><p>状态机安全特性：如果一个Leader已经将给定index的日志条目apply到了状态机上，那么其他任何一个节点不会在这个index apply一个不同的日志。</p></li></ol><blockquote><p>定义A为上个任期最后一条已提交日志</p><p>根据<code>4</code>，A必然同步到了集群中半数以上的节点并且Leader必然拥有A</p><p>根据<code>3</code>，如果A被Leader包含则比A旧的日志一定被Leader包含。</p><p>因为lastApplied &lt;= commitIndex 且已提交的日志在所有集群节点上顺序一致。所以apply日志必然在所有节点上顺序一致，因为状态机只能按序应用日志。所以<strong>状态机在整个集群所有节点上必然最终一致</strong>。</p></blockquote><h4 id="配置变更"><a href="#配置变更" class="headerlink" title="配置变更"></a>配置变更</h4><p>Raft 的配置变更一般分为两种方式：一次变更一个和一次变更多个。</p><h5 id="一次变更一台"><a href="#一次变更一台" class="headerlink" title="一次变更一台"></a>一次变更一台</h5><p>因为在 Raft 算法中，集群中每一个节点都存有整个集群的信息，而集群的成员有可能会发生变更（节点增删、替换节点等）。 Raft 限制一次性只能增／删一个节点，在一次变更结束后，才能继续进行下一次变更。</p><p>如果一次性只变更一个节点，那么只需要简单的要求“<strong>在新／旧集群中，都必须取得多数（N/2+1）</strong>”， 那么这两个多数中必然会出现交集，这样就可以保证不会因为配置不一致而导致脑裂。</p><p>  ![one config change](/picture/Distributed/one config change.png)</p><p>当 Leader 收到集群变更的请求后，就会生成一个特殊的 entry 项用来保存配置， 在将配置项添加到 log 后，该配置立刻生效（也就是说任何节点在收到新配置后，就立刻启用新配置）。 然后 Leader 将该 entry 扩散至多数节点，成功后则提交该 entry。 一旦一个新配置项被 committed，则视为该次变更已结束，可以继续处理下一次变更了。</p><p>为了保证可用性，需要新增一项规则，节点在响应 RPC 时，不考虑来源节点是否在自己的配置文件之中。 也就是说，即使收到了一个并不在自己配置文件之中的节点发来的 RPC， 也需要正常处理和响应，包括 AppendEntriesRPC 和 RequestVoteRPC。</p><h5 id="一次变更多台"><a href="#一次变更多台" class="headerlink" title="一次变更多台"></a>一次变更多台</h5><blockquote><p>Todo…</p></blockquote><h4 id="日志压缩——快照"><a href="#日志压缩——快照" class="headerlink" title="日志压缩——快照"></a>日志压缩——快照</h4><p>Raft 的日志在正常运行期间会增长以合并更多的客户请求，但是在实际的系统中，Raft 的日志无法不受限制地增长。随着日志的增长，日志会占用更多空间，并且需要花费更多时间进行重放。如果没有某种机制可以丢弃日志中累积的过时信息，这最终将导致可用性问题。因此需要定时去做 snapshot。</p><p>  <img src="/picture/Distributed/snapshot.png" alt="snapshot"></p><p>snapshot 会包括：</p><ul><li>状态机当前的状态。</li><li>状态机最后一条应用的 entry 对应的 index 和 term。</li><li>集群最新配置信息。</li><li>为了保证 exactly-once 线性化语义的去重表</li></ul><p>各个节点自行择机完成自己的 snapshot 即可，如果 leader 发现需要发给某一个 follower 的 nextIndex 已经被做成了 snapshot，则需要将 snapshot 发送给该 follower。注意 follower 拿到非过期的 snapshot 之后直接覆盖本地所有状态即可，不需要留有部分 entry，也不会出现 snapshot 之后还存在有效的 entry。因此 follower 只需要判断 <code>InstallSnapshot RPC</code> 是否过期即可。过期则直接丢弃，否则直接替换全部状态即可。 </p><p>snapshot 可能会带来两个问题：</p><ol><li>做 snapshot 的策略？<br>一般为定时或者定大小，达到阈值即做 snapshot，做完后对状态机和 raft log 进行原子性替换即可。</li><li>做 snapshot 时是否还可继续提供写请求？<br>一般情况下，做 snapshot 期间需要保证状态机不发生变化，也就是需要保证 snapshot 期间状态机不处理写请求。当然 raft 层依然可以去同步，只是状态机不能变化，即不能 apply 新提交的日志到状态机中而已。要想做的更好，可以对状态机采用 <code>copy-on-write</code> 的复制来不阻塞写请求。</li></ol><h3 id="Raft优化"><a href="#Raft优化" class="headerlink" title="Raft优化"></a>Raft优化</h3><p>先回顾一下简单的Raft流程</p><ol><li>Leader 收到 client 发送的 request。</li><li>Leader 将 request append 到自己的 log。</li><li>Leader 将对应的 log entry 发送给其他的 follower。</li><li>Leader 等待 follower 的结果，如果大多数节点提交了这个 log，则 apply。</li><li>Leader 将结果返回给 client。</li><li>Leader 继续处理下一次 request。</li></ol><p>可以看到，上面的流程是一个典型的顺序操作，如果真的按照这样的方式来写，那性能是完全不行的。</p><h4 id="读写分离——读优化"><a href="#读写分离——读优化" class="headerlink" title="读写分离——读优化"></a>读写分离——读优化</h4><p>Raft对外保证线性一致性。上述简单步骤所有读写请求都通过Leader来进行，并且读请求也会按照Log进行处理。因为 Raft 本来就是一个为了实现分布式环境下线性一致性的算法，所以通过 Raft 非常方便的实现线性 Read，也就是将任何的读请求走一次 Raft Log，等此 Log 提交之后在 apply 的时候从状态机里面读取值，一定能够保证这个读取到的值是满足线性要求的。</p><p>当然，因为每次 Read 都需要走 Raft 流程，Raft Log 存储、复制带来刷盘开销、存储开销、网络开销，走 Raft Log不仅仅有日志落盘的开销，还有日志复制的网络开销，另外还有一堆的 Raft “读日志” 造成的磁盘占用开销，导致 Read 操作性能是非常低效的，所以在读操作很多的场景下对性能影响很大，在读比重很大的系统中是无法被接受的，通常都不会使用。</p><p>所以可以考虑<strong>Read不按Log处理</strong>，因为<strong>读Leader其实可以完全确保读到最新的写入数据</strong>，所以只需要确保Leader处理读请求时还是Leader即可。</p><h5 id="ReadIndex"><a href="#ReadIndex" class="headerlink" title="ReadIndex"></a>ReadIndex</h5><p>当 Leader 需要处理 Read 请求时，Leader 与过半机器交换心跳信息确定自己仍然是 Leader 后可提供线性一致读：</p><ol><li>Leader 将自己当前 Log 的 commitIndex 记录到一个 Local 变量 ReadIndex 里面；</li><li>接着向 Followers 节点发起一轮 Heartbeat，如果半数以上节点返回对应的 Heartbeat Response，那么 Leader就能够确定现在自己仍然是 Leader；</li><li>Leader 等待自己的 StateMachine 状态机执行，至少应用到 ReadIndex 记录的 Log，直到 applyIndex 超过 ReadIndex，这样就能够安全提供 Linearizable Read，也不必管读的时刻是否 Leader 已飘走；</li><li>Leader 执行 Read 请求，将结果返回给 Client。</li></ol><p>使用 ReadIndex Read 提供 Follower Read 的功能，<strong>很容易在 Followers 节点上面提供线性一致读</strong>，Follower 收到 Read 请求之后：</p><ol><li>Follower 节点向 Leader 请求最新的 ReadIndex；</li><li>Leader 仍然走一遍之前的流程，执行上面前 3 步的过程(确定自己真的是 Leader)，并且返回 ReadIndex 给 Follower；</li><li>Follower 等待当前的状态机的 applyIndex 超过 ReadIndex；</li><li>Follower 执行 Read 请求，将结果返回给 Client。</li></ol><blockquote><p>ReadIndex Read 使用 Heartbeat 方式来让 Leader 确认自己是 Leader，省去 Raft Log 流程。相比较于走 Raft Log 方式，ReadIndex Read 省去磁盘的开销，能够大幅度提升吞吐量。虽然仍然会有网络开销，但是 Heartbeat 本来就很小，所以性能还是非常好的。</p><p>并且还能成功将<strong>读压力分散到了各个Follower上</strong>，一举两得。</p></blockquote><h5 id="Lease-Read"><a href="#Lease-Read" class="headerlink" title="Lease Read"></a>Lease Read</h5><p>虽然 ReadIndex Read 比原来的 Raft Log Read 快很多，但毕竟还是存在 Heartbeat 网络开销，所以考虑做更进一步的优化。Raft 论文里面提及一种通过 Clock + Heartbeat 的 Lease Read 优化方法，也就是 Leader 发送 Heartbeat 的时候首先记录一个时间点 Start，当系统大部分节点都回复 Heartbeat Response，由于 Raft 的选举机制，Follower 会在 Election Timeout 的时间之后才重新发生选举，下一个 Leader 选举出来的时间保证大于 Start+Election Timeout/Clock Drift Bound，所以可以认为 Leader 的 Lease 有效期可以到 Start+Election Timeout/Clock Drift Bound 时间点。Lease Read 与 ReadIndex 类似但更进一步优化，不仅节省 Log，而且省掉网络交互，大幅提升读的吞吐量并且能够显著降低延时。</p><p>Lease Read 基本思路是 Leader 取一个比 Election Timeout 小的租期（最好小一个数量级），在租约期内不会发生选举，确保 Leader 不会变化，所以跳过 ReadIndex 的第二步也就降低延时。由此可见 Lease Read 的正确性和时间是挂钩的，依赖本地时钟的准确性，因此虽然采用 Lease Read 做法非常高效，但是仍然面临风险问题，也就是存在预设的前提即各个服务器的 CPU Clock 的时间是准的，即使有误差，也会在一个非常小的 Bound 范围里面，时间的实现至关重要，如果时钟漂移严重，各个服务器之间 Clock 走的频率不一样，这套 Lease 机制可能出问题。</p><p>Lease Read 实现方式包括：</p><ol><li>定时 Heartbeat 获得多数派响应，确认 Leader 的有效性；</li><li>在租约有效时间内，可以认为当前 Leader 是 Raft Group 内的唯一有效 Leader，可忽略 ReadIndex 中的 Heartbeat 确认步骤(2)；</li><li>Leader 等待自己的状态机执行，直到 applyIndex 超过 ReadIndex，这样就能够安全的提供 Linearizable Read。</li></ol><blockquote><p>这个方法主要优化Leader提供的读服务。</p></blockquote><h4 id="Batch-amp-Pipeline"><a href="#Batch-amp-Pipeline" class="headerlink" title="Batch &amp; Pipeline"></a>Batch &amp; Pipeline</h4><p>使用Batch通常情况下能提升性能，写入不会只写入一个值，而是<strong>用一个Batch 缓存一批修改，然后再整个写入</strong>。 对于 Raft 来说，Leader 可以一次收集多个 requests，然后一批发送给 Follower。当然，我们也需要有一个最大发送容量来限制每次最多可以发送多少数据。</p><p>但只有Batch依旧要等待Follower返回才能继续后面的流程。其实这里可以做一个假定，通常Leader和Follower建立连接后就可以认为网络是互通的。Leader根据NextIndex变量指示发送给Follower的下一个发送Log的位置，所以当 Leader 给 Follower 发送了一批Log 之后，可以像Pipeline一样<strong>直接更新 NextIndex</strong>，并且立刻发送后面的 Log，不需要等待 Follower 的返回。如果网络出现了错误，或者 Follower 返回一些错误，Leader 就需要重新调整 NextIndex，然后重新发送 Log 了。</p><h4 id="并行添加日志"><a href="#并行添加日志" class="headerlink" title="并行添加日志"></a>并行添加日志</h4><p>Leader 可以先<strong>并行的将 log 发送给 Followers，然后再本地log append</strong>。为什么可以这么做，主要是因为在 Raft 里面，如果一个 log 被大多数的节点append（并回复Leader），我们就可以认为这个 log 是被 committed 了，所以即使 Leader 再给 Follower 发送 log 之后，自己 append log 失败 panic 了，只要 N / 2 + 1个 Follower 能接收到这个 log 并成功 append，我们仍然可以认为这个 log 是被 committed 了，被 committed 的 log 后续就一定能被成功 apply。</p><p>那为什么我们要这么做呢？主要是因为 append log 会涉及到落盘，有开销，所以我们完全可以在 Leader 落盘的同时让 Follower 也尽快的收到 log 并 append。</p><p>这里我们还需要注意，虽然 Leader 能在 append log 之前给 Follower 发 log，但是 Follower 却不能在 append log 之前告诉 Leader 已经成功 append 这个 log。如果 Follower 提前告诉 Leader 说已经成功 append，但实际后面 append log 的时候失败了，Leader 仍然会认为这个 log 是被 committed 了，这样系统就有丢失数据的风险了。 </p><h4 id="异步Apply"><a href="#异步Apply" class="headerlink" title="异步Apply"></a>异步Apply</h4><p>当一个log被大部分节点append并回复Leader收到commitIndex的更新后，我们就可以认为这个log被committed了，被 committed 的 log 在什么时候被 apply 都不会再影响数据的一致性。所以<strong>当一个 log 被 committed 之后，我们可以用另一个线程去异步的 apply 这个 log</strong>。</p><p>所以整个 Raft 流程就可以变成：</p><ol><li>Leader 接受一个 client 发送的 request。</li><li>Leader 将对应的 log 发送给其他 follower 并本地 append。</li><li>Leader 继续接受其他 client 的 requests，持续进行步骤 2。</li><li>Leader 发现 log 已经被 committed，在另一个线程 apply。</li><li>Leader 异步 apply log 之后，返回结果给对应的 client。</li></ol><p>使用 asychronous apply 的好处在于我们现在可以完全的并行处理 append log 和 apply log，虽然对于一个 client 来说，它的一次 request 仍然要走完完整的 Raft 流程，但对于多个 clients 来说，整体的并发和吞吐量是上去了。</p><h4 id="…-…"><a href="#…-…" class="headerlink" title="… …"></a><strong>… …</strong></h4><h3 id="Raft与客户端的交互"><a href="#Raft与客户端的交互" class="headerlink" title="Raft与客户端的交互"></a>Raft与客户端的交互</h3><p>虽然说 raft 算法只是一个 RSM，其只需要保证不同节点上的日志相同即可，其他的事情它都不需要关心。但是要想保证线性一致性语义，对于基于 raft 的 KV 往往还需要额外做一些事情，比如即使客户端会超时重试，也要保证日志的 exactly-once 执行。这也是Lab3需要解决的问题。</p><blockquote><p>即使写请求的业务语义能够保证幂等，但不进行额外的处理让其重复执行多次也会破坏线性一致性（毕竟会覆盖其他客户端的修改）。当然，读请求由于不改变系统的状态，重复执行多次是没问题的。</p></blockquote><p>对于这个问题，raft 作者介绍了想要实现线性化语义，就需要保证日志仅被执行一次，即它可以被 commit 多次，但一定只能 apply 一次。</p><p>基本思路便是：</p><ul><li>每个 client 都需要一个唯一的标识符，它的每个不同命令需要有一个顺序递增的 commandId，clientId 和这个 commandId，clientId 可以唯一确定一个不同的命令，从而使得各个 raft 节点可以记录保存各命令是否已应用以及应用以后的结果。</li></ul><p>为什么要记录应用的结果？因为通过这种方式同一个命令的多次 apply 最终只会实际应用到状态机上一次，之后相同命令 apply 的时候实际上是不应用到状态机上的而是直接返回的，那么这时候应该返回什么呢？直接返回成功吗？不行，如果第一次应用时状态机报了什么例如 key not exist 等业务上的错而没有被记录，之后就很难捕捉到这个执行结果了，所以也需要将应用结果保存下来。</p><p>如果默认一个客户端只能串行执行请求的话，服务端这边只需要记录一个 map，其 key 是 clientId，其 value 是该 clientId 执行的最后一条日志的 commandId 和状态机的输出即可。</p><p>raft 论文中还考虑了对这个 map 进行一定大小的限制，防止其无线增长。这就带来了两个问题：</p><ul><li>集群间的不同节点如何就某个 clientId 过期达成共识。</li><li>不小心驱逐了活跃的 clientId 怎么办，其之后不论是新建一个 clientId 还是复用之前的 clientId 都可能导致命令的重执行。</li></ul><p>这些问题在工程实现上都较为麻烦。比如后者如果业务上是事务那直接 abort 就行，但如果不是事务就很难办了。</p><blockquote><p>其实Raft还有一些容错性问题的细节本文没有提到，那些细小的场景有可能影响Raft的正确性，也应做相应处理，具体可以详见Raft论文。</p></blockquote><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol><li><a href="https://tanxinyu.work/raft/">潭新宇的博客</a></li><li><a href="https://hardcore.feishu.cn/docs/doccnMRVFcMWn1zsEYBrbsDf8De">硬核课堂Raft论文导读</a></li><li><a href="https://www.zhihu.com/question/382888510/answer/2368632206">潭新宇知乎回答</a></li><li><a href="https://mp.weixin.qq.com/s/jzx05Q781ytMXrZ2wrm2Vg">Raft 的 Figure 8 讲了什么问题？为什么需要 no-op 日志？</a></li><li><a href="https://www.sofastack.tech/blog/sofa-jraft-linear-consistent-read-implementation/">线性一致读SOFAJRaft</a></li><li><a href="https://zhuanlan.zhihu.com/p/25735592">TiKV Raft优化</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP Malloc Lab &amp; Shell Lab</title>
    <link href="/2022/02/20/CSAPP%E9%83%A8%E5%88%86Lab%E6%80%BB%E7%BB%93/"/>
    <url>/2022/02/20/CSAPP%E9%83%A8%E5%88%86Lab%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>主要为了复习面试，只针对CSAPP中的Malloc Lab与Shell Lab这两个Lab做一次复习整理。</p><span id="more"></span>]]></content>
    
    
    
    <tags>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NAT穿透 + CS144 Lab简述</title>
    <link href="/2022/02/08/Nat%20&amp;%20CS144/"/>
    <url>/2022/02/08/Nat%20&amp;%20CS144/</url>
    
    <content type="html"><![CDATA[<p>在面试完之后，发现自己计算机网络知识讲得非常不清楚。其中印象特别深的一个问题“两个不同内网的设备如何通信”回答得极差。于是自己在寒假里听了一遍中科大郑烇老师的课后，快速过了一遍CS144的Lab（参考学习了其他同学的实现）。本文将主要记录上述面试题的一部分答案——NAT穿透的细节并简述CS144 Lab的内容。【别问我为什么把这两个内容放在一起嘿嘿】</p><span id="more"></span><blockquote><p>本文不会介绍NAT的基本概念。直接讨论NAT潜在的问题与穿透技术。</p></blockquote><p>NAT/NAPT 都使用自己的转换表，因此会有以下的问题:</p><ul><li>外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。 </li><li>转换表的生成与转换操作都会产生性能开销。</li><li>通信过程中，如果 NAT 路由器􏰿启了，所有的 TCP 连接都将被􏰿置。</li></ul><p>针对以上的问题主要有两种方法。</p><p>第一种方法就是改用<code>IPv6</code>，这个很好理解，每个设备都有公网IP了就不需要转换地址了。不过目前还未全面普及。</p><p>另一种方法是NAT穿透技术。也就是本文将重点关注的技术。</p><h2 id="NAT穿透"><a href="#NAT穿透" class="headerlink" title="NAT穿透"></a>NAT穿透</h2><p>回到面试题“两个不同内网的设备如何通信”上，两个均位于NAT设备之后的设备无法主动发起相互通讯的请求。一个简单的想法就是通过一个位于公网的服务器充当建立维护连接与转发的工作，但是很明显的缺点也就是带宽可能会被这个位于公网的服务器限制，会产生效率瓶颈。要避免这个限制，即可在公网服务器建立好双方连接后，让双方直连。下面便会讨论这种方法的实现。</p><p>下面介绍NAT的4种限制类型，也就是NAT网关的类型，根据两个NAT网关不同的限制类型，共有10种组合方式（其中有当双方都为对称型或一方对称型一方端口限制型锥型时不易穿透）。</p><h4 id="NAT的限制类型"><a href="#NAT的限制类型" class="headerlink" title="NAT的限制类型"></a>NAT的限制类型</h4><p>根据NAT访问限制可以分为全锥型、IP受限锥型、端口受限锥型与对称型4种，限制逐渐增大。</p><ol><li>完全锥型：如果在NAT网关已经建立了一个NAT映射，那么任何外网的机器都可以通过这个映射来访问内网的电脑 </li><li>IP限制型锥型：如果在NAT网关已经建立了一个NAT映射，那么只有与其建立映射的ip才能通过NAT访问内网的电脑。</li><li>端口限制型锥型：这个类型名称不是很准确，其实限制的不只是端口，也同样限制IP可以理解为IP+端口限制型锥型。</li><li>对称型NAT：对称型NAT和端口限制型锥型是一样的，即对IP和端口都有限制，只有和其建立”连接”的IP和端口向其发送数据才不会被丢弃。 但是对称型NAT在内网设备<strong>即使主动使用相同的端口</strong>去和不同服务器或相同的服务器不同的端口建立连接时，NAT网关也会给其重新分配一个端口映射维护此“连接”关系。也就是一个完全1:1的关系，不会<strong>复用</strong>之前创建的映射关系。</li></ol><blockquote><p>两设备能否轻易打洞通信需要看双方NAT网关的类型。</p></blockquote><p>第一种：完全锥型NAT和完全锥型NAT进行穿透</p><p>假设A和B都是完全锥型NAT，在A和B都连接到server后，A和B都可以借助server的转发互相发送消息，那么此刻A和B就可以知道对方的公网ip，以及对方和server连接的时候，使用的端口是什么（假设是100），因为两者和server1进行通信的端口已经进行了NAT映射，所以二者的100端口其实已经完成映射，又因为二者都在完全锥型NAT下，此刻A只需要直接给B的100端口发送建立连接的请求，B给A的100端口回复同意建立连接的请求，二者即可建立UDP连接（当然UDP连接建立要比这复杂点，不过本文重点不在于如何建立UDP连接）</p><p>第二种：IP/端口限制型NAT和IP/端口限制型NAT进行穿透</p><p>假设A和B都是ip限制型NAT，在A和B都连接到server后，A和B都可以借助server的转发互相发送消息<strong>同样由于已经和Server建立连接，目前A、B都可以通过Server知道彼此NAT网关的IP及转换后的端口</strong>，A会先发送一个UDP请求（假设自己的NAT网关端口为100，目标NAT网关端口为200）到B的公网ip上，理论上来说，因为B的NAT网关中，200端口没有建立NAT映射，所以这个数据包会被丢弃，但是在A发送给B的UDP请求后，A会通过server给B发送一个邀请，邀请B也发送一个UDP请求给A（此刻B自己用的端口是200，目标端口是100），注意，<strong>在B收到来自A的UDP请求后，虽然A的数据包被B丢弃了，但是此刻，网关A暂时的建立了一个NAT映射，等待B返回的信息，虽然数据包已经被丢弃了，但是A不知道，所以A会稍微等一会B。这时，B收到了A的邀请，给A发送了一个建立连接的请求，此刻A的NAT网关恰巧暂时建立了NAT映射，所以A就可以收到B的UDP请求，接着A会给B发送一个同意建立连接的请求，因为此刻B刚发完请求在等A的回信，所以B的NAT网关也会暂时的建立一个NAT映射，所以A同意建立连接的请求就不会被B的NAT网关丢弃，最终，二者就建立了一个稳定的UDP连接</strong>。</p><p><img src="/picture/Network/nat.png" alt="NAT穿透"></p><p>第三种：对称型NAT与端口限制型/对称型NAT的穿透</p><blockquote><p>借助上述思想，我们就可以完成不需要服务器一直进行中转的内网穿透，那么为什么对称型NAT不能使用上述思想和对称型NAT穿透呢。 </p></blockquote><p>在第二种方法中，A邀请B给其发送一个UDP请求，在邀请的信息中，A指明了B的UDP请求的目标端口，因为在锥型NAT中，主机A的一个端口和NAT网关的映射是固定的，所以<strong>主机A可以通过Server知道自己给B发送请求是打开的端口是哪一个，也可以知道B给自己发送请求是打开的端口是哪一个</strong>，但是当换到对称NAT中时，由于一个连接对应NAT网关上的一个端口，所以主机A无法确定自己通过哪一个端口给B发信息，同样无法确定B会通过哪一个端口给自己发信息，所以二者无法建立连接。</p><p>那么端口限制型又为什么不能和对称型进行穿透呢，因为端口限制型对端口存在要求，但是我们无法确定对称型中分配的端口是哪一个，<strong>对称型NAT新建的映射信息是会被锥型NAT拒收的，数据无法进入内网，这个新的映射端口就只能靠猜了</strong>。</p><p><u><strong><em>简单说就是网关后的主机没法直接知道网关分配的端口是什么，如果锥型网关可以借助Server获取分配的端口信息，而对称型的由于无法确定这个分配的端口而难以进行打洞。</em></strong></u></p><blockquote><p>如果这里对称NAT使用顺序增加策略，那么，B将两次被分配的NAT端口发送给Server后，Server就可以通知A在这个端口范围内猜测刚才B发送给它的socket中被NAT映射后的端口，A很有可能在孔有效期内成功猜测到端口号，从而和B成功通信。</p></blockquote><h4 id="NAT打洞与P2P的关系"><a href="#NAT打洞与P2P的关系" class="headerlink" title="NAT打洞与P2P的关系"></a>NAT打洞与P2P的关系</h4><p>由于目前大多数端设备都在NAT网关之后，所以若两台设备想要进行P2P连接就必须先进行NAT打洞操作。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><blockquote><p> <a href="https://juejin.cn/post/6844904098572009485">NAT基本原理及穿透详解(打洞)</a></p><p><a href="https://www.bilibili.com/read/cv6189209?spm_id_from=333.999.0.0">B站最详细内网穿透原理</a></p></blockquote><blockquote><p>突然换题！主要是写给自己看的…</p></blockquote><h2 id="CS144-Lab"><a href="#CS144-Lab" class="headerlink" title="CS144 Lab"></a>CS144 Lab</h2><p>简单记录各个Lab完成的任务，自己还没能全部完成。</p><h4 id="lab-0"><a href="#lab-0" class="headerlink" title="lab 0"></a>lab 0</h4><ul><li>使用telnet &amp; netcat等命令发送和接受应用层的数据</li><li>使用sponge自带的功能那个接口写一个简单的套接字webget程序</li><li>实现ByteStream作为TCP连接的最底器的容器（有限的内存网络流队列）</li></ul><h4 id="lab-1"><a href="#lab-1" class="headerlink" title="lab 1"></a>lab 1</h4><ul><li><p>在ByteStream的基础上实现StreamReassembler</p><ul><li><p>解决数据包的<strong>重复</strong>、<strong>重叠</strong>、<strong>乱序</strong>问题（暂时不用考虑丢包问题）</p><blockquote><p>使用拥有排序能力的数据结构如 <strong><em>红黑树</em></strong> 存储未整合好的数据，新插入的数据包分别不断和左右节点合并看是否整合完毕。</p></blockquote></li></ul></li></ul><h4 id="lab-2-amp-3"><a href="#lab-2-amp-3" class="headerlink" title="lab 2 &amp; 3"></a>lab 2 &amp; 3</h4><ul><li>TCP receiver<ul><li>基于收到包的连续性的假设，正确转换32位的seq到64位的index</li><li>将收到的包传给StreamReassembler</li><li>计算出正确的ackno</li><li>计算出正确的window_size，以通知发送方实现流量控制</li></ul></li><li>TCP sender<ul><li>TCP<strong>可靠</strong>数据传输机制的实现<ul><li>定时器(单一的重传定时器)</li><li>序号和确认(确认是被捎带在数据报文段中的)</li></ul></li><li>TCP连接管理:SYN和FIN</li><li>实现流量控制的另一部分，发送方根据接收方的窗口大小调整流量</li></ul></li></ul><h4 id="lab-4"><a href="#lab-4" class="headerlink" title="lab 4"></a>lab 4</h4><ul><li>TCP connection<ul><li>整合sender和receiver实现TCP过程</li><li>TCP状态机：三次握手，正常通信，四次挥手（jyy所说的画状态机模型真的很有用，每个Lab都用到了！）</li></ul></li></ul><h4 id="lab-5"><a href="#lab-5" class="headerlink" title="lab 5"></a>lab 5</h4><ul><li>实现一个network interface，也就是网卡以及arp协议</li><li>网卡中有一个arp表，实现ip地址和mac地址的转换，它通过arp协议自动生成，每个表项都会过期</li><li>arp协议是一个链路层和网络层中间的协议，它在层次关系上和ip（网络层）很像，我们需要把arp包封装为一个以太网包（或其他链路层帧）发送出去，因而在体系结构上位于链路层之上，但是一个arp分组具有包含链路层地址的字段，因而也可认为是链路层协议。</li><li>借由链路层的广播帧，可以将arp分组发送给所有人，从而得到预期的回复</li></ul><h4 id="lab-6"><a href="#lab-6" class="headerlink" title="lab 6"></a>lab 6</h4><ul><li>实现一个路由器，对应网络层的数据平面，根据输入的规则，按照最长前缀匹配规则转发</li><li>基于lab 5的network interface：一个路由器有多个interface</li></ul><p>基本除了拥塞控制，其余TCP主体部分都有相应的实现。自己实验做得很粗糙，就不多妄加评论了。</p><h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><blockquote><p>  <a href="https://segmentfault.com/a/1190000040775305">CS144-计算机网络学习笔记</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Lab</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15-445课程知识点复习 &amp; 总结</title>
    <link href="/2022/02/01/CMU15-445%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/02/01/CMU15-445%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>本文将进行CMU15-445的知识点巩固与复习。</p><p>复习点参考<code>博主：西部小笼包</code>与<a href="https://zhenghe.gitbook.io/">一份很不错的数据库笔记</a>进行整理，我进行了参考并加入了一点自己的见解。</p><span id="more"></span>    <h2 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h2><h4 id="1-为什么需要数据库系统？文件系统不够吗？"><a href="#1-为什么需要数据库系统？文件系统不够吗？" class="headerlink" title="1. 为什么需要数据库系统？文件系统不够吗？"></a>1. 为什么需要数据库系统？文件系统不够吗？</h4><p>首先是更好得解耦，对所需存储的数据的建模（不同场景不同模型）这些逻辑可与物理存储层分离。并且类似查询检查保证数据一致性的逻辑也可以与业务代码分离。</p><p>其次磁盘IO是比较昂贵的，相较于基于操作系统mmap等机制对于内存磁盘的交互，数据库系统拥有更多的信息去更好地决定何时将内存页刷入磁盘。数据库会有一个Buffer Pool Manager组件进行管理，制定专属的淘汰策略。</p><h4 id="2-数据库底层是如何存储的？"><a href="#2-数据库底层是如何存储的？" class="headerlink" title="2. 数据库底层是如何存储的？"></a>2. 数据库底层是如何存储的？</h4><p>数据库的存储为了移植性一般基于文件系统。DBMS 通常将自己的所有数据作为一个或多个文件存储在磁盘中，而 OS 只当它们是普通文件，并不知道如何解读这些文件。</p><p>数据库会按照Page为存储单位进行存储（类似文件系统Block的概念）。每个 Page 带着一个唯一的 id。数据库会用一个间接层做通过PageID &lt;—&gt; 物理实际地址的映射。</p><p>数据库会有一个storage manager模块负责读写磁盘上的对应Page，同时保持较好的空间和时间的局部性。数据文件在底层会有不同的组织形式，比较常见的是无序的HEAP FILE， 或者是有序的聚集索引（B树），还有一种是HASH FILE。</p><h4 id="3-HEAP-FILE-内部是怎么组织变成一个数据库的？"><a href="#3-HEAP-FILE-内部是怎么组织变成一个数据库的？" class="headerlink" title="3.HEAP FILE 内部是怎么组织变成一个数据库的？"></a>3.HEAP FILE 内部是怎么组织变成一个数据库的？</h4><p>这里不讨论链表的方式，主要讨论页目录（Page Directory）的方式。</p><p>这种方式会有一些页目录会记录全部数据文件的位置，同时也记录了每一个页的FREE SLOT数量（即使用情况）。</p><p>具体数据页的存储有两种方式，一种记录数据本身采用Slotted Page（下左图），另一种记录操作数据的日志（定期会压缩日志）。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/picture/Database/slotted_page.png" alt="slotted page"></div><div class="group-image-wrap"><img src="/picture/Database/log_structed_page.png" alt="log structed page"></div></div></div><p>对于Slotted Page，每一个TUPLE 在DBMS里会即会有以page_id + offset/slot的二元组唯一定位。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h4 id="4-Hash表主要关注什么？静态、动态HASH算法有哪些区别是什么？"><a href="#4-Hash表主要关注什么？静态、动态HASH算法有哪些区别是什么？" class="headerlink" title="4.Hash表主要关注什么？静态、动态HASH算法有哪些区别是什么？"></a>4.Hash表主要关注什么？静态、动态HASH算法有哪些区别是什么？</h4><p>Hash 函数的选择，就是在性能和冲突率之间的TRADE OFF。另外就是冲突之后的策略选择。其实是在开一个更大的表和找到其他地方去插KEY的TRADE OFF。</p><p>静态Hash算法（要求事先知道存多少元素，否则就需要在一定时间对整个表做扩容和缩容然后rehash）：</p><ol><li>线性扫描</li><li>Robin（目的是让每次扫描次数差不多）</li><li>Cuckoo（两张表）</li></ol><p>动态扩容的Hash算法：</p><ol><li>Chained Hash （桶满了加桶）</li><li>Extenible Hash（桶满了后增加hash匹配位数，变相增加桶数）</li><li>Linear Hash（维护一个指针指向下一个被拆分的桶）</li></ol><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/picture/Database/chained_hash.png" alt="chained hash"></div><div class="group-image-wrap"><img src="/picture/Database/extenible_hash.png" alt="extenible hash"></div><div class="group-image-wrap"><img src="/picture/Database/linear_hash.png" alt="linear hash"></div></div></div><h4 id="5-B-树有哪些性质？"><a href="#5-B-树有哪些性质？" class="headerlink" title="5. B+树有哪些性质？"></a>5. B+树有哪些性质？</h4><ol><li>他是完美平衡的，所有叶子节点的深度一致。</li><li>每个非根节点至少是半满的。（如果最多有M个孩子，那么至少会有[M / 2 - 1, M - 1]个key ）</li><li>每个内部节点有K个KEY，就会有K + 1个孩子。</li></ol><h4 id="6-B-树的设计策略：B树节点的SIZE如何选择？合并阈值？"><a href="#6-B-树的设计策略：B树节点的SIZE如何选择？合并阈值？" class="headerlink" title="6. B+树的设计策略：B树节点的SIZE如何选择？合并阈值？"></a>6. B+树的设计策略：B树节点的SIZE如何选择？合并阈值？</h4><p>一般存储设备IO开销越大，速度越慢，节点就需要越大。具体情境下的最优大小由 workload 决定。</p><p>对于节点的合并有些 DBMS 选择延迟 merge 操作的发生时间，甚至可以利用其它进程来负责周期性地重建 table index。</p><h4 id="7-B-树有哪些常见优化？"><a href="#7-B-树有哪些常见优化？" class="headerlink" title="7. B+树有哪些常见优化？"></a>7. B+树有哪些常见优化？</h4><p>1． 前缀压缩，如果这个节点的STRING 都是以ABC，开头，可以把这个ABC提出来，这样之后的信息都会少，就能存更多。</p><p>2． 后缀截断【较常用】。如果后缀的信息没有区分度，则在中间节点的时候可以砍掉。</p><p>3． 指针调整，如果一个PAGE已经再BUFFER POOL 里PINNED了，我们可以存直接的指针来代替原来存的PAGE ID。来避免去PAGE TABLE 查ADDRESS。</p><p>4． 批量插入【常用】。如果一开始你就知道要插的所有KEY，可以对他们先排序，然后对这些KEY去构建INDEX BOTTOM UP。这样性能最好。</p><h4 id="8-什么是聚簇-非聚簇索引、隐式索引、局部索引、覆盖索引、包含索引-index-include-column-？"><a href="#8-什么是聚簇-非聚簇索引、隐式索引、局部索引、覆盖索引、包含索引-index-include-column-？" class="headerlink" title="8. 什么是聚簇/非聚簇索引、隐式索引、局部索引、覆盖索引、包含索引(index include column)？"></a>8. 什么是聚簇/非聚簇索引、隐式索引、局部索引、覆盖索引、包含索引(index include column)？</h4><blockquote><p>Todo…</p></blockquote><h4 id="9-什么是Latch-Crabbing，此方法是如何加锁索引的？"><a href="#9-什么是Latch-Crabbing，此方法是如何加锁索引的？" class="headerlink" title="9. 什么是Latch Crabbing，此方法是如何加锁索引的？"></a>9. 什么是Latch Crabbing，此方法是如何加锁索引的？</h4><p>首先拿父PAGE的LATCH， 然后拿孩子的LATCH。如果父节点是SAFE（不会引起分裂、合并操作）的则释放父PAGE的LATCH。</p><p>查的时候，拿到孩子的读锁就可以释放父亲的读锁。</p><p>删增的时候，拿写锁，如果某一个孩子是SAFE的，可以释放祖先持有的全部锁</p><p>其余一个优化是可以先假设叶子节点是安全的，在一开始可以只上读锁。如果发现这个假设是错的，再重头来一遍写锁。</p><p>如果要同时支持LEFT-&gt;RIGHT， TOP-&gt;BOTTM <strong>两个方向</strong>的节点查找，当发现锁被占有了，最好的方式是等一小会然后杀掉自己，重头开始。</p><p>另一个优化是把PARENT节点的更新延迟到下次获取写锁的时候再更新（通过一个全局变量记录需要更新的节点）。</p><h2 id="排序、聚合和Join"><a href="#排序、聚合和Join" class="headerlink" title="排序、聚合和Join"></a>排序、聚合和Join</h2><h4 id="10-如果有108个页，内存只能容下5页，如何做硬盘外排序？"><a href="#10-如果有108个页，内存只能容下5页，如何做硬盘外排序？" class="headerlink" title="10. 如果有108个页，内存只能容下5页，如何做硬盘外排序？"></a>10. 如果有108个页，内存只能容下5页，如何做硬盘外排序？</h4><p>首先每次放进内存5个页，对5个页排序，写到磁盘的一个文件里。这样最后会有22个文件。</p><p>下一次开始做K路归并，把4个文件放进去BUFFER里，然后流式读文件。还余下的一个文件的位置是用来当PQ，每次输出一个最小的写进磁盘。这样搞完之后。就还有22/4 = 6个文件。</p><p>下一步同样，变成2个文件。最后合到一个有序文件。<br><img src="/picture/Database/2-way.png" alt="2-way外排"></p><h4 id="11-GROUP-BY-、DISTINCT-应该怎么做？"><a href="#11-GROUP-BY-、DISTINCT-应该怎么做？" class="headerlink" title="11. GROUP BY 、DISTINCT 应该怎么做？"></a>11. GROUP BY 、DISTINCT 应该怎么做？</h4><p>一般有两种聚合方法，一种是Sorting Aggregation，另一种是Hashing Aggregation。</p><p>当然第一种排序聚合的方法需要做一遍外排，然后按顺序即可轻松进行GroupBy和Distinct操作，不过这样的方法开销会大一点，一般对于无排序要求的情况会采用Hash聚合。</p><p>Hash聚合<strong>利用一个临时的Hash Table</strong>来记录必要的信息。</p><ul><li>首先将相同的key哈希进一个partition中（使用 1 个 page 读数据，B-1 个 page 写出 B-1 个 partition 的数据），partition满了就刷进磁盘。</li><li>在内存中针对每个 partition 利用一个临时的Hash Table计算 aggregation 的结果<ul><li>如果我们发现相应的 GroupKey 已经在内存中，只需要更新 RunningVal 就可以</li><li>反之，则插入新的 GroupKey 到 RunningVal 的键值对</li></ul></li></ul><p>由于这里的两阶段假设一个Partition可以被完整得读入内存之中因此能够聚合的表最大为 B × (B − 1)。</p><p>如果表更大，则阶段要更复杂一点，需要更多轮。</p><p><img src="/picture/Database/hash_aggregation.png" alt="Hash Aggregation"></p><h4 id="12-Join如何做？"><a href="#12-Join如何做？" class="headerlink" title="12. Join如何做？"></a>12. Join如何做？</h4><p>这里只讲两张表的Join。</p><p>Join方法很多，最直观的就是一个对于A表的每一个Tuple，去遍历B表找到满足要求的Tuple合并。这也叫Nested Loop Join。一个很直观的优化就是两表Join，选数据量小的表作内循环。如果Join的对象在两表都有索引也可以避免内部循环，可以直接找到对应的项。</p><p>还有优化的做法是可以用Sort-Merge Join。先分别对外层表和内层表按照JOIN KEY 要做好排序。然后Merge时同时从两表的一端开始双指针扫描去配对。这里要注意的是如果JOIN KEY不唯一可能需要外表指针回溯，内表指针无论Key唯不唯一都可能回溯。</p><p>Boss方法就是<strong>Hash Join</strong>：核心思想就是满足Join条件的Tuple对于JOIN KEY进行哈希必然相等。因此只需对两个表中哈希得到相同值的Tuples分别进行Join操作即可。</p><p>我们可以对2个表的数据分别PARTITION 到不同文件，用相同的HASH 函数。随后读出这2个文件，2重FOR循环。如果一次PARTITION还是没法全部读进内存。可以使用第2个HASH函数。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/picture/Database/basic_hash_join.png" alt="basic hash join"></div><div class="group-image-wrap"><img src="/picture/Database/grace_hash_join.png" alt="grace hash join"></div></div></div><p>对于basic hash join，如果想更快检测s表tuple是否在哈希表中（哈希表如果太大无法全放在内存中），还可以在创建哈希表时使用布隆过滤器！</p><h2 id="查询过程与优化"><a href="#查询过程与优化" class="headerlink" title="查询过程与优化"></a>查询过程与优化</h2><h4 id="13-描述一下一个执行计划数据系统是怎么做的？"><a href="#13-描述一下一个执行计划数据系统是怎么做的？" class="headerlink" title="13. 描述一下一个执行计划数据系统是怎么做的？"></a>13. 描述一下一个执行计划数据系统是怎么做的？</h4><p>Iterator迭代模型。每一个关系函数会实现自己的NEXT方法，下层的NEXT函数会被上层的算子调用。构建出自己的NEXT函数。而根节点的NEXT函数，就可以直接取到这个QUERY 要的一行行数据。</p><p>Materialization物化模型则是把数据准备好一齐返回给上层，而迭代模型是流式的。</p><p>Vectorization矢量模型是一个折中，它会暴露NEXT函数，之后是批量返回需要的数据。</p><p><img src="/picture/Database/query_execution.png" alt="Query Execution"></p><table><thead><tr><th>模型</th><th>方向</th><th>Emits</th><th>使用场景</th></tr></thead><tbody><tr><td>Iterator/Volcano</td><td>Top-Down</td><td>Single Tuple</td><td>General Purpose</td></tr><tr><td>Vectorized</td><td>Top-Down</td><td>Tuple Batch</td><td>OLAP</td></tr><tr><td>Materialization</td><td>Bottom-Up</td><td>Entire Tuple Set</td><td>OLTP</td></tr></tbody></table><h4 id="14-描述一下几种常见的访问数据的方法？（access-method）"><a href="#14-描述一下几种常见的访问数据的方法？（access-method）" class="headerlink" title="14. 描述一下几种常见的访问数据的方法？（access method）"></a>14. 描述一下几种常见的访问数据的方法？（access method）</h4><p>三种方法：顺序扫描、索引扫描与BITMAP SCAN（用多个索引，求交集之后再返回结果）</p><p>最基本的就是顺序扫描。数据库维护一个当前扫完的页的指针。优化方式有，<strong>预取</strong>，<strong>缓存池绕过</strong>，<strong>统计信息检查</strong>（比如这页的最大值是300，你要查400以上的数据，就可以跳过该页），延迟物化，这里就是每个算子知道上层用不到哪些列，可以去更新OFFSET，让上层可以不用管他用不到的列信息。</p><p>其次是索引扫描，就是优化器会挑选最适合的索引去走索引文件。当然如果走非聚集索引，需要回表，这里有一个优化就是，把那些要回表的PAGE ID先存起来，然后把PAGE ID 排序，这样就可以顺序把需要的PAGE 都取好，读起来会比查一个找一个快很多。</p><h4 id="15-WHERE语句的判断是怎么实现的？"><a href="#15-WHERE语句的判断是怎么实现的？" class="headerlink" title="15. WHERE语句的判断是怎么实现的？"></a>15. WHERE语句的判断是怎么实现的？</h4><p>DBMS 使用 expression tree 来表示一个 WHERE 语句。然后根据 expression tree 完成数据过滤的判断，即依次取算看树根最后是不是TRUE，但这个过程比较低效，很多 DBMS 采用 <strong>JIT Compilation</strong> 的方式，直接将比较的过程编译成机器码来执行，提高 expression evaluation 的效率。</p><h4 id="16-QUERY-是怎么从用户输入到最后变成可执行的计划的？"><a href="#16-QUERY-是怎么从用户输入到最后变成可执行的计划的？" class="headerlink" title="16. QUERY 是怎么从用户输入到最后变成可执行的计划的？"></a>16. QUERY 是怎么从用户输入到最后变成可执行的计划的？</h4><p>首先SQL QUERY会经过重写器，这里会根据一些固定的模式对QUERY做改写，随后会经过PARSER生成一颗语法树，语法树的节点去查system catalog会把一些人可以读懂的关键词转换为系统内部的INTERNAL ID。 然后交给tree rewriter看下这颗树可不可以优化。到这里产生出了逻辑计划。逻辑计划结合一些基于统计样本的COST MODEL 再做一层优化生成出物理执行计划。</p><p>常见的基本逻辑优化有<strong>谓词下放</strong>（提前缩小数据行范围）、<strong>投影下方</strong>（提前缩小数据列范围）、一些表达式重写（表达式删除，合并谓词，连接消除等）</p><h4 id="17-说一下物理计划的优化？"><a href="#17-说一下物理计划的优化？" class="headerlink" title="17. 说一下物理计划的优化？"></a>17. 说一下物理计划的优化？</h4><blockquote><p>这应该是数据库最最最最难的部分了。</p></blockquote><p>首先就是基于<strong>统计</strong>，数据库会对每个表计算一些统计信息。比如最常用的就是一个列的选择度。就是这个列的DISTINCT值。 然后如果假设这些值分布均匀我们是可以估计出所有谓词的选择度， 比如范围: sel(A &gt;= a) = (Amax − a/(Amax − Amin))。如果不均匀，也有2种方法，一种是建立均匀的桶。 这里其实是一道算法问题。就是给你每个KEY 的FRENCY，你要装进10个桶，使得每个桶的SIZE的差值最小。</p><p>另外一种方式是抽样。根据抽象数据去判断谓词的选择度。这个选择度在JOIN TABLE时非常重要，我们希望外层表越小越好。</p><p>下一步优化器会枚举出所有的可能的执行计划，并且计算他们的COST，然后选择COST最小的一个。对OLTP来说，这通常是简单，因为只要选对最佳的INDEX就可以。</p><p>但是OLAP通常会有多关系JOIN，随着JOIN数量增多，计划数的可能呈指数上升。</p><p>IBM最开始引入只考虑LEFT-DEEP JOIN（<strong>剪枝</strong>）， 是为了更好的利用PIPELINE，这样可以不用把JOIN出来的结果序列化到磁盘。可以流式的去做。</p><p>接下来的可以枚举所有LEFT-DEEP TREE的顺序，枚举每个JOIN是用哪种JOIN算法，枚举每个表是用INDEX SCAN 还是SEQ SCAN。 然后用动态规划的方式取算出最小的代价的方式。如果要JOIN的表很多时，我们可以使用遗传算法来找到较优解。</p><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>这里先简单讲一下数据库中一个非常重要的抽象——<strong>事务</strong>。</p><p>事务最关键的就是四个特性 ACID：</p><p>A就是原子性，事务里的操作要么全做成了，要么全没做成。这个背后的机制可以使用LOG来实现，也可以通过SHADOW PAGING来实现。</p><p>C是一致性，代表执行事务前如果状态是一致的，那么之后也是一致的。（这也是最终目的）</p><p>I是隔离性，虽然有很多事务会并行在做，但是每个提交的事务自己看上去会是只有自己在做。就是并行的事务不会相互影响。</p><p>D就是可持久性，所有事务提交的数据不应该丢失。</p><p>对于并发控制主要就是I（隔离性）的相关问题。</p><p>对于两个事务，不同事务中的操作穿插执行会带来一些错误。因此需要一些控制策略去限制操作的执行顺序。</p><p>对于限制操作执行顺序的程度，常见事务的隔离程度分为三个级别：read committed、snapshot/repeatable read 以及 serializable。相关竞争条件罗列如下：</p><table><thead><tr><th>竞争条件</th><th>描述</th><th>最低有效隔离级别</th></tr></thead><tbody><tr><td>脏读</td><td>clientA 读到 clientB 写入但还未 commit 的数据</td><td>Read Committed</td></tr><tr><td>脏写</td><td>clientA 覆盖 clientB 写入但还未 commit 的数据</td><td>Read Committed</td></tr><tr><td>不可重复读</td><td>client 在事务进行的不同时间点上读取不同状态的数据</td><td>Snapshot Isolation</td></tr><tr><td>更新丢失</td><td>clientA 和 clientB 同时执行一个 read-modify-write 事务，clientA 在 clientB 不知情的情况下覆盖了 clientB 写入的数据，数据丢失且失去记录。</td><td>Snapshot Isolation</td></tr><tr><td>幻读</td><td>clientA 根据某种搜索条件读取一组数据，同时 clientB 正执行的写操作改变着 clientA 读取的数据集合。</td><td>Snapshot Isolation</td></tr><tr><td>写倾斜</td><td>clientA 读取某数据，并根据该数据的值做出另一个写数据的决定，然而在 clientA 写数据时，它读取的数据被 clientB 写入新的值，这使得 clientA 之前的决定的假设不成立</td><td>Serialization  Isolation</td></tr></tbody></table><p>弱事务隔离级别只能保护应用不受以上竞争条件中的部分情况影响，因此应用开发者需要对数据库提供的保证有正确的了解，只有 serializable isolation 可以防止以上所有竞争条件带来的影响。</p><blockquote><p>通过<strong>MVCC</strong>多版本并发控制这一<code>基础设施</code>可以轻松实现Read Committed和Snapshot Isolation。</p></blockquote><blockquote><p>对于Serialization Isolation则有悲观与乐观两大类方法去实现。 悲观主要方法是<strong>2PL</strong>，乐观的主要方法是<strong>OOC</strong>。</p></blockquote><h4 id="18-什么是2PL？"><a href="#18-什么是2PL？" class="headerlink" title="18. 什么是2PL？"></a>18. 什么是2PL？</h4><p>简单来说就是一个事务拿锁和还锁分为2个阶段，第一个阶段你可以拿，一旦你还了就到了第二个阶段，之后就不能再拿锁了。不过普通的2PL会造成级联Abort。比如第一个事务上来拿了锁A，并还了A，第二个事务拿到A开始做事情了，然后第一个事务ABORT了。第二个事务也只能ABORT。</p><p>如果不级联ABORT，就会脏读。当然还会引起死锁的问题。解决脏读问题可以靠严格二阶段锁定。严格2PL只在再事务结束时才释放所有锁。</p><p><img src="/picture/Database/schedule_level.png" alt="Schedule Level"></p><h4 id="19-死锁发生了怎么办？"><a href="#19-死锁发生了怎么办？" class="headerlink" title="19. 死锁发生了怎么办？"></a>19. 死锁发生了怎么办？</h4><p>两个办法，一是启用一个线程进行死锁检测，数据库系统会构建事务之间锁依赖的有向图，如果有环就代表有死锁了。当发现了环，他会选择一个要事务去让他ROLLBACK来打破这个环。这个被牺牲的事务可以ABORT或者重试。这中间是对检测死锁的频率，和事务的等待死锁解开时间的trade-off。</p><p>二是死锁预防。在申请已被持有的锁时就根据锁持有方的优先级（新/老程度等）决定等待或是抢锁（或自身回滚）。</p><h4 id="20-如果一个事务要更新10万行，那他要拿10万把锁吗？"><a href="#20-如果一个事务要更新10万行，那他要拿10万把锁吗？" class="headerlink" title="20. 如果一个事务要更新10万行，那他要拿10万把锁吗？"></a>20. 如果一个事务要更新10万行，那他要拿10万把锁吗？</h4><p>不需要，这里涉及到锁的粒度。粒度可以是TUPLE，可以是PAGE，也可以是TABLE。这里会引入意向锁，可以提高并发度，以及减少实际需要的锁用量。在父节点上IS（意向共享锁），代表需要在之后需要更细粒度的S LOCK。 如果上的是IX，就意味在接下来更细粒度需要X LOCK。 SIX 锁就等价于上了S锁 加IX锁。2个规则是如果要上S或者IS锁，那么父节点必须要有IS锁。如果要上IX,X,SIX，那么父节点必须要有IX锁。</p><p>当获得太多的细粒度锁的时候，锁会升级为粗粒度的锁。</p><h4 id="21-什么是OOC"><a href="#21-什么是OOC" class="headerlink" title="21. 什么是OOC?"></a>21. 什么是OOC?</h4><p>乐观锁其乐观表现在事务访问数据时无需显式加锁（通过附带时间戳等信息进行检测），主要原理是在发生不符合规则的冲突后解决冲突，重启事务。</p><p>OCC 分为3个步骤，READ、VALIDATION、 WRITE。核心思想就是先把数据库的内容读到自己的私有空间，要在提交时，去检测有没有和其他的事务有读写冲突，或者写读冲突。这里分为forward validation 和 backward validation，如果顺利，就可以进入write phase 把自己私有空间的内容刷进DB。OCC的问题是有复制数据的OVERHEAD，还有VALIDATION 和写是瓶颈，如果发生了ABORT，浪费的操作比2PL更多（因为没法提前知道出了问题，直到VALIDATION PHASE）</p><h4 id="22-简单介绍一下MVCC？"><a href="#22-简单介绍一下MVCC？" class="headerlink" title="22. 简单介绍一下MVCC？"></a>22. 简单介绍一下MVCC？</h4><p>早期数据库不论读取还是写入，都用锁来实现。但是锁会带来性能的问题。人们尝试各种优化方案。写入和读取的优化方式不同。对于写入操作，没有特别好的办法，人们实现主要就是上述几个问题的乐观锁与悲观锁。而对于读取操作，优化就是MVCC，<strong>对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁</strong>。</p><p>MVCC是一套很大的概念。主要思想是想要<strong>读不阻塞写，写不阻塞读</strong>。简而言之，实现 MVCC 的 DBMS 在内部维持着单个逻辑数据的多个物理版本，当事务修改某数据时，DBMS 将为其创建一个新的版本；当事务读取某数据时，它将读到该数据在事务开始时刻之前的最新版本。由此非常容易实现Read Committed和Snapshot Isolation两个隔离级别（如实现可重复读即总是读取当前事务开始之前最后一次commit的版本）。</p><p>它分为4块组成。</p><p>第一块是选择一种并发控制协议，比如可以是T/O, OCC, 或者2PL。</p><p>第二块是存多版本的方法。</p><p>第三块是垃圾回收的方法，分为TUPLE级别的GC和事务级别的GC。</p><p>第四块是索引管理。</p><p>细节太多部分感兴趣的读者可以自行查阅… …</p><h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><p>关于可靠的持久性。首先数据库要采取一些行动在当事务正在运行的时候，来保证DBMS可以从失败恢复。然后在重启的时候需要采取一些动作来恢复之前的状态确保ACID的性质。</p><h4 id="23-事物在执行时需要采取什么行动来确保故障能够恢复？"><a href="#23-事物在执行时需要采取什么行动来确保故障能够恢复？" class="headerlink" title="23. 事物在执行时需要采取什么行动来确保故障能够恢复？"></a>23. 事物在执行时需要采取什么行动来确保故障能够恢复？</h4><p><strong>WAL</strong>（Write Ahead Log）。另一种Shadow Page的方法不怎么用就不说了。WAL使用的是Steal + No force策略，即BUFFER POOL可以在事务未提交前，就把脏页刷到磁盘；并且事务在提交时不一定要把事务涉及到的脏页全部刷盘。</p><p>那么关于WAL什么时候刷入磁盘。一种是当一个WAL LOG BUFFER PAGE写满的时候，会触发一次刷盘。同时第二个页可以用来写，这样性能非常好，另外一种情况，就是过了一定的时间，也会触发一次刷盘。其次就是事务提交时会触发刷盘。</p><p>WAL的日志具体记录什么样的Log分为3种格式：一种是物理日志，存的就是具体的页的位偏移改了什么。缺点是如果一个SQL改了10W条数据，那么就会有这么多的LOG信息。优点是更加细节，不易出错，更容易恢复。另一种是逻辑日志，基本就是把SQL语句给存下来。优点是磁盘占用空间小。缺点是并发事务时日志会不准，数据可能会不一致。而且恢复起来会更慢。最后一种是半物理日志，他存的是具体的页的数据信息但是和页的数据组织无关。会更加通用，且易在上面做优化。可以其他下游系统去读取。</p><p>DBMS会周期性的打CHECKPOINT， 凡是打了CHECKPOINT的位置在这之前已经COMMIT的TX一定是已经落盘了。所以关于这些的WAL就可以回收掉的。最简单的打CHECKPOINT的方式就是停掉所有TXN，然后开始刷盘，然后再日志上打一个CHECKPOINT记录。然后恢复停掉的TXN继续做。所有在CHECKPOINT后开始的事务，在CRASH前没提交，需要UNDO。在CRASH前提交了，需要REDO。</p><h4 id="24-在故障发生后如何恢复数据库？"><a href="#24-在故障发生后如何恢复数据库？" class="headerlink" title="24. 在故障发生后如何恢复数据库？"></a>24. 在故障发生后如何恢复数据库？</h4><p><strong>ARIES</strong>。此机制肯定要借助WAL。</p><p>第一步是分析，目标是得到CRASH时刻的ATT和DPT，从MASTER RECORD开始读所有日志，然后更新ATT（活跃事务表）和DPT（脏页表）。</p><p>第二步是根据DPT里最小的LSN （日志序号）我们就可以把这之后的所有操作都在内存中REDO，如果有TXN-END，就可以更新ATT。</p><p>第三步是就是余下的ATT表里都是没做完的TXN，需要UNDO，把他们UNDO掉。</p><blockquote><p>关于Fuzzy checkpoint：其实就是内存中维护了ATT和DPT两张表，Checkpoint只是将这两张表写入到了日志之中，并没有将实际所有脏页刷盘（所以不会阻塞活跃的事务）。分析阶段就是从Begin开始重建这两张表，Redo阶段即要从DPT里最老的脏页LSN开始了。</p></blockquote><p><img src="/picture/Database/aries.png" alt="ARIES"></p><h2 id="分布式相关"><a href="#分布式相关" class="headerlink" title="分布式相关"></a>分布式相关</h2><p>这部分和DDIA、MIT6.824重合很多。主要介绍了解决分布式事务问题的2PC、Paxos算法与分布式数据库的数据复制与数据分区技术。</p><p>对于分布式未来学习完MIT6.824会进行新的知识点总结复习，在数据库课程中自己理解得也不是很到位就不做知识点复习了。</p><h2 id="CMU15-445课程总结"><a href="#CMU15-445课程总结" class="headerlink" title="CMU15-445课程总结"></a>CMU15-445课程总结</h2><p>以前本科的数据库课程仅仅教了如何使用数据库，在学习完CMU15-445与完成Lab的过程中才真正了解到一个简单的关系型数据库是如何诞生的。Andy的PPT做得真的很精美，描述很多问题的图都非常的清晰。</p><p>并且在课程中也提到了很多不一定要用在数据库领域里但非常有用的技术如Bloom Filter、一致性哈希算法等，属实拓展了一定知识面。虽然分布式相关知识我没做复习点总结，但其实那节课涉猎了很多概念例如云原生数据库、Serverless数据库等。收获真的很大。</p><p>前路漫漫，继续探索吧！</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫踩坑</title>
    <link href="/2022/01/23/%E7%88%AC%E8%99%AB%E8%B8%A9%E5%9D%91/"/>
    <url>/2022/01/23/%E7%88%AC%E8%99%AB%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>本篇博客记录自己做某汽车平台二手车报价爬取的一些小坑。（菜鸟的第一次爬虫经验）</p><span id="more"></span><blockquote><p>request.get可能因为网络问题返回空值或是错误值。</p></blockquote><p>   基本可以这样处理：</p><figure class="highlight py"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>抓！<br><span class="hljs-keyword">if</span> 抓取为空或者错误值:<br>sleep + <span class="hljs-keyword">continue</span><br></code></pre></td></tr></table></figure><blockquote><p>频繁访问可能会返回要验证的页面。</p></blockquote><p>   简单的做法就是sleep。</p><p>   复杂点可以找一些免费的高匿级别的代理IP，然后每次爬取的时候轮询即可。</p><blockquote><p>request返回时并没有返回动态加载的页面。</p></blockquote><p>   直接F12在<code>网络</code>中找对应的返回动态加载数据的url，对该url请求内容。</p>]]></content>
    
    
    
    <tags>
      
      <tag>感悟与记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.S081 Lab复习</title>
    <link href="/2021/10/20/MIT6.S081%E9%83%A8%E5%88%86Lab%E6%80%BB%E7%BB%93/"/>
    <url>/2021/10/20/MIT6.S081%E9%83%A8%E5%88%86Lab%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>这一个多月学习了MIT6.S081，基本完成了课程的Lab，但是可惜有一半左右的Lab都参考了他人的博客。本文主要记录那些写得不扎实的Lab，以作复习。</p><span id="more"></span><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><h2 id="各种延迟技术（带上mmap一起）"><a href="#各种延迟技术（带上mmap一起）" class="headerlink" title="各种延迟技术（带上mmap一起）"></a>各种延迟技术（带上mmap一起）</h2><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h2 id="文件系统与网络驱动"><a href="#文件系统与网络驱动" class="headerlink" title="文件系统与网络驱动"></a>文件系统与网络驱动</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Lab</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统进程管理</title>
    <link href="/2021/08/13/OS%E8%BF%9B%E7%A8%8B/"/>
    <url>/2021/08/13/OS%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>本文复习LMOS操作系统课程的进程管理模块，主要介绍进程地址空间、进程切换及进程调度。</p><span id="more"></span><p><strong>目录</strong></p><ol><li>进程地址空间</li><li>进程切换</li><li>进程调度</li></ol><p>了解进程管理，首先就要了解什么进程，为什么会有进程这个概念。（<strong>计算机领域产生的概念/技术大多要从其解决的问题出发进行研究</strong>）<br>在计算机刚诞生的时候，我们利用CPU运行程序这个静态资源，反复做计算的任务，这时还用不到进程。慢慢得随着计算能力的提升，一台计算机在处理复杂任务时可能需要“同时”执行不同的程序，这时，如果没有一个描述程序运行时状态的结构，难以去切换不同程序的执行（无法保存运行状态），进程便因此诞生了。</p><h2 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h2><p>了解了进程的基本概念和诞生初衷，就知道进程是一个应用程序运行时刻的实例，它的目的就是操作系统用于管理和运行多个应用程序的；从之前我们研究的内存管理角度看，操作系统是给应用程序提供服务的。所以，从这两个角度看，进程必须要有一个地址空间，这个地址空间至少包括两部分内容：一部分是内核，一部分是用户的应用程序。<br><img src="/picture/OS/2-1.jpg" alt="进程地址结构"><br>上图中有 8 个进程，每个进程拥有 x86 CPU 的整个虚拟地址空间，这个虚拟地址空间被分成了两个部分，上半部分是所有进程都共享的内核部分 ，里面放着一份内核代码和数据，下半部分是应用程序，分别独立，互不干扰。<strong>其实所谓的用户态和内核态切换就要将用户页表切换为内核页表，从而运行内核代码</strong><br>细化的整个进程地址空间则由下图所示。<br><img src="/picture/OS/2-2.jpg" alt="进程地址结构细化示意图"><br>这里带 * 号是每个进程都有独立一份，有了这样的设计结构，多个进程就能并发运行了。</p><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>还记得上一部分在进程地址空间中的机器上下文结构嘛，这个部分会保存该进程下一次运行的开始地址与下一次运行时的内核栈地址。内核栈会保存各个CPU寄存器的值，当然也保存了内核函数的调用路径。在切换回原进程时，便会将原本保存在内核栈中的CPU数据pop弹出。<br>进程切换时只用两部即可完成1.保存进程的上下文结构，2.通过修改CR3页表地址切换资源（进程的虚拟地址空间）<br><img src="/picture/OS/2-3.jpg" alt="进程切换示意图"><br><strong>总结一下</strong>切换方式：首先，我们把当前进程的通用寄存器保存到当前进程的内核栈中；然后，保存 CPU 的 RSP 寄存器到当前进程的机器上下文结构中，并且读取保存在下一个进程机器上下文结构中的 RSP 的值，把它存到 CPU 的 RSP 寄存器中；接着，调用一个函数切换 MMU 页表；最后，从下一个进程的内核栈中恢复下一个进程的通用寄存器。</p><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>进程调度算法的设计是决定性能的一个关键。进程调度算法种类也非常多，这里不会详细介绍各个算法的优劣，主要介绍进程调度的机制。<br>首先<strong>为什么需要进程调度？</strong><br>第一，CPU 同一时刻只能运行一个进程，而 CPU 个数总是比进程个数少，这就需要让多进程共用一个 CPU，每个进程在这个 CPU 上运行一段时间。第二点原因，当一个进程不能获取某种资源，导致它不能继续运行时，就应该让出 CPU。当然你也可以把第一点中的 CPU 时间，也归纳为一种资源，这样就合并为一点：进程拿不到资源就要让出 CPU。<br>管理进程、调度进程就需要知道进程有哪些状态，从而组织进程。<br> <img src="/picture/OS/2-4.jpg" alt="进程状态切换示意图"><br> 其次如何组织进程？最简单的办法就是使用链表数据结构，而且我们的进程有优先级，所以我们可以设计成每个优先级对应一个链表头。<br> 然后就是进程调度器，主要思路就是确定当前正在运行的进程，然后选择下一个将要运行的进程（通过相应的调度算法选取进程，例如根据各个进程的优先级或等待时间），最后从当前运行的进程，切换到下一个将要运行的进程。<br> 根据这个思路我们就发现，内核的进程调度器需要有主动权才能实现其功能，但进程自己一般不会主动让出CPU（除非要等待资源)，那么<strong>如何让进程调度器得到控制权呢？</strong> 其实我们的机器会有一个设备去定时发送中断信号，此时控制权就从进程转交给了内核，内核根据相应算法计算出下一个要调用的进程进行进程切换即可。本文不准备讨论相应算法，Linux支持多种调度器：CFS、RT、Dealine、Idle等，有机会单独讲解调度器算法。</p><h4 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h4><p><a href="https://time.geekbang.org/column/intro/100078401">极客时间LMOS操作系统</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统内存管理</title>
    <link href="/2021/08/07/OS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2021/08/07/OS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>自实习结束已有近9个月没有更新博客了，这段时间主要在进行毕业设计和毕业旅行噗，毕设做的微服务相关内容暂时不准备整理至博客上。暑假主要稳固基础知识（计算机组成原理、操作系统、计算机网络、数据库原理），弥补本科的缺陷。接下来会更新关于操作系统的相关内容。</p><span id="more"></span><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><strong>目录</strong></p><ol><li>物理地址与虚拟地址</li><li>内存分段与分页管理</li><li>内存组织、分配与释放</li><li>小块内存的管理</li><li>虚拟内存技术</li><li>垃圾收集</li></ol><h2 id="物理地址与虚拟地址"><a href="#物理地址与虚拟地址" class="headerlink" title="物理地址与虚拟地址"></a>物理地址与虚拟地址</h2><p>在CPU实模式下（16位），程序对于内存的访问直接使用物理地址。随着地址线增多，程序并发要求变高，程序与程序之间地址冲突的各种问题就急需解决了。我们给每个程序一样的虚拟地址空间，通过翻译单元（硬件MMU）将虚拟地址翻译成物理地址。<br><strong>那么如何设计这个映射关系表呢</strong>但是如果通过一一映射的地址翻译表。在32 位地址空间下，4GB 虚拟地址的地址关系转换表就会把整个 32 位物理地址空间用完，这显然不行。要是结合前面的保护模式下分段方式呢，地址关系转换表中存放：一个虚拟段基址对应一个物理段基址，这样看似可以，但是因为段长度各不相同，所以依然不可取。综合刚才的分析，系统设计者最后采用一个折中的方案，即把虚拟地址空间和物理地址空间都分成同等大小的块，也称为页，按照虚拟页和物理页进行转换。根据软件配置不同，这个页的大小可以设置为 4KB、2MB、4MB、1GB，这样就进入了现代内存管理模式——分页模型。<br><img src="/picture/OS/1.jpg" alt="分页模型"><br>一直存在内存中的地址关系转换表也就是我们熟悉的页表，其基地址放置在CR3寄存器当中，所以当程序切换（进程切换时）也要修改CR3寄存器的值。最后，当CPU接受到虚拟地址时，将虚拟地址与页表首地址传入MMU即可返回真正的物理地址。</p><h2 id="内存分段与分页管理"><a href="#内存分段与分页管理" class="headerlink" title="内存分段与分页管理"></a>内存分段与分页管理</h2><p>前文已经讨论了一部分选择分段还是分页管理内存的问题，但还不足够。（我认为，分页是真正起效的内存管理模式，分段只是逻辑上的划分起到的作用极小甚至没有）。为何这么说，那得从分段的历史说起，分段最开始是从Intel的8086CPU，受限于价格和技术水平，当时的CPU和寄存器的宽度仍然为16位。那时还是直接访问物理地址的，为了便利地实现多道程序并发运行，也就需要支持对各个程序进行重定位，因为如果不支持重定位，凡是涉及到内存访问的地方都需要将地址硬编码，进而必须把某个程序加载到内存的固定区间。有了分段机制，程序中只需要使用基于段的相对地址，然后更改段基址，就可以方便地对程序进行重定位。当然，在8086CPU中，分段除了服务于重定位的目的，还有其他的作用。具体地说，8086CPU的地址线宽度是20位，可寻址的最大内存空间是1MB，但寄存器这些都是16位， 它是通过段加偏移的方式生成20位的地址，从而实现对1MB内存空间的寻址的。我们经常谈的程序可执行文件的分段，例如代码段数据段这些，在最开始其实就是为了跟上面描述的硬件上的内存分段机制对应，并且逻辑上能够更清晰有序地构造程序的组织结构。<br>但是分段管理从表示方式和状态确定角度、内存碎片、内存和硬盘的数据交换效率（段长度不同，很可能导致系统性能抖动）考虑来看均有很大的缺点，当然段最大的问题还是<strong>使得虚拟内存难以实施</strong>。虚拟内存会在之后的段落详细描述。<br>目前Linux的分段更多的是一种历史包袱，而不是能够提供多大实际作用的内存管理机制。</p><h4 id="分页管理下的MMU页表原理"><a href="#分页管理下的MMU页表原理" class="headerlink" title="分页管理下的MMU页表原理"></a>分页管理下的MMU页表原理</h4><p><img src="/picture/OS/2.jpg" alt="虚拟地址翻译过程"><br>从上面可以看出，一个虚拟地址被分成从左至右四个位段。第一个位段索引顶级页目录中一个项，该项指向一个中级页目录，然后用第二个位段去索引中级页目录中的一个项，该项指向一个页目录，再用第三个位段去索引页目录中的项，该项指向一个物理页地址，最后用第四个位段作该物理页内的偏移去访问物理内存。这就是 MMU 的工作流程。<br><strong>为什么要分成这么多级的页表呢？</strong> 主要为了节省内存，页表也是需要占用空间的，一级页表是必须放在主存之中的，但页表分级之后二级页表便可以存储在磁盘之中，不用占用内存空间。同时，如果一级页表的某些页项为空，则对应的二级页表也无需进行创建。</p><h2 id="内存组织、分配与释放"><a href="#内存组织、分配与释放" class="headerlink" title="内存组织、分配与释放"></a>内存组织、分配与释放</h2><p>这部分将详细介绍与设计一个实际的分页内存管理。此部分参考LMOS操作系统课程。<br>首先要想好页的数据结构需要包含哪些信息：页的状态、页的地址、页的分配记数，页的类型、页的链表。其中链表是方便挂入其他组织页面的数据结构之中所用。<br><img src="/picture/OS/3.jpg" alt="页面组织"><br>dm_mdmlielst 数组挂载连续 msadsc_t 结构的数量等于用 1 左移其数组下标，如数组下标为 3，那结果就是 8（1&lt;&lt;3）个连续的 msadsc_t 结构。因此页面数统统都是 2 的倍数，这样就能实现页内存对齐，减少内存分配时的碎片。同时，2的倍数意味着可以用位操作进行相应计算工作，这比乘法操作要节省较多的CPU时钟。<br>根据这个页面的组织结构，即可设计出相应的页面分配算法。<br><img src="/picture/OS/4.jpg" alt="页面分配"><br>假设现在需要分配一个页面。</p><ol><li>根据一个页面的请求，会返回 m_mdmlielst 数组中的第 0 个 bafhlst_t 结构。</li><li>如果第 0 个 bafhlst_t 结构中有 msadsc_t 结构就直接返回，若没有 msadsc_t 结构，就会继续查找 m_mdmlielst 数组中的第 1 个 bafhlst_t 结构。</li><li>如果第 1 个 bafhlst_t 结构中也没有 msadsc_t 结构，就会继续查找 m_mdmlielst 数组中的第 2 个 bafhlst_t 结构。</li><li>如果第 2 个 bafhlst_t 结构中有 msadsc_t 结构，记住第 2 个 bafhlst_t 结构中对应是 4 个连续的 msadsc_t 结构。这时让这 4 个连续的 msadsc_t 结构从第 2 个 bafhlst_t 结构中脱离。</li><li>把这 4 个连续的 msadsc_t 结构，对半分割成 2 个双 msadsc_t 结构，把其中一个双 msadsc_t 结构挂载到第 1 个 bafhlst_t 结构中。</li><li>把剩下一个双 msadsc_t 结构，继续对半分割成两个单 msadsc_t 结构，把其中一个单 msadsc_t 结构挂载到第 0 个 bafhlst_t 结构中，剩下一个单 msadsc_t 结构返回给请求者，完成内存分配。<br>页面释放算法即是分配的逆算法，这里就不再阐述了。</li></ol><h2 id="小块内存的管理"><a href="#小块内存的管理" class="headerlink" title="小块内存的管理"></a>小块内存的管理</h2><p>内存是非常宝贵的，如果程序申请的内存远远小于一个页面的大小，此时该如何分配内存呢？<br>这部分直接介绍Linux的Slab分配器，我们来看看Linux是如何解决这个问题的。<br><img src="/picture/OS/5.jpg" alt="SLAB对象分配示意图"><br>在 SLAB 分配器中，它把一个内存页面或者一组连续的内存页面，划分成大小相同的块，其中这一个小的内存块就是 SLAB 对象，但是这一组连续的内存页面中不只是 SLAB 对象，还有 SLAB 管理头和着色区。这个着色区也是一块动态的内存块，建立 SLAB 时才会设置它的大小，目的是为了错开不同 SLAB 中的对象地址，降低硬件 Cache 行中的地址争用，以免导致 Cache 抖动效应，整个系统性能下降。<br>最后提及一下Slab对象的大小：Slab分配最小位32B，最大分配单元依赖体系架构。</p><h2 id="虚拟内存技术"><a href="#虚拟内存技术" class="headerlink" title="虚拟内存技术"></a>虚拟内存技术</h2><p>一个英语往往拥有很大的连续地址空间，并且每个应用都是一样的，只有在运行时才能分配到真正的物理内存，在操作系统中这称为虚拟内存。<br>虚拟地址就是逻辑上的一个数值，而虚拟地址空间就是一堆数值的集合。通常情况下，32 位的处理器有 0～0xFFFFFFFF 的虚拟地址空间，而 64 位的虚拟地址空间则更大，有 0～0xFFFFFFFFFFFFFFFF 的虚拟地址空间。<br>虚拟地址空间某种角度也可以称为进程地址空间，关于进程地址空间的描述将留到下一篇操作系统进程中详解。<br>对于虚拟内存技术，便会存在页面存在内存之中与页面存在磁盘之中的区别。虚拟地址传入CPU后查询页表的过程中自然也就存在页命中与页丢失两种情况。下图展示了页命中的情况，图摘自CSAPP。<br><img src="/picture/OS/6.jpg" alt="页命中"><br>如果页缺失，则将调用内核中的缺页异常处理程序，该程序会选择一个牺牲页将其复制回磁盘（这里也涉及很多调换算法，常见的有LRU算法等），接下来将缺失的页面换到内存中。当异常处理程序返回时，CPU会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重新发送到地址翻译硬件。此时就能页命中了。<br>或许到此就会产生一个感觉，虚拟内存技术效率有点低，因为不命中的惩罚很大，我们担心页面调度会破坏程序性能。实际上，虚拟内存工作得相当得好，这主要归功于<strong>局部性</strong>，关于局部性就不多说啦。</p><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>垃圾收集器将内存视为一张有向可达图，其中具有两种节点：</p><ol><li>根节点（Root Node）：对应于不在堆中但包含指向堆中的指针，可以是寄存器、栈中变量或全局变量等等。</li><li>堆节点（Heap Node）：对应于堆中的一个已分配的块。<br><img src="/picture/OS/7.jpg" alt="垃圾收集器"><br>对于像ML和Java语言，其对指针创建和使用有严格的要求，由此来构建十分精确的可达图，所以能回收所有垃圾。而对于像C和C++这样的语言，垃圾收集器无法维护十分精确的可达图，只能正确地标记所有可达节点，而有一些不可达节点会被错误地标记为可达的，所以会遗留部分垃圾，这种垃圾收集器称为保守的垃圾收集器。<br>下面介绍具体的垃圾收集流程。<strong>Mark&amp;Sweep垃圾收集器</strong>由标记阶段与清除阶段组成，标记阶段标记出根节点的所有可达和以分配的后继，而后面的清除阶段释放每个未被标记的已分配块。块头部中空闲的低位中的一位通常用来表示这个块是否被标记了。<br>标记阶段为每个根节点都调用一次mark函数，首先会判断输入p是否为指针，如果是则返回p指向的堆节点b，然后判断b是否被标记，如果没有，则对其进行标记，并返回b中不包含头部的以字为单位的长度，这样就能依次遍历b中每个字是否指向其他堆节点，再递归地进行标记。这是对图进行DFS。<br>清除阶段会调用一次sweep函数，它会在所有堆节点上反复循环，如果堆节点b是已标记的，则消除它的标记，如果是未标记的已分配堆节点，则将其释放，然后指向b的后继节点。<br><img src="/picture/OS/8.jpg" alt="Mark&amp;Sweep示例"></li></ol><h4 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h4><p><a href="https://time.geekbang.org/column/intro/100078401">极客时间LMOS操作系统</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XX实习总结</title>
    <link href="/2020/11/01/XX%E5%AE%9E%E4%B9%A0/"/>
    <url>/2020/11/01/XX%E5%AE%9E%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>本文记录自己的第一段实习经历。</p><p>9.25 - 12.18</p><span id="more"></span><h2 id="职位"><a href="#职位" class="headerlink" title="职位"></a>职位</h2><p>算法工程师</p><p>——————————————————————————————————————————</p><h2 id="第一个月"><a href="#第一个月" class="headerlink" title="第一个月"></a>第一个月</h2><p>首先非常感谢wc老师、zc、lhs，让我在XX感受到了很不错的同事氛围，真的很温馨很棒。</p><h4 id="两个选择"><a href="#两个选择" class="headerlink" title="两个选择"></a>两个选择</h4><blockquote><p>1.Java开发，负责开发日志聚类后，用户“关注”某些模版后详细展示该模版的信息的功能<br>2.算法设计，负责对日志流l流向Query容器的行为进行动态扩缩容算法设计</p></blockquote><p>其实自己研究生也不是很想做算法，未来还是想做开发岗方向，但基于两个因素，一是自己没有学习过SpringBoot框架，对Kafka、Zookeeper、ES、Redis、etcd都不太了解，而且，自己身处XXX，部署环境在云端，k8s、容器等知识也都不是很会，实在是压力有点大。 二是自己的导师是做AI算法的，感觉可以学到更多东西。所以权衡了一下还是选择了偏向算法的岗位。</p><p>在这里就真的觉得自己运气不错，别的实习生可能会面临调岗，但我自己竟然可以有选择的余地，真的很棒。</p><h4 id="开始工作"><a href="#开始工作" class="headerlink" title="开始工作"></a>开始工作</h4><p>其实已经到了10.12号，我才确定了自己的方向<br>对于算法的任务，首先就是要对数据有理解，有深刻的理解！我们能拿到什么数据，该怎么分析这些数据，这就是第一步：看懂数据。<br>然后对于数据，尤其在公司里，一定会和其他同事有所沟通交流，为了让别的同事能理解我们所做的工作，我们需要一个demo去展示。 <strong>其实数据可视化展示也可以帮助我们自己更好得理解数据！可视化其实也是一个很有深度的研究领域。</strong><br>最后可以不断对自己的算法进行优化，这种优化会在demo中有所体现。<br>对于我的这个项目，可以比较轻松的从普罗米修斯上获取到现网监控数据，所以不用担心数据的问题。<br>对于算法而言，参照一些论文，Google对于类似问题采用的是<strong>贪心算法</strong>，其实也达到了一个不错的效果，所以我们的想法就是MVP（最小可行性产品）就想采用贪心算法。<br>对于可视化，我才用python Flask+pyecharts绘制，确实都是从头学起，不过flask非常简单，主要要学习的其实是Javascript的DOM还有Jquery框架的使用。</p><p>————————————————————————————————————————————</p><blockquote><p>获取数据+数据预处理</p></blockquote><p>写爬虫，爬普罗的数据，其实出现很多问题。AOM限流，难以爬取，暂时沟通还没得到解决方案。</p><p>其实数据结构的设计，我们到底要存储什么样的数据，怎样存储感觉是非常有学问的。但其实自己真的理解不深刻，也不知道自己写的好不好… 这点是很难受的<br>例如路由表的存储结构<br>一开始我准备像快照一样存储，就分为routing_table和operation_table，定期生成一个完整的routing_table。但导师说这样我得单独开一个线程来做这个工作，消耗太大。最后就采取了单表存储流的所有路由信息。查询时只要挑选各个流距离查询时间最近的那条路由信息即可获得路由表。但其实这样的结构我也不知道未来放入ES中好不好查询，或许未来还得改数据结构..</p><blockquote><p>数据分析</p></blockquote><p>以往路由的变更点、异常点分析<br>日志流流量分布<br>Topic流量分布</p><p>其实自己不是很喜欢做这个，做得有点难受</p><blockquote><p>UI（这个伴随着整个项目的生命周期，各个阶段都有相应的可视化展示）<br>做UI前，要思考，要注意展示的点。<br>而此项目，其实就是要注重原来现网的检测数据和自己的算法数据的这种对比感！<br>所以用横向条形图，左侧现网右侧算法，这样对比度更加强烈来进行展示。</p></blockquote><p><strong><em>其实这个月…最后有点懈怠了，很多事情明明知道怎么做好，却没有去做，尤其是数据分析的部分…胶片做的非常烂</em></strong></p><h4 id="和导师的聊天的部分记录"><a href="#和导师的聊天的部分记录" class="headerlink" title="和导师的聊天的部分记录"></a>和导师的聊天的部分记录</h4><ol><li>Python学习路线 Python编程从入门到实践 -&gt; Effective Python/Python Cookbook -&gt; Fluent Python<br>学习了高效的python写法，<strong>一定要去改曾经自己写过的代码</strong>，去实现。不然，习惯是很难改变的，好代码的习惯要好好培养。</li><li>做技术可以2-3年就跳槽，但想做管理不要跳。XX的管理不是别的，一定是<strong>老人</strong>。</li><li>2021年，选择一门语言强化，可以再选择另一门语言做深入</li><li>在XX这样公司,以后就不可能有两周的旅行了，好好去玩玩</li><li>不要说这个方法 <strong>“也行”</strong> 多质疑，真的</li><li>Balsamiq Mockup 画图，做胶片的好帮手～</li><li>外企会对你的职业生涯做规划，告诉你未来给你选择。而在XX3年不知道未来是怎样的。</li><li>刚进入公司，尤其是XX这样的公司 前半年一定要拼命加班！这样有可能会进入升职的“快速通道”</li></ol><p>——————————————————————————————————————————————————————————————第二次编辑</p><h2 id="11-01-12-18"><a href="#11-01-12-18" class="headerlink" title="11.01 - 12.18"></a>11.01 - 12.18</h2><p>为什么提前终止了实习呢…导师在12月初转岗去了另外一个地方，我自然感觉远程指导和面对面还是有相当大的差距。当然公司内部也经历了两次存储架构的改变，自己的心也有些累了。感觉暂时也学不到什么了，做出来的东西没有什么使用价值。于是提前两周结束了实习。</p><h3 id="日志存储出现新的架构"><a href="#日志存储出现新的架构" class="headerlink" title="日志存储出现新的架构"></a>日志存储出现新的架构</h3><h4 id="为何改变架构？"><a href="#为何改变架构？" class="headerlink" title="为何改变架构？"></a>为何改变架构？</h4><ul><li>写入和查询在某种情况下时矛盾的<ul><li>要想查询性能高，要求ES索引足够小（同样的日志流量，索引小意味着索引会变多）</li><li>写入性能高，要求同时写入的索引不能太多</li></ul></li><li>当前索引现状（问题）<ul><li><p>大量日志流量较小，产生了大量的小流量索引，则服务写入能力上不去（500个索引，总流量不超过2MB/s）</p></li><li><p>某个流量巨大，但节点最多处理60MB/m，分裂为多个索引时，查询性能无法保证</p></li><li><p>某个流量变动大的时候，没有自动路由（因为我还在做，但实际情况因为拿不到相应数据，并且指标只有size/num，节点的索引数这种指标也无法拿到，这在分析当中是非常受限的），需要人肉运维</p></li><li><p>自动路由机制要考虑的因素太多，实现较为复杂（考虑因素：query节点负荷、索引个数、日志流组流量分布情况、query分裂参数等）</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><img src="/picture/sharding.png" alt="基本Sharding方案"></p></li></ul></li><li>建立stream到shard数据流的动态均衡映射<ul><li>将大象流与老鼠流合并或切分为统一固定流量的shard数据流</li><li>日志流按照租户遍历映射到指定大小的shard中</li><li>实时动态调整shard和日志流的映射关系（流量波动）<ul><li>Move次数少</li><li>超过shard流量阈值的数据流切分到不同节点</li><li>小于shard流量阈值的租户数据在同一个shard内</li><li>…（具体可以用贪心BFD…）</li></ul></li></ul></li><li>利用自动路由算法将shard路由到不同的query消费族（自动路由就变成了一个经典装箱问题）<ul><li>query根据分配到自身的shard数据流建立shard到index的一一映射关系，自身不再做shard分裂，仅做线程间均衡</li></ul></li></ul><p><strong>缺点</strong></p><ul><li>数据非租户级隔离</li><li>未命中场景查询效率会更加劣化（各种租户查询会落在同一个索引，大小租户的查询会互相影响）<ul><li><strong>解决方案</strong><ul><li>标记历史查询条件</li><li>shard流映射时大小租户做区分</li></ul></li></ul></li></ul><p><strong>优点</strong></p><ul><li>写入性能达到最优（因为shard与query映射固定，索引数量控制在一个固定的数值下）</li><li>查询性能可做到基线化</li><li>分配和路由算法更简单</li></ul><h3 id="Sharding-UI"><a href="#Sharding-UI" class="headerlink" title="Sharding UI"></a>Sharding UI</h3><p>这次直接使用echarts画了，其实更加方便了，因为echarts文档更加丰富翔实。</p><p><strong>UI设计目标</strong></p><ul><li>同时体现query流量分布均匀情况与shard流量分布</li></ul><p><strong>UI设计思路</strong></p><ul><li>查看了各个现网region的query数量，基本在20-30+的数量，乘上10也就是200-300+的shard，所以想直接呈现分布情况（除非用华夫饼图，但不够详细）不太可能。</li><li>query和shard存在映射关系，这个关系可以绑定在点击query就显示流向这个query的10个shard的流量分布</li></ul><p><strong>最终实现</strong></p><ul><li>正轴：query流量分布画柱状图（20-30个bar）</li><li>负轴：各个query内的10个shard流量方差</li><li>交互：点击query的bar，可以显示query内10个shard的流量分布柱状图（10个bar）<br>这样可以在一目了然query和shard的分布情况。也不丢失任何数据具体情况。</li></ul><br><h3 id="突然…导师告知要转岗…"><a href="#突然…导师告知要转岗…" class="headerlink" title="突然…导师告知要转岗…"></a>突然…导师告知要转岗…</h3><h4 id="整合demo"><a href="#整合demo" class="headerlink" title="整合demo"></a>整合demo</h4><ul><li>将以前实习生的自动基线的代码（基于Django）整合到我们ilog（基于Flask）里<br>整合其实也是一个重构的过程，在整合中其实就发现，什么样的代码易于整合，什么样的代码几乎要重写。这也是我未来要有所注意，要去研究的。<br>为了做自动基线的存储也学了一下ElasticSearch的使用，这东西怪好用的，未来学学底层原理。</li></ul><h4 id="为老师Crux功能做个简单的UI测试"><a href="#为老师Crux功能做个简单的UI测试" class="headerlink" title="为老师Crux功能做个简单的UI测试"></a>为老师Crux功能做个简单的UI测试</h4><p>主要借助BootstrapTable进行表格的呈现（同时该支持父子表）</p><h4 id="把所有项目部署在196节点上"><a href="#把所有项目部署在196节点上" class="headerlink" title="把所有项目部署在196节点上"></a>把所有项目部署在196节点上</h4><p>python这语言真是不能更新，不小心更新，anaconda都崩溃了…<br>下班前最后跑服务还是nohup …… &amp;让服务跑在后台吧，以防ssh各种莫名其妙的原因断了</p><h4 id="自己来设计sharding-init算法-rebalance等各个调度策略算法"><a href="#自己来设计sharding-init算法-rebalance等各个调度策略算法" class="headerlink" title="自己来设计sharding_init算法+rebalance等各个调度策略算法"></a>自己来设计sharding_init算法+rebalance等各个调度策略算法</h4><p>第一次接触到了cplex（这个要付费），之后尝试了一些类似scip，glpk等开源的算规划问题的数学工具<br>基本上做这种研究问题就是分三步</p><ol><li>用cplex跑一下我们要优化的目标函数（看模型、程序有没有大问题）</li><li>优化模型，简化目标函数，让cplex跑得更加流畅？例如将非线性目标规划转换成线性的（保证极值点不变）。其实这个时候如果cplex解的快，就可以端到端用cplex引擎。</li><li>如果觉得cplex跑得太慢，就可以用一些heuristic的方法缩短时间（当然精度有所欠缺，保留在一个可以接受的范围就行）。这种heuristic的方法更多就是对自己的目标，有更加特性化的解决方法。这完成了，一篇优化论文就完成啦。</li></ol><p>自己借鉴了一些VM Migration的论文去考虑shard的调度。<br>主要参考Multi-objective optimization for rebalancing virtual machine placement此篇<br>这个实习总结的文章就不专注于论文本身了，其实我觉得这论文也没有什么深挖的必要。<br>总之，我们做调度要考虑以下四个问题:</p><ul><li>如何初始化映射关系</li><li>新增的流怎么分配</li><li>如何rebalance（如何判断unbalance）</li><li>shard超过阈值后如何迁移</li></ul><p>其实蛮难的这些问题…无奈导师走了，实习还是得结束了，其实这些问题是算法的核心问题。做了一堆UI来验证算法的可行性但算法只写了简单的贪心装箱…哎，一大遗憾啊。<br>Todo…. 毕设时再进行一些相关研究</p><h3 id="和导师（或同事）的聊天的部分记录"><a href="#和导师（或同事）的聊天的部分记录" class="headerlink" title="和导师（或同事）的聊天的部分记录"></a>和导师（或同事）的聊天的部分记录</h3><ol><li>做PPT当个处女座吧，展示20页，backup这种过程中生产的胶片可能至少有50页（这种更详细的内容很适合做凝缩后的数据支撑）</li><li>不要说 <strong>“我原来怎么想的”</strong>，请写下来。在脑子的东西是靠不住的模糊的。</li><li>说话，或者写句子。先说论点，再说论据。</li><li>设计一个方法时，预设太多，往往最后的功能就很有限了</li><li>工程师一定要软硬结合来考虑性能</li><li>一个印度四十多岁做业务的，在别人讲完需求后，会紧接着先讲一遍要做的业务，再由此衍生出其他场景去质问提需求的人为什么做，为什么不做。<strong>其实我觉得就是做工程或者做算法，都一定要好好去理解业务！！</strong></li><li>做工程，很多时候要专注模型问题，这是最难的也是最重要的。</li><li>数据怎么存很大程度归决于数据怎么用。</li><li>在公司里，还是必须得有不错的定位问题的能力。</li></ol><h2 id="实习总结"><a href="#实习总结" class="headerlink" title="实习总结"></a>实习总结</h2><p>加过班，熬过夜，生过病，在公司睡过觉。但早上闹钟没响干脆请假这种事也干过。<br>导师转岗，自己也无奈提前离职。<br>不过还是学到了公司的很多为人处事。<br>技术确实没学到什么新的（前端/巩固了python）不过这段时间在学校估计浪费也会很严重吧hh。<br>第一次实习，面对全新的环境，还是收获很大的，说不上来。 对未来的路更坚定了吧！</p><p><strong>部门比公司更重要</strong></p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>软件开发者大会，听了以下一些领域的大牛的演讲…继续摸索吧…</p><ul><li>Serverless</li><li>分布式数据库/云数据库</li><li>区块链</li><li>重构与建模…</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>感悟与记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>保研夏令营预推免总结</title>
    <link href="/2020/10/28/%E4%BF%9D%E7%A0%94%E5%88%86%E4%BA%AB/"/>
    <url>/2020/10/28/%E4%BF%9D%E7%A0%94%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<p>其实距离保研上岸已经一个学期多过去啦，不过实习时确实有一点忙，一直没功夫写一个保研的记录。拖了很久感觉还是得记录一下，毕竟是人生的一个分叉路口。</p><span id="more"></span><h2 id="个人情况介绍"><a href="#个人情况介绍" class="headerlink" title="个人情况介绍"></a>个人情况介绍</h2><p>211网络工程 卓越班 rank （3/32）</p><p>3段水科研 + 一篇N作 MDPI（自己的工作太水了）</p><p>CET-6 659  TOFEL 107 GRE 324 + 3.5 （英语算优势了，毕竟原来准备出国但被疫情摁下来了）</p><blockquote><p>总的来说除了排名和英语，其他地方都不值一提，自己没参加过算法竞赛，算法题做得也十分稀烂（机试很惨…）。自己目标还是硕士，所以一个博士都没报。</p></blockquote><h2 id="夏令营-预推免入营情况"><a href="#夏令营-预推免入营情况" class="headerlink" title="夏令营+预推免入营情况"></a>夏令营+预推免入营情况</h2><p>北大信科（硕士） 没入营</p><p>南大cs 没入营</p><p>浙大工程师院 夏令营offer</p><p>中科大网安 夏令营offer</p><p>北航cs 机试挂</p><p>上交软 没入营</p><p>哈深 清深 没入营</p><p>复旦 没入营</p><p>北大软微 预推免Offer</p><p>自动化所 错过报名时间</p><p>计算所 夏令营太紧张面试挂了 预推免拿到offer</p><p>软件所 夏令营入营要面试的时候在外面玩没参加，预推免想报的时候想跟的老师没名额了…</p><p>信工所 入营后未参加</p><blockquote><p>这里就不分享什么具体考了些啥了（其实是自己记不太得了），基本就是一些操作系统、网络的八股，好像还有问数据库ACID是啥的。反正相比找工作面试真的时间短太多了（可能难的面试我都没进hh）。</p></blockquote><h2 id="疫情改变人生…"><a href="#疫情改变人生…" class="headerlink" title="疫情改变人生…"></a>疫情改变人生…</h2><p>好像这篇博客开始偏题了。我感觉我的命运在这一年发生了重大的变化。</p><p>因为疫情，暑假没法去加拿大暑研了，想着该怎么填补这个假期，于是便开始找暑期实习。不面不知道，一去真正的面试才让我突然就意识到我这计算机学了个🔨！ 要不是这场疫情，我还不知道自己还在一个什么样的状态下在学计算机这个专业（现在想想感觉基本没学…走的弯路太多太多了）…</p><p>甚至，在5月前，我还是想出国的，想着暑研做脑部图像分割的工作，出国往AI靠。害，结果现在基本与AI无缘啦，老老实实做开发。不知道是好事还是坏事呢。</p><p>还有保研去北京还结束了一定的异地恋，还避免了异国恋，真的是一个非常大的bonus了。</p><p>呼…</p><p>我们只是在历史车轮的裹挟下而向前行走吧…</p>]]></content>
    
    
    
    <tags>
      
      <tag>感悟与记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云平台管理系统</title>
    <link href="/2020/08/26/%E4%BA%91%E5%B9%B3%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/08/26/%E4%BA%91%E5%B9%B3%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>保研期间干的一个小活，纯属记录给自己看。但最后没去这个实验室，这个活交付一部分后也就不了了之了。</p><span id="more"></span><p>实现功能非常简单，就是调用各个云计算平台如(openstack,cloudstack)的API接口，对不同平台进行一个统一的管理。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>学长将openstack部署在了内网之上，所以我将前端部署在跳板机上，后端部署在openstack控制节点之上从而方便日志功能查看的实现。其余功能还是调用API实现。 </p><h4 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h4><blockquote><p>服务器搭建<br>layui框架使用<br>cURL简介<br>正则表达式与php正则使用<br>整体框架设计</p></blockquote><p><strong><em>TODO…..</em></strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>小东西</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信安大赛作品使用指南</title>
    <link href="/2020/06/14/Jade%E4%BF%A1%E5%AE%89%E5%A4%A7%E8%B5%9B%E6%95%99%E7%A8%8B/"/>
    <url>/2020/06/14/Jade%E4%BF%A1%E5%AE%89%E5%A4%A7%E8%B5%9B%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>本作品基于JADE（Java智能体开发框架），是一个实现共识算法的通信框架，用于进行威胁信息共享。</p><span id="more"></span><h3 id="JADE简介"><a href="#JADE简介" class="headerlink" title="JADE简介"></a>JADE简介</h3><p>JADE是基于Java 语言的Agent开发框架，是由TILAB 开发的开放源代码的自由软件。JADE是多Agent开发框架，遵循FIPA规范，它提供了基本的命名服务，黄业服务，通讯机制等，可以有效地与其它Java开发平台和技术集成。 JADE架构适应性很强，不仅可以在受限资源环境中运行，而且与其他复杂架构集成到一起，比如：Net和Java EE。它包括一个Agent赖以生存的运行环境，开发Agent应用的类库和用来调试和配置的一套图形化的工具，简化了一个多Agent系统的开发过程。</p><h3 id="JADE功能"><a href="#JADE功能" class="headerlink" title="JADE功能"></a>JADE功能</h3><p>JADE为多Agent系统提供了以下功能: </p><blockquote><p>(1)Agent管理系统(Agent Management System，简称AMS)，负责控制平台内Agent的活动、 生存周期及外部应用程序与平台的交互，规范Agent在平台上用独一无二的名字来标识；<br>(2)目录服务器(Dilectoly Facilitatol，简称DF)，负责对平台内的Agent提供黄页服务，注册服务类型以供查找；<br>(3)消息传送系统，也称为Agent交流通道(Agent Communication Channel，简称ACC)，控制平台内或不同平台之间的消息传输、消息编码、消息解析等。<br>JADE定义了Agentclass作为其他Agent的父类，其他Agent均继承自Agentclass。Agentclass中定义了setup方法，用于初始化Agent；定义了takeDown方法，用于结束Agent的运行；定义了doDelete方法，用于终止Agent；定义了Behaviour类以及addBehaviour方法用于添加Agent任务。为了保证Agent的分布式计算和协作机制，JADE构建行为池(Behaviour Pool)来存储所有添加的Behaviour，这些Behaviour呈队列排列，按照进入行为池的顺序依次被调用。Behaviour方法被调用时，首先执行Action方法，然后判断Done函数返回的布尔值，如果为真则将Behaviour移出行为池，继续下一个Behaviour的执行。JADE提供了这样一个基类，其他Agent所需要做的是重载setup，action，done，takeDown 这几个方法来实现特定的功能模块。</p></blockquote><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p><strong>安装JADE前需要先安装jdk并配置好Java环境</strong></p><p>从JADE的官方网站JADE官网上下载JADE的最新版本，目前最新的是4.5.0，我下载的是包含全部文件的JADE-all-4.5.0.zip，先解压这个压缩包，解压得到的文件夹中的所有压缩包也解压到各自的文件夹。建立文件夹起名为jade（存放位置和命名自己喜欢和习惯即可），用来存放JADE的相关文件，我把刚才解压缩的四个文件夹都拷贝到在这个jade文件夹中。<br>四个文件夹说明： </p><blockquote><p>JADE-bin-4.5.0（存放JADE的核心部件，它是JADE框架平台的支持文件）<br>JADE-doc-4.5.0（存放JADE的说明文档，其中包括各种程序说明与教程资料）<br>JADE-examples-4.5.0（存放 JADE 的实例源代码）<br>JADE-src-4.5.0（存放JADE框架平台的源代码，JADE为开源项目）</p></blockquote><h3 id="Eclipse开发"><a href="#Eclipse开发" class="headerlink" title="Eclipse开发"></a>Eclipse开发</h3><p>Window-&gt;Preferences-&gt;Java-&gt;Build Path-&gt;User Libraries新建库，命名为jade，添加jade.jar进这个jade库里<br>新建工程，命名为jade，右击工程，Build Path-&gt;Configure Build Path-&gt;Libraries-&gt;Add Library-&gt;User Library，然后将jade库添加进去<br>在src目录下新建文件夹jadetest，然后将本作品的文件导入<br><img src="/picture/JADE/1.png" alt="Run Configurations"></p><p>右击AgentSelector.java，选择Run As，选择Run Configurations，选择Java Application，点击添加，Name起名为：Run In JADE（可任意），Project名不变，Main Class起名为：jade.Boot（固定，不可改变），Argument中Program arguments起名为：-gui selector:jadetest.AgentSelector（如果只想打开GUI管理器而不运行程序，则只要-gui即可），其中，selector为智能体的名字，jadetest为包名，AgentSeletor为类名。其他默认即可，配置完成，点击Run，运行如下：</p><p><img src="/picture/JADE/2.png" alt="GUI"></p><p>可以看到创建出来的selector智能体。这里的selector是用来确定通信过程中哪个Agent智能体为主节点。<br>右击Main-Container点击Start New Agent即可创建一个新的Agent智能体。</p><p><img src="/picture/JADE/3.png" alt="创建新的Agent"></p><p>这里Class Name选择jadetest.NodeAgent，点击OK创建好一个Agent：</p><p><img src="/picture/JADE/4.png" alt="作品运行UI"></p><p>点击帮助了解作品使用方法</p><p><img src="/picture/JADE/5.png" alt="帮助"></p>]]></content>
    
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PekingUniversityOJ No.1485</title>
    <link href="/2019/11/29/PekingOJ1485/"/>
    <url>/2019/11/29/PekingOJ1485/</url>
    
    <content type="html"><![CDATA[<p>这是一道很典型的动态规划问题。<br>动态规划在上课的时候说实话没怎么理解其精髓，于是挑一道典型题来练一下。</p><span id="more"></span><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Description</p><p>The fastfood chain McBurger owns several restaurants along a highway. Recently, they have decided to build several depots along the highway, each one located at a restaurant and supplying several of the restaurants with the needed ingredients. Naturally, these depots should be placed so that the average distance between a restaurant and its assigned depot is minimized. You are to write a program that computes the optimal positions and assignments of the depots. </p><p>To make this more precise, the management of McBurger has issued the following specification: You will be given the positions of n restaurants along the highway as n integers d1 &lt; d2 &lt; … &lt; dn (these are the distances measured from the company’s headquarter, which happens to be at the same highway). Furthermore, a number k (k &lt;= n) will be given, the number of depots to be built. </p><p>The k depots will be built at the locations of k different restaurants. Each restaurant will be assigned to the closest depot, from which it will then receive its supplies. To minimize shipping costs, the total distance sum, defined as </p><p>n<br>∑ |di - (position of depot serving restaurant i)|<br>i=1 </p><p>must be as small as possible. </p><p>Write a program that computes the positions of the k depots, such that the total distance sum is minimized.<br>Input</p><p>The input file contains several descriptions of fastfood chains. Each description starts with a line containing the two integers n and k. n and k will satisfy 1 &lt;= n &lt;= 200, 1 &lt;= k &lt;= 30, k &lt;= n. Following this will n lines containing one integer each, giving the positions di of the restaurants, ordered increasingly. </p><p>The input file will end with a case starting with n = k = 0. This case should not be processed.<br>Output</p><p>For each chain, first output the number of the chain. Then output an optimal placement of the depots as follows: for each depot output a line containing its position and the range of restaurants it serves. If there is more than one optimal solution, output any of them. After the depot descriptions output a line containing the total distance sum, as defined in the problem text. </p><p>Output a blank line after each test case.<br>Sample Input</p><p>6 3<br>5<br>6<br>12<br>19<br>20<br>27<br>0 0<br>Sample Output</p><p>Chain 1<br>Depot 1 at restaurant 2 serves restaurants 1 to 3<br>Depot 2 at restaurant 4 serves restaurants 4 to 5<br>Depot 3 at restaurant 6 serves restaurant 6<br>Total distance sum = 8</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>动态规划的核心是要找到一个递推方程。<br>而这道题则需要局部最优状态的递推方程。考虑到局部最优状态mindis[i][j]，表示前i个餐馆<br>分配j个仓库的最短距离。那么，当我们增加一个仓库时：<br>计算MIN(mindis[l][j]+第l+1到第i个餐馆分配一个仓库的最短距离)其中j&lt;l&lt;i<br>则得到mindis[i][j+1]</p><blockquote><p>其实总结起来递推方程即为mindis[i][j]=MIN(mindis[l][j-1]+onedepot[l+1][i])</p></blockquote><p>其中onedepot[l+1][i]代表第l+1个餐馆到第i个餐馆只安排一个仓库的最短距离，而这个最短距离是很好算的<br>最短距离一定是仓库放在中间餐馆时的距离，偶数个餐馆则中间两个餐馆的任意一个都可以。<br>这里只需要求（i+j）/2留下的整数即可。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,k;<br><span class="hljs-keyword">int</span> countt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> restaurant[<span class="hljs-number">200</span>],mindis[<span class="hljs-number">200</span>][<span class="hljs-number">30</span>],onedepot[<span class="hljs-number">200</span>][<span class="hljs-number">200</span>];<br><span class="hljs-keyword">int</span> from[<span class="hljs-number">200</span>][<span class="hljs-number">30</span>],to[<span class="hljs-number">200</span>][<span class="hljs-number">30</span>],depot[<span class="hljs-number">200</span>][<span class="hljs-number">30</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(j&lt;=<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> counttt=<span class="hljs-built_in">result</span>(from[i][j]<span class="hljs-number">-1</span>,j<span class="hljs-number">-1</span>); <span class="hljs-comment">//from[i][j]-1就是去掉最后一个仓库分配的餐馆，剩下的最“右”一个餐馆</span><br>    <span class="hljs-comment">//我原来竟然想result(i-t;j-1)这里t去从1开始尝试，直到to[i-t][j-1]=i-t为止...好蠢</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Depot %d at restaurant %d serves &quot;</span>,counttt,depot[i][j]);<br>    <span class="hljs-keyword">if</span>(from[i][j]==to[i][j])<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;restaurant %d\n&quot;</span>,from[i][j]);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;restaurants %d to %d\n&quot;</span>,from[i][j],to[i][j]);<br>    <span class="hljs-keyword">return</span> counttt+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">memset</span>(restaurant,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(restaurant));<br>        <span class="hljs-built_in">memset</span>(mindis,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(mindis));<br>        <span class="hljs-built_in">memset</span>(onedepot,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(onedepot));<br>        <span class="hljs-keyword">int</span> i,j,l,temp;<br>        countt++;<br>        cin&gt;&gt;n&gt;&gt;k;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>&amp;&amp;k==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            cin&gt;&gt;restaurant[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;       <span class="hljs-comment">//计算出所有dept 其中onedepot[i][j]代表第i--j个餐厅放置一个仓库的最短距离</span><br>            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                <span class="hljs-keyword">for</span>(l=i;l&lt;=j;l++)&#123;<br>                    onedepot[i][j]=onedepot[i][j]+<span class="hljs-built_in">abs</span>(restaurant[(i+j)/<span class="hljs-number">2</span>]-restaurant[l]);<br>                &#125;<br><br>               <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot;  &quot;&lt;&lt;j&lt;&lt;&quot;   &quot;&lt;&lt;onedepot[i][j]&lt;&lt;endl;</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            mindis[i][<span class="hljs-number">0</span>]=<span class="hljs-number">100000</span>;  <span class="hljs-comment">//递归方程的初始化</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=i&amp;&amp;j&lt;=k;j++)&#123;<br>                mindis[i][j]=<span class="hljs-number">100000</span>;<span class="hljs-comment">//首先将初始值赋为MAX</span><br>                <span class="hljs-keyword">for</span>(l=j<span class="hljs-number">-1</span>;l&lt;i;l++)&#123;<br>                    temp=mindis[l][j<span class="hljs-number">-1</span>]+onedepot[l+<span class="hljs-number">1</span>][i]; <span class="hljs-comment">//mindis[i][j]=min(mindis[l][j-1]+onedepot[l+1][i])</span><br>                    <span class="hljs-keyword">if</span>(temp&lt;mindis[i][j])&#123;<br>                        mindis[i][j]=temp;<br>                        from[i][j]=l+<span class="hljs-number">1</span>;<br>                        to[i][j]=i;<br>                        depot[i][j]=(l+<span class="hljs-number">1</span>+i)/<span class="hljs-number">2</span>;<br>                        <br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Chain %d\n&quot;</span>,countt);<br>        <span class="hljs-built_in">result</span>(n,k);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Total distance sum = %d\n\n&quot;</span>,mindis[n][k]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>语义分析器</title>
    <link href="/2019/11/19/compiler3/"/>
    <url>/2019/11/19/compiler3/</url>
    
    <content type="html"><![CDATA[<h1 id="语义分析器的构造"><a href="#语义分析器的构造" class="headerlink" title="语义分析器的构造"></a>语义分析器的构造</h1><span id="more"></span><h2 id="语法制导翻译绘制函数图形"><a href="#语法制导翻译绘制函数图形" class="headerlink" title="语法制导翻译绘制函数图形"></a>语法制导翻译绘制函数图形</h2><blockquote><p>表达式值的计算：深度优先后序遍历语法树<br>图形的绘制：画出每个坐标点</p></blockquote><h3 id="绘图所需的语义处理"><a href="#绘图所需的语义处理" class="headerlink" title="绘图所需的语义处理"></a>绘图所需的语义处理</h3><p>1.从origin、rot和scale中得到坐标变换所需的信息；<br>2.for_draw语句根据t的每一个值进行如下处理：</p><ul><li>计算被绘制点的横、纵坐标值；</li><li>根据坐标变换信息进行坐标变换，得到实际坐标；</li><li>根据点的实际坐标画出该点。</li></ul><h3 id="语法制导翻译的基本步骤"><a href="#语法制导翻译的基本步骤" class="headerlink" title="语法制导翻译的基本步骤"></a>语法制导翻译的基本步骤</h3><ul><li>为文法符号设计属性；</li><li>设计语义规则中所需的辅助函数；</li><li>为产生式设计语义规则。</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>文法：ScaleStatment  → SCALE IS<br>      L_BRACKET Expression COMMA Expression R_BRACKET<br>可简写为：S → SCALE IS (E,E)<br>            它的作用是提供横、纵坐标的比例因子。<br>因此需要：<br>设计属性：.x和.y，分别保存比例因子；<br>设计计算表达式值的辅助函数：<br>    GetExprValue(nptr)，它返回表达式树的值；<br>设计语义规则：<br>S → SCALE IS (E1,E2) S.x:=GetExprValue(E1.nptr);<br>                    S.y:=GetExprValue(E2.nptr);</p><h4 id="几个关键变量及需构建的函数"><a href="#几个关键变量及需构建的函数" class="headerlink" title="几个关键变量及需构建的函数"></a>几个关键变量及需构建的函数</h4><p>&lt;1&gt; 全程变量：<br>double Parameter=0;            // 为参数T分配的变量<br>double Origin_x=0.0, Origin_y=0.0;// 用于记录平移距离<br>double Rot_ang=0.0;            // 用于记录旋转角度<br>double Scale_x=1, Scale_y=1;        // 用于记录比例因子</p><p>&lt;2&gt; 辅助语义函数<br>a) 计算表达式的值：深度优先后序遍历语法树<br>double GetExprValue(…root);<br>b) 计算点的坐标值：首先获取坐标值，然后进行坐标变换<br>static void CalcCoord(….);<br>c) 绘制一个点(与环境有关):            【这里我java里就没有此绘制函数，主要思路是存下所有的点借助JFrame和JPanel绘制所有的点】<br>void DrawPixel(….);<br>d) 循环绘制所有的点：<br>void DrawLoop(  double Start,<br>                 double End,<br>                   double Step,<br>                   …);<br>e)计算点的坐标：<br>static void CalcCoord (…)；<br>要计算原始坐标、比例变换、旋转变换、平移变换</p><h2 id="语法分析器-语义分析器的代码"><a href="#语法分析器-语义分析器的代码" class="headerlink" title="语法分析器+语义分析器的代码"></a>语法分析器+语义分析器的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> javax.swing.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tree</span> </span>&#123;                     <span class="hljs-comment">//语法树的类,</span><br>    String type=<span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">int</span> rank;<br>    <span class="hljs-keyword">int</span> left=-<span class="hljs-number">1</span>;   <span class="hljs-comment">//T、FUNC都有特殊含义</span><br>    <span class="hljs-keyword">int</span> right=-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">double</span> constant=<span class="hljs-number">0.0d</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coordinate</span></span>&#123;<br>    <span class="hljs-keyword">double</span> x;<br>    <span class="hljs-keyword">double</span> y;<br>&#125;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YuFa_Analyzer</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">JFrame</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Draw2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JFrame</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Draw2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            MyPanel2 mp= <span class="hljs-keyword">new</span> MyPanel2();<br>            <span class="hljs-keyword">this</span>.add(mp);<br>            <span class="hljs-keyword">this</span>.setSize(<span class="hljs-number">500</span>, <span class="hljs-number">500</span>);<br>            <span class="hljs-keyword">this</span>.setDefaultCloseOperation(EXIT_ON_CLOSE);<br>            <span class="hljs-keyword">this</span>.setVisible(<span class="hljs-keyword">true</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//定义一个panel、用于绘制和实现图像</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPanel2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JPanel</span></span><br><span class="hljs-class">    </span>&#123;<br>        <span class="hljs-comment">//覆盖jpanel的paint方法</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">paint</span><span class="hljs-params">(Graphics g)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//调用父类函数进行初始化，绝对不可少</span><br>            <span class="hljs-keyword">super</span>.paint(g);<br>            <span class="hljs-comment">//System.out.println(&quot;我开始画了！&quot;);</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;Dian;i++) &#123;<br>                g.drawOval((<span class="hljs-keyword">int</span>)coord[i].x, (<span class="hljs-keyword">int</span>)(Origin_y-(coord[i].y-Origin_y)), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> blank=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> Dian=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> current=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> sum;<br>    <span class="hljs-keyword">static</span> OutputToken Liu=<span class="hljs-keyword">new</span> OutputToken();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> Parameter=<span class="hljs-number">0</span>;            <span class="hljs-comment">// 为参数T分配的变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> Origin_x=<span class="hljs-number">0.0</span>, Origin_y=<span class="hljs-number">0.0</span>;<span class="hljs-comment">// 用于记录平移距离</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> Rot_ang=<span class="hljs-number">0.0</span>;            <span class="hljs-comment">// 用于记录旋转角度</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> Scale_x=<span class="hljs-number">1</span>, Scale_y=<span class="hljs-number">1</span>;        <span class="hljs-comment">// 用于记录比例因子</span><br>    <span class="hljs-keyword">static</span> Coordinate[] coord=<span class="hljs-keyword">new</span> Coordinate[<span class="hljs-number">10000</span>];<br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-title">YuFa_Analyzer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) <span class="hljs-comment">//对象需要分别初始化</span><br>        &#123;<br>            coord[j] = <span class="hljs-keyword">new</span> Coordinate();<br>        &#125;<br>        Draw2 demo=<span class="hljs-keyword">new</span> Draw2();<br>    &#125;<br><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">YuFa</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        sum=Liu.Cifa_Analyzer();<br><br>        Tree point[]=<span class="hljs-keyword">new</span> Tree[sum+<span class="hljs-number">1</span>]; <span class="hljs-comment">//最后一位留来创造识别 负数来填补的零</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; sum; j++) <span class="hljs-comment">//对象需要分别初始化</span><br>        &#123;<br>            point[j] = <span class="hljs-keyword">new</span> Tree();<br>            point[j].rank=j;<br>            point[j].type=Liu.tokens[j].type;<br>        &#125;<br>        point[sum]=<span class="hljs-keyword">new</span> Tree();<br>        point[sum].rank=sum;<br>        point[sum].type=<span class="hljs-string">&quot;CONST_ID&quot;</span>;<br>        point[sum].right=-<span class="hljs-number">2</span>;<br><br>        Program(point);<br><br>        <span class="hljs-comment">/*for(int i=0;i&lt;sum+1;i++)&#123;</span><br><span class="hljs-comment">            System.out.println(point[i].type+&quot;  &quot;+point[i].left+&quot;  &quot;+point[i].right+&quot;   &quot;+point[i].constant+&quot;   &quot;+point[i].rank);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        */</span><br><br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Program</span><span class="hljs-params">(Tree point[])</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!Liu.tokens[current].lexeme.equals(<span class="hljs-string">&quot;NONTOKEN&quot;</span>)) &#123;<br>        Statement(point);<br>        MatchToken(<span class="hljs-string">&quot;SEMICO&quot;</span>);<br>        <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(<span class="hljs-string">&quot;COMMENT&quot;</span>))&#123;<br>            MatchToken(<span class="hljs-string">&quot;COMMENT&quot;</span>);<br>        &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Statement</span><span class="hljs-params">(Tree point[])</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(<span class="hljs-string">&quot;ORIGIN&quot;</span>))&#123;<br>            current++;<br>            OriginStatement(point);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(<span class="hljs-string">&quot;SCALE&quot;</span>))&#123;<br>            current++;<br>            ScaleStatement(point);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(<span class="hljs-string">&quot;ROT&quot;</span>))&#123;<br>            current++;<br>            RotStatement(point);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(<span class="hljs-string">&quot;FOR&quot;</span>))&#123;<br>            current++;<br>            ForStatement(point);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            System.out.println(Liu.tokens[current].type+<span class="hljs-string">&quot; 语法错误  &quot;</span>+current);<br>            System.exit(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OriginStatement</span><span class="hljs-params">(Tree point[])</span></span>&#123;<br>        MatchToken(<span class="hljs-string">&quot;IS&quot;</span>);<br>        MatchToken(<span class="hljs-string">&quot;L_BRACKET&quot;</span>);<br>        <span class="hljs-keyword">int</span> x=Expression(point);<br>        System.out.println();<br>        PrintTree(point,x,<span class="hljs-number">0</span>);<br>        Origin_x=GetExprValue(point,x);<br>        MatchToken(<span class="hljs-string">&quot;COMMA&quot;</span>);<br>        <span class="hljs-keyword">int</span> y=Expression(point);<br>        PrintTree(point,y,<span class="hljs-number">0</span>);<br>        Origin_y=GetExprValue(point,y);<br>        MatchToken(<span class="hljs-string">&quot;R_BRACKET&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ScaleStatement</span><span class="hljs-params">(Tree point[])</span></span>&#123;<br>        MatchToken(<span class="hljs-string">&quot;IS&quot;</span>);<br>        MatchToken(<span class="hljs-string">&quot;L_BRACKET&quot;</span>);<br>        <span class="hljs-keyword">int</span> x=Expression(point);<br>        PrintTree(point,x,<span class="hljs-number">0</span>);<br>        Scale_x=GetExprValue(point,x);<br>        MatchToken(<span class="hljs-string">&quot;COMMA&quot;</span>);<br>        <span class="hljs-keyword">int</span> y=Expression(point);<br>        PrintTree(point,y,<span class="hljs-number">0</span>);<br>        Scale_y=GetExprValue(point,y);<br>        MatchToken(<span class="hljs-string">&quot;R_BRACKET&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RotStatement</span><span class="hljs-params">(Tree point[])</span></span>&#123;<br>        MatchToken(<span class="hljs-string">&quot;IS&quot;</span>);<br>        <span class="hljs-keyword">int</span> x=Expression(point);<br>        PrintTree(point,x,<span class="hljs-number">0</span>);<br>        Rot_ang=GetExprValue(point,x);<br>        <span class="hljs-comment">//System.out.println(&quot;根为:&quot;+x);</span><br>        <span class="hljs-comment">//System.out.println(&quot;Rot为:&quot;+Rot_ang);</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ForStatement</span><span class="hljs-params">(Tree point[])</span></span>&#123;<br>        <span class="hljs-keyword">int</span> a,b,c,d,e;<br>        MatchToken(<span class="hljs-string">&quot;T&quot;</span>);<br>        MatchToken(<span class="hljs-string">&quot;FROM&quot;</span>);<br>        a=Expression(point);<br>        PrintTree(point,a,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">double</span> Start=GetExprValue(point,a);<br>        MatchToken(<span class="hljs-string">&quot;TO&quot;</span>);<br>        b=Expression(point);<br>        PrintTree(point,b,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">double</span> End=GetExprValue(point,b);<br>        MatchToken(<span class="hljs-string">&quot;STEP&quot;</span>);<br>        c=Expression(point);<br>        PrintTree(point,c,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">double</span> Step=GetExprValue(point,c);<br>        MatchToken(<span class="hljs-string">&quot;DRAW&quot;</span>);<br>        MatchToken(<span class="hljs-string">&quot;L_BRACKET&quot;</span>);<br>        d=Expression(point);<span class="hljs-comment">//x坐标</span><br>        PrintTree(point,d,<span class="hljs-number">0</span>);<br>        MatchToken(<span class="hljs-string">&quot;COMMA&quot;</span>);<br>        e=Expression(point);    <span class="hljs-comment">//y坐标</span><br>        PrintTree(point,e,<span class="hljs-number">0</span>);<br>        MatchToken(<span class="hljs-string">&quot;R_BRACKET&quot;</span>);<br><br>        DrawLoop(Start,End,Step,d,e,point);   <span class="hljs-comment">//开始画画！！</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Expression</span><span class="hljs-params">(Tree point[])</span></span>&#123;<br>        <span class="hljs-keyword">int</span> left,right;<br>        left=Term(point);<br>        <span class="hljs-keyword">while</span>(Liu.tokens[current].type.equals(<span class="hljs-string">&quot;PLUS&quot;</span>)||Liu.tokens[current].type.equals(<span class="hljs-string">&quot;MINUS&quot;</span>))&#123;<br>            <span class="hljs-comment">//point[current].type=Liu.tokens[current].type;</span><br>            <span class="hljs-keyword">int</span> mark=current;<br>            MatchToken(Liu.tokens[current].type);<br>            right=Term(point);<br>            MakeNode(point,mark,left,right);<br>            left=mark;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Term</span><span class="hljs-params">(Tree point[])</span></span>&#123;<br>        <span class="hljs-keyword">int</span> left,right;<br>        left=Factor(point);<br>        <span class="hljs-keyword">while</span>(Liu.tokens[current].type.equals(<span class="hljs-string">&quot;MUL&quot;</span>)||Liu.tokens[current].type.equals(<span class="hljs-string">&quot;DIV&quot;</span>)) &#123;<br>            <span class="hljs-keyword">int</span> mark = current;<br>            MatchToken(Liu.tokens[current].type);<br>            right = Factor(point);<br>            MakeNode(point, mark, left, right);<br>            left = mark;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Factor</span><span class="hljs-params">(Tree point[])</span></span>&#123;<br>        <span class="hljs-keyword">int</span> left,right;<br>        <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(<span class="hljs-string">&quot;PLUS&quot;</span>)||Liu.tokens[current].type.equals(<span class="hljs-string">&quot;MINUS&quot;</span>))&#123;<br>            left=current;<br>            MatchToken(Liu.tokens[current].type);<br>            right=Factor(point);<br>            MakeNode(point,left,sum,right);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            left=component(point);<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">component</span><span class="hljs-params">(Tree point[])</span></span>&#123;<br>        <span class="hljs-keyword">int</span> left,right,mark;<br>        left=Atom(point);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (Liu.tokens[current].type.equals(<span class="hljs-string">&quot;POWER&quot;</span>)) &#123;<br>                mark = current;<br>                MatchToken(<span class="hljs-string">&quot;POWER&quot;</span>);<br>                right = component(point);<br>                MakeNode(point, mark, left, right);<br>                left=mark;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Atom</span><span class="hljs-params">(Tree point[])</span></span>&#123;<br>        <span class="hljs-keyword">int</span> left,right,mark;<br>        left=<span class="hljs-number">0</span>;<span class="hljs-comment">//无奈的初始化</span><br>        <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(<span class="hljs-string">&quot;CONST_ID&quot;</span>))&#123;<br>            left=current;<br>            mark=current;<br>            MatchToken(<span class="hljs-string">&quot;CONST_ID&quot;</span>);<br>            MakeNode(point,mark,left,left);<span class="hljs-comment">//常数的left right参数没啥用</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(<span class="hljs-string">&quot;T&quot;</span>))&#123;<br>            left=current;<br>            mark=current;<br>            MatchToken(<span class="hljs-string">&quot;T&quot;</span>);<br>            MakeNode(point,mark,left,left);<span class="hljs-comment">//T的left right参数没啥用</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(<span class="hljs-string">&quot;FUNC&quot;</span>))&#123;<br>            left=current;<br>            mark=current;<br>            MatchToken(<span class="hljs-string">&quot;FUNC&quot;</span>);<br>            MatchToken(<span class="hljs-string">&quot;L_BRACKET&quot;</span>);<br>            right=Expression(point);<br>            MatchToken(<span class="hljs-string">&quot;R_BRACKET&quot;</span>);<br>            MakeNode(point,mark,left,right);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(<span class="hljs-string">&quot;L_BRACKET&quot;</span>))&#123;<br>            MatchToken(<span class="hljs-string">&quot;L_BRACKET&quot;</span>);<br>            <span class="hljs-comment">//mark=current;</span><br>            left=Expression(point);<br>            MatchToken(<span class="hljs-string">&quot;R_BRACKET&quot;</span>);<br><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            System.out.println(Liu.tokens[current].type+<span class="hljs-string">&quot;  WRONG1  &quot;</span>+current);<br>            System.exit(<span class="hljs-number">0</span>);<span class="hljs-comment">//出错了</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br><br><br><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeNode</span><span class="hljs-params">(Tree point[],<span class="hljs-keyword">int</span> mark,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<span class="hljs-comment">//制作节点，并且只要判断left和right值相不相等，就能知道哪些Token在Expression中，这里程序其实没用上...</span><br>        <span class="hljs-keyword">if</span>(point[mark].type.equals(<span class="hljs-string">&quot;CONST_ID&quot;</span>))&#123;<br>            point[mark].constant=Liu.tokens[mark].value;<br>            point[mark].right=-<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[mark].type.equals(<span class="hljs-string">&quot;T&quot;</span>))&#123; <span class="hljs-comment">//制定一个规则表示T</span><br>            point[mark].left=-<span class="hljs-number">100</span>;<br>            point[mark].right=-<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[mark].type.equals(<span class="hljs-string">&quot;FUNC&quot;</span>))&#123;  <span class="hljs-comment">//制定一个规则来表示不同的func，其实没啥用...</span><br>            <span class="hljs-comment">//&quot;SIN&quot;, &quot;COS&quot;, &quot;TAN&quot;, &quot;LN&quot;, &quot;EXP&quot;, &quot;SQRT&quot;</span><br>            <span class="hljs-keyword">if</span>(Liu.tokens[mark].lexeme.toUpperCase().equals(<span class="hljs-string">&quot;COS&quot;</span>))&#123;<br>                point[mark].left=-<span class="hljs-number">2</span>;<br>                point[mark].right=right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[mark].lexeme.toUpperCase().equals(<span class="hljs-string">&quot;SIN&quot;</span>))&#123;<br>                point[mark].left=-<span class="hljs-number">3</span>;<br>                point[mark].right=right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[mark].lexeme.toUpperCase().equals(<span class="hljs-string">&quot;TAN&quot;</span>))&#123;<br>                point[mark].left=-<span class="hljs-number">4</span>;<br>                point[mark].right=right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[mark].lexeme.toUpperCase().equals(<span class="hljs-string">&quot;LN&quot;</span>))&#123;<br>                point[mark].left=-<span class="hljs-number">5</span>;<br>                point[mark].right=right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[mark].lexeme.toUpperCase().equals(<span class="hljs-string">&quot;EXP&quot;</span>))&#123;<br>                point[mark].left=-<span class="hljs-number">6</span>;<br>                point[mark].right=right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[mark].lexeme.toUpperCase().equals(<span class="hljs-string">&quot;SQRT&quot;</span>))&#123;<br>                point[mark].left=-<span class="hljs-number">7</span>;<br>                point[mark].right=right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            point[mark].left=left;<br>            point[mark].right=right;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MatchToken</span><span class="hljs-params">(String token)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(token))&#123;<br>            current++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(Liu.tokens[current].type+<span class="hljs-string">&quot; Match WRRRRROOOOONG! &quot;</span>+current);<br>            System.exit(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">GetExprValue</span><span class="hljs-params">(Tree[] point, <span class="hljs-keyword">int</span> root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">&quot;PLUS&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> GetExprValue(point,point[root].left)+GetExprValue(point,point[root].right);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">&quot;MINUS&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> GetExprValue(point,point[root].left)-GetExprValue(point,point[root].right);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">&quot;MUL&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> GetExprValue(point,point[root].left)*GetExprValue(point,point[root].right);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">&quot;DIV&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> GetExprValue(point,point[root].left)/GetExprValue(point,point[root].right);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">&quot;POWER&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> Math.pow(GetExprValue(point,point[root].left),GetExprValue(point,point[root].right));<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">&quot;FUNC&quot;</span>))&#123;<br>            <span class="hljs-keyword">switch</span>(point[root].left)&#123;<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">2</span>:<br>                    <span class="hljs-keyword">return</span> Math.cos(GetExprValue(point,point[root].right));<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">3</span>:<br>                    <span class="hljs-keyword">return</span> Math.sin(GetExprValue(point,point[root].right));<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">4</span>:<br>                    <span class="hljs-keyword">return</span> Math.tan(GetExprValue(point,point[root].right));<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">5</span>:<br>                    <span class="hljs-keyword">return</span> Math.log(GetExprValue(point,point[root].right));<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">6</span>:<br>                    <span class="hljs-keyword">return</span> Math.exp(GetExprValue(point,point[root].right));<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">7</span>:<br>                    <span class="hljs-keyword">return</span> Math.sqrt(GetExprValue(point,point[root].right));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">&quot;CONST_ID&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> point[root].constant;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">&quot;T&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> Parameter;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;计算Expression出错&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0.0d</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.0d</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawLoop</span><span class="hljs-params">(<span class="hljs-keyword">double</span> Start,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">double</span> End,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">double</span> Step,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">int</span> x,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">int</span> y,</span></span><br><span class="hljs-params"><span class="hljs-function">                         Tree point[])</span></span>&#123;<br><br>        <span class="hljs-keyword">for</span>(Parameter=Start;Parameter&lt;=End;Parameter+=Step)&#123;<br>            coord[Dian]=CalcCoord(point,coord[Dian],x,y);<br>            Dian++;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;有几个点！！：&quot;</span>+Dian);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Coordinate <span class="hljs-title">CalcCoord</span><span class="hljs-params">(Tree point[],Coordinate coord,<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">double</span> local_x,local_y,temp;<br>        local_x=GetExprValue(point,x);<br>        local_y=GetExprValue(point,y);<br>        local_x*=Scale_x;<br>        local_y*=Scale_y;<br>        temp=local_x*Math.cos(Rot_ang)+local_y*Math.sin(Rot_ang);<br>        local_y=local_y*Math.cos(Rot_ang)-local_x*Math.sin(Rot_ang);<br>        local_x=temp;<br>        local_x+=Origin_x;<br>        local_y+=Origin_y;<br>        coord.x=local_x;<br>        coord.y=local_y;<br>        <span class="hljs-keyword">return</span> coord;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">PrintTree</span><span class="hljs-params">(Tree point[],<span class="hljs-keyword">int</span> root,<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            System.out.print(<span class="hljs-string">&#x27;\t&#x27;</span>);<br>        &#125;<br>        k++;<br>        System.out.println(point[root].type);<br>        <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">&quot;PLUS&quot;</span>))&#123;<br>            PrintTree(point,point[root].left,k);<br>            PrintTree(point,point[root].right,k);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">&quot;MINUS&quot;</span>))&#123;<br>            PrintTree(point,point[root].left,k);<br>            PrintTree(point,point[root].right,k);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">&quot;MUL&quot;</span>))&#123;<br>            PrintTree(point,point[root].left,k);<br>            PrintTree(point,point[root].right,k);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">&quot;DIV&quot;</span>))&#123;<br>            PrintTree(point,point[root].left,k);<br>            PrintTree(point,point[root].right,k);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">&quot;POWER&quot;</span>))&#123;<br>            PrintTree(point,point[root].left,k);<br>            PrintTree(point,point[root].right,k);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">&quot;FUNC&quot;</span>))&#123;<br>            <span class="hljs-keyword">switch</span>(point[root].left)&#123;<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">2</span>:<br>                    PrintTree(point,point[root].right,k);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">3</span>:<br>                    PrintTree(point,point[root].right,k);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">4</span>:<br>                    PrintTree(point,point[root].right,k);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">5</span>:<br>                    PrintTree(point,point[root].right,k);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">6</span>:<br>                    PrintTree(point,point[root].right,k);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">7</span>:<br>                    PrintTree(point,point[root].right,k);<br>                    <span class="hljs-keyword">break</span>;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">&quot;CONST_ID&quot;</span>))&#123;<br><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">&quot;T&quot;</span>))&#123;<br><br>        &#125;<br>    &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>语法分析器</title>
    <link href="/2019/11/10/compiler2/"/>
    <url>/2019/11/10/compiler2/</url>
    
    <content type="html"><![CDATA[<h1 id="语法分析器的构造"><a href="#语法分析器的构造" class="headerlink" title="语法分析器的构造"></a>语法分析器的构造</h1><p>两个任务：</p><blockquote><p>为句子（表达式）构造语法树；<br>检查程序（语句）中的语法错误。</p></blockquote><span id="more"></span><p>主要工作：</p><blockquote><p>设计函数绘图语言的文法，使其适合递归下降分析；<br>设计语法树的节点，用于存放表达式的语法树；<br>设计递归下降子程序，分析句子并构造表达式的语法树；<br>设计测试程序和测试用例，检验分析器是否正确。</p></blockquote><h2 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h2><p>Program   → ε| Program Statement SEMICO</p><p>Statement →  OriginStatment | ScaleStatment<br>        |  RotStatment    | ForStatment</p><p>OriginStatment → ORIGIN IS </p><p>L_BRACKET Expression COMMA Expression R_BRACKET</p><p>ScaleStatment  → SCALE IS </p><p>L_BRACKET Expression COMMA Expression R_BRACKET</p><p>RotStatment → ROT IS Expression</p><p>ForStatment → FOR T<br>   FROM Expression<br>   TO   Expression<br>   STEP Expression<br>   DRAW L_BRACKET Expression COMMA Expression R_BRACKET</p><p>Expression<br>  → Expression PLUS Expression<br>  |  Expression MINUS Expression<br>  |  Expression MUL Expression<br>  |  Expression DIV Expression<br>  |  PLUS Expression<br>  |  MINUS Expression<br>  |  Expression POWER Expression<br>  |  CONST_ID<br>  |  T<br>  |  FUNC L_BRACKET  Expression  R_BRACKET<br>  |  L_BRACKET  Expression  R_BRACKET</p><h2 id="消除二义性"><a href="#消除二义性" class="headerlink" title="消除二义性"></a>消除二义性</h2><p>表达式中的运算                       结合性       非终结符<br> PLUS、MINUS（二元）        左结合       Expression<br> MUL、DIV                              左结合       Term<br> PLUS、MINUS（一元）        右结合       Factor<br> POWER                                  右结合       Component<br>（原子表达式）                           无          Atom</p><p>Expression<br>  → Expression PLUS Expression<br>  |  Expression MINUS Expression<br>  |  Expression MUL Expression<br>  |  Expression DIV Expression<br>  |  PLUS Expression<br>  |  MINUS Expression<br>  |  Expression POWER Expression<br>  |  CONST_ID<br>  |  T<br>  |  FUNC L_BRACKET  Expression  R_BRACKET<br>  |  L_BRACKET  Expression  R_BRACKET</p><blockquote><p>要引入非终结符来体现优先性还有结合性</p></blockquote><h3 id="无二义性的表达式文法"><a href="#无二义性的表达式文法" class="headerlink" title="无二义性的表达式文法"></a>无二义性的表达式文法</h3><p>Expression → Expression PLUS Term<br>        | Expression MINUS Term<br>        | Term<br>Term       → Term MUL Factor<br>        | Term DIV Factor<br>        | Factor<br>Factor     → PLUS Factor<br>        | MINUS Factor<br>        | Component<br>Component  → Atom POWER Component<br>        | Atom<br>Atom       → CONST_ID<br>        |  T<br>        |  FUNC L_BRACKET  Expression  R_BRACKET<br>        |  L_BRACKET  Expression  R_BRACKET</p><h2 id="消除左递归和提取左因子"><a href="#消除左递归和提取左因子" class="headerlink" title="消除左递归和提取左因子"></a>消除左递归和提取左因子</h2><blockquote><p>这样在递归下降分析中不会无限循环寻找左子树</p></blockquote><p><strong>消除Expression和Term 的左递归</strong><br>Expression → Term  Expression’<br>Expression’→ PLUS Term Expression’<br>            | MINUS Term Expression’<br>            |ε</p><p>Term  → Factor Term’<br>Term’ → MUL Factor Term’<br>       | DIV Factor Term’<br>       |ε</p><h2 id="改写左结合的产生式为EBNF形式（避免子程序调用）"><a href="#改写左结合的产生式为EBNF形式（避免子程序调用）" class="headerlink" title="改写左结合的产生式为EBNF形式（避免子程序调用）"></a>改写左结合的产生式为EBNF形式（避免子程序调用）</h2><p>递归子程序仅要求产生式没有左递归。</p><h3 id="改写Program产生式："><a href="#改写Program产生式：" class="headerlink" title="改写Program产生式："></a>改写Program产生式：</h3><p>Program → Statement SEMICO Program |ε的子程序：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Program</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">if</span> (token == NONTOKEN) <span class="hljs-keyword">return</span>;    <br>  Statement(); MathchToken(SEMICO); Program();<br>&#125;<br></code></pre></td></tr></table></figure><p>改写为EBNF形式，以减少不必要的子程序调用。<br>Program  → { Statement SEMICO }的子程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Program</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">while</span> (token != NONTOKEN) <br>   &#123; Statement(); MathchToken(SEMICO); &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="改写Expression产生式："><a href="#改写Expression产生式：" class="headerlink" title="改写Expression产生式："></a>改写Expression产生式：</h3><p>Expression  →Term  Expression’<br>Expression’ → PLUS Term Expression’<br>             | MINUS Term Expression’ |ε </p><p>Expression’→(PLUS|MINUS)Term Expression’|ε<br>Program    →  Statement SEMICO Program |ε </p><p>Expression’ →     {(PLUS|MINUS)Term }<br>Expression → Term {(PLUS|MINUS)Term }<br>Expression的递归子程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Expression</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;    Term();<br>         <span class="hljs-keyword">while</span> (token==PLUS || token==MINUS) <br>    &#123; MathchToken(token); Term();&#125;<br> &#125; <br></code></pre></td></tr></table></figure><h3 id="最终Expression"><a href="#最终Expression" class="headerlink" title="最终Expression"></a>最终Expression</h3><p>Expression     → Term  { ( PLUS | MINUS) Term }<br>Term           → Factor { ( MUL | DIV ) Factor }<br>Factor      → PLUS Factor | MINUS Factor | Component<br>Component     → Atom [POWER Component]<br>Atom → CONST_ID<br>            | T<br>            | FUNC L_BRACKET Expression R_BRACKET<br>            | L_BRACKET Expression R_BRACKET </p><h2 id="构造Expression的语法树"><a href="#构造Expression的语法树" class="headerlink" title="构造Expression的语法树"></a>构造Expression的语法树</h2><p>通过构建语法树，才可在语义分析时通过遍历二叉树计算表达式的值。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>叶节点：常数、参数T等。<br>两个孩子的内部节点：二元运算如Plus、Mul等。<br>                                    一元加：+5转化为5；<br>                                    一元减：-5转化为0-5。<br>一个孩子的内部节点：函数调用，如cos(t)等。<br><img src="/picture/Tree.png" alt="示例"></p><blockquote><p>其实用c/c++做会较为简单，因为指针的存在二叉树很方便。java这里我构建了一个类，其中left,right是左子树或右子树的数组序，其实还是通过数组的序来确定这颗树的。</p></blockquote><p>这里代码在语义分析处附上，因为我将语义分析紧接着语法分析做了。因为比较方便,不用重复创建使用Tokens。</p>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>词法分析器</title>
    <link href="/2019/11/05/compiler1/"/>
    <url>/2019/11/05/compiler1/</url>
    
    <content type="html"><![CDATA[<p>接下来三篇博客将回顾编译原理课程的大作业（编译一个语义极简的画图语言），分别从词法、语法、语义三部分进行梳理。</p><span id="more"></span><h2 id="绘图语言介绍"><a href="#绘图语言介绍" class="headerlink" title="绘图语言介绍"></a>绘图语言介绍</h2><p>&lt;1&gt; 实现简单函数绘图的语句</p><ul><li>循环绘图（FOR-DRAW）</li><li>比例设置（SCALE）</li><li>角度旋转（ROT）</li><li>坐标平移（ORIGIN）</li><li>注释        （– 或 //）</li></ul><hr><p>&lt;2&gt; 屏幕（窗口）的坐标系</p><ul><li>左上角为原点</li><li>x方向从左向右增长</li><li>y方向从上到下增长(与一般的坐标系方向相反)</li></ul><hr><p>&lt;3&gt; 函数绘图源程序举例<br>————— 函数f(t)=t的图形 —————<br>origin is (100, 300);    – 设置原点的偏移量<br>rot is 0;            – 设置旋转角度(不旋转)<br>scale is (1, 1);        – 设置横坐标和纵坐标的比例<br>for T from 0 to 200 step 1 draw (t, 0);<br>                – 横坐标的轨迹（纵坐标为0）<br>for T from 0 to 150 step 1 draw (0, -t);<br>                – 纵坐标的轨迹（横坐标为0）<br>for T from 0 to 120 step 1 draw (t, -t);<br>                – 函数f(t)=t的轨迹<br>//默认值：<br>//  origin is (0, 0)<br>// rot is 0;<br>// scale is (1, 1)</p><blockquote><p>FOR T FROM 起点 TO 终点 STEP 步长 DRAW(横坐标, 纵坐标);</p></blockquote><blockquote><p>令T从起点到终点、每次改变一个步长，绘制出由(横坐标，纵坐标)所规定的点的轨迹。</p></blockquote><blockquote><p>FOR T FROM 0 TO 2*PI STEP PI/50 DRAW (cos(T), sin(T));</p></blockquote><blockquote><p>该语句的作用是令T从0到2*PI、步长 PI/50，绘制出各个点的坐标(cos(T)，sin(T))，即一个单位圆。</p></blockquote><p>语句满足下述规定(原则)：<br>&lt;1&gt;各类语句可以按任意次序书写，且语句以分号结尾。源程序中的语句以它们出现的先后顺序处。<br>&lt;2&gt;ORIGIN、ROT和SCALE语句只影响其后的绘图语句，且遵循最后出现的语句有效的原则。例如，若有下述ROT语句序列：     ROT IS 0.7 ；<br>                                            ROT IS 1.57 ；<br>则随后的绘图语句将按1.57而不是0.7弧度旋转。<br>&lt;3&gt;无论ORIGIN、ROT和SCALE语句的出现顺序如何，图形的变换顺序总是：比例变换→旋转变换→平移变换<br>&lt;4&gt; 语言对大小写不敏感，例如for、For、FOR等，均被认为是同一个保留字。<br>&lt;5&gt; 语句中表达式的值均为双精度类型，旋转角度单位为弧度且为逆时针旋转，平移单位为点。  </p><h2 id="词法分析器的构造"><a href="#词法分析器的构造" class="headerlink" title="词法分析器的构造"></a>词法分析器的构造</h2><blockquote><p>步骤：正规式－NFA－DFA－最小DFA－编写程序－测试 </p></blockquote><p>三个任务</p><blockquote><p>滤掉源程序中的无用成分<br>输出记号供语法分析器使用<br>识别非法输入，并将其标记为“出错记号”。</p></blockquote><p>记号的组成：记号的<strong>类别</strong>和<strong>属性</strong></p><p><strong><em>本简易编译器使用java来构造</em></strong><br>public class Token {<br>    public String type=””;     //类别<br>    public String lexeme=””; //词义，这里是输入的字符串<br>    public double value;  //如果是常数则为常数的值，否则无意义<br>}</p><h4 id="函数绘图语言中记号的分类与表示"><a href="#函数绘图语言中记号的分类与表示" class="headerlink" title="函数绘图语言中记号的分类与表示"></a>函数绘图语言中记号的分类与表示</h4><p>private static final String[] Token_Type = {<br>        “ORIGIN”, “SCALE”, “ROT”, “IS”,      // 保留字（一字一码）<br>        “TO”, “STEP”, “DRAW”, “FOR”, “FROM”, //保留字<br>        “T”,                  // 参数<br>        “SEMICO”, “L_BRACKET”, “R_BRACKET”, “COMMA”,// 分隔符<br>        “PLUS”, “MINUS”, “MUL”, “DIV”, “POWER”,        // 运算符<br>        “FUNC”,                  // 函数（调用）<br>        “CONST_ID”,              // 常数<br>        “NONTOKEN”,              // 空记号（源程序结束）<br>        “ERRTOKEN”              //出错记号（非法符号）<br>};</p><h4 id="正规式"><a href="#正规式" class="headerlink" title="正规式"></a>正规式</h4><p>letter    = [a-zA-Z]<br>digit    = [0-9] </p><p>COMMENT       = “//“|”–”<br>WHITE_SPACE     = (“ “|\t|\n)+<br>SEMICO        = “;”<br>L_BRACKET     = “(“<br>R_BRACKET     = “)”<br>COMMA         = “,”<br>PLUS          = “+”<br>MINUS         = “-“<br>MUL          = “<em>“<br>DIV           = “/“<br>POWER         = “**”<br>CONST_ID        = digit+(“.” digit</em>)?<br>ID            = letter+<br>（去除注释与白空有11个正规式）</p><h4 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h4><p><img src="/picture/DFA.png" alt="DFA"></p><h3 id="程序思路及代码"><a href="#程序思路及代码" class="headerlink" title="程序思路及代码"></a>程序思路及代码</h3><p>思路非常简单，单个单个读取字符，根据DFA匹配，并赋值给Token，以产生记号流给予语法分析器分析。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Token</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String type=<span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">public</span> String lexeme=<span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> value;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OutputToken</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Token[] tokens = <span class="hljs-keyword">new</span> Token[<span class="hljs-number">1000</span>];<span class="hljs-comment">//开辟数组空间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] Token_Type = &#123;<br>            <span class="hljs-string">&quot;ORIGIN&quot;</span>, <span class="hljs-string">&quot;SCALE&quot;</span>, <span class="hljs-string">&quot;ROT&quot;</span>, <span class="hljs-string">&quot;IS&quot;</span>,      <span class="hljs-comment">// 保留字（一字一码）</span><br>            <span class="hljs-string">&quot;TO&quot;</span>, <span class="hljs-string">&quot;STEP&quot;</span>, <span class="hljs-string">&quot;DRAW&quot;</span>, <span class="hljs-string">&quot;FOR&quot;</span>, <span class="hljs-string">&quot;FROM&quot;</span>, <span class="hljs-comment">//保留字</span><br>            <span class="hljs-string">&quot;T&quot;</span>,                  <span class="hljs-comment">// 参数</span><br>            <span class="hljs-string">&quot;SEMICO&quot;</span>, <span class="hljs-string">&quot;L_BRACKET&quot;</span>, <span class="hljs-string">&quot;R_BRACKET&quot;</span>, <span class="hljs-string">&quot;COMMA&quot;</span>,<span class="hljs-comment">// 分隔符</span><br>            <span class="hljs-string">&quot;PLUS&quot;</span>, <span class="hljs-string">&quot;MINUS&quot;</span>, <span class="hljs-string">&quot;MUL&quot;</span>, <span class="hljs-string">&quot;DIV&quot;</span>, <span class="hljs-string">&quot;POWER&quot;</span>,        <span class="hljs-comment">// 运算符</span><br>            <span class="hljs-string">&quot;FUNC&quot;</span>,                  <span class="hljs-comment">// 函数（调用）</span><br>            <span class="hljs-string">&quot;CONST_ID&quot;</span>,              <span class="hljs-comment">// 常数</span><br>            <span class="hljs-string">&quot;NONTOKEN&quot;</span>,              <span class="hljs-comment">// 空记号（源程序结束）</span><br>            <span class="hljs-string">&quot;ERRTOKEN&quot;</span>              <span class="hljs-comment">//出错记号（非法符号）</span><br>    &#125;;<br><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Cifa_Analyzer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        String pathName = <span class="hljs-string">&quot;/Users/leo/Desktop/test.txt&quot;</span>;<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(pathName);<br>        BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(fis));<br>        String temp = <span class="hljs-string">&quot;&quot;</span>;<br>        String string2 = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> ((temp = br.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>            string2 = string2 + temp + <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">char</span>[] chars = string2.toCharArray();<br><span class="hljs-comment">//        OutputToken test=new OutputToken(string);</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) <span class="hljs-comment">//对象需要分别初始化</span><br>        &#123;<br>            tokens[j] = <span class="hljs-keyword">new</span> Token();<br>        &#125;<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; string2.length(); ) &#123;<br>            <span class="hljs-keyword">if</span> ((chars[i] &gt;= <span class="hljs-number">65</span> &amp;&amp; chars[i] &lt;= <span class="hljs-number">90</span>) || (chars[i] &lt;= <span class="hljs-number">122</span> &amp;&amp; chars[i] &gt;= <span class="hljs-number">97</span>)) &#123;<br>                tokens[k].type += <span class="hljs-string">&quot;ID&quot;</span>;<br>                tokens[k].lexeme = tokens[k].lexeme + chars[i];<br>                tokens[k].value = <span class="hljs-number">0.0d</span>;<br>                i++;<br>                <span class="hljs-keyword">while</span> ((chars[i] &gt;= <span class="hljs-number">65</span> &amp;&amp; chars[i] &lt;= <span class="hljs-number">90</span>) || (chars[i] &lt;= <span class="hljs-number">122</span> &amp;&amp; chars[i] &gt;= <span class="hljs-number">97</span>)) &#123;<br>                    tokens[k].lexeme = tokens[k].lexeme + chars[i];<br>                    i++;<br>                &#125;<br>                k++;<br>            &#125;   <span class="hljs-comment">//letter</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[i] &gt;= <span class="hljs-number">48</span> &amp;&amp; chars[i] &lt;= <span class="hljs-number">57</span>) &#123;<br>                tokens[k].type = <span class="hljs-string">&quot;CONST_ID&quot;</span>;<br>                tokens[k].lexeme = tokens[k].lexeme + chars[i];<br>                i++;<br>                <span class="hljs-keyword">while</span> (chars[i] &gt;= <span class="hljs-number">48</span> &amp;&amp; chars[i] &lt;= <span class="hljs-number">57</span>) &#123;<br>                    tokens[k].lexeme = tokens[k].lexeme + chars[i];<br>                    i++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    tokens[k].lexeme = tokens[k].lexeme + chars[i];<br>                    i++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    tokens[k].value = Double.parseDouble(tokens[k].lexeme);<br>                    k++;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (chars[i] &gt;= <span class="hljs-number">48</span> &amp;&amp; chars[i] &lt;= <span class="hljs-number">57</span>) &#123;<br>                    <span class="hljs-keyword">while</span> (chars[i] &gt;= <span class="hljs-number">48</span> &amp;&amp; chars[i] &lt;= <span class="hljs-number">57</span>) &#123;<br>                        tokens[k].lexeme = tokens[k].lexeme + chars[i];<br>                        i++;<br>                    &#125;<br>                    tokens[k].value = Double.parseDouble(tokens[k].lexeme);<br>                    k++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    System.out.println(tokens[k].lexeme);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br><br>            &#125;<span class="hljs-comment">//digit</span><br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (chars[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    tokens[k].type = <span class="hljs-string">&quot;POWER&quot;</span>;<br>                    tokens[k].lexeme = <span class="hljs-string">&quot;**&quot;</span>;<br>                    tokens[k].value = <span class="hljs-number">0.0d</span>;<br>                    i = i + <span class="hljs-number">2</span>;<br>                    k++;<br><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    tokens[k].type = <span class="hljs-string">&quot;MUL&quot;</span>;<br>                    tokens[k].lexeme = <span class="hljs-string">&quot;*&quot;</span>;<br>                    tokens[k].value = <span class="hljs-number">0.0d</span>;<br>                    i++;<br>                    k++;<br>                &#125;<br>            &#125;<span class="hljs-comment">// MUL and POWER</span><br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (chars[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>                    <span class="hljs-comment">//tokens[k].type = &quot;COMMENT&quot;;</span><br>                    <span class="hljs-comment">//tokens[k].lexeme = &quot;//&quot;;</span><br>                    <span class="hljs-comment">//tokens[k].value = 0.0d;</span><br>                    i = i + <span class="hljs-number">2</span>;<br>                    <span class="hljs-comment">//k++;</span><br>                    <span class="hljs-keyword">while</span> (chars[i] != <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;   <span class="hljs-comment">//直接跳到换行符之后</span><br>                        i++;<br>                        <span class="hljs-keyword">if</span> (i == string2.length()) &#123;<br>                            <span class="hljs-keyword">return</span> k;<br>                        &#125;<br>                    &#125;<br>                    i++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    tokens[k].type = <span class="hljs-string">&quot;DIV&quot;</span>;<br>                    tokens[k].lexeme = <span class="hljs-string">&quot;/&quot;</span>;<br>                    tokens[k].value = <span class="hljs-number">0.0d</span>;<br>                    i++;<br>                    k++;<br>                &#125;<br>            &#125;<span class="hljs-comment">// 注释或者除</span><br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (chars[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                    tokens[k].type = <span class="hljs-string">&quot;COMMENT&quot;</span>;<br>                    tokens[k].lexeme = <span class="hljs-string">&quot;--&quot;</span>;<br>                    tokens[k].value = <span class="hljs-number">0.0d</span>;<br>                    i = i + <span class="hljs-number">2</span>;<br>                    k++;<br>                    <span class="hljs-keyword">while</span> (chars[i] != <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;   <span class="hljs-comment">//直接跳到换行符之后</span><br>                        i++;<br>                        <span class="hljs-keyword">if</span> (i == string2.length()) &#123;<br>                            <span class="hljs-keyword">return</span> k;<br>                        &#125;<br>                    &#125;<br>                    i++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    tokens[k].type = <span class="hljs-string">&quot;MINUS&quot;</span>;<br>                    tokens[k].lexeme = <span class="hljs-string">&quot;-&quot;</span>;<br>                    tokens[k].value = <span class="hljs-number">0.0d</span>;<br>                    i++;<br>                    k++;<br>                &#125;<br>            &#125;<span class="hljs-comment">// 注释或者减</span><br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                tokens[k].type = <span class="hljs-string">&quot;PLUS&quot;</span>;<br>                tokens[k].lexeme = <span class="hljs-string">&quot;+&quot;</span>;<br>                tokens[k].value = <span class="hljs-number">0.0d</span>;<br>                i++;<br>                k++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>                tokens[k].type = <span class="hljs-string">&quot;COMMA&quot;</span>;<br>                tokens[k].lexeme = <span class="hljs-string">&quot;,&quot;</span>;<br>                tokens[k].value = <span class="hljs-number">0.0d</span>;<br>                i++;<br>                k++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">&#x27;;&#x27;</span>) &#123;<br>                tokens[k].type = <span class="hljs-string">&quot;SEMICO&quot;</span>;<br>                tokens[k].lexeme = <span class="hljs-string">&quot;;&quot;</span>;<br>                tokens[k].value = <span class="hljs-number">0.0d</span>;<br>                i++;<br>                k++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                tokens[k].type = <span class="hljs-string">&quot;L_BRACKET&quot;</span>;<br>                tokens[k].lexeme = <span class="hljs-string">&quot;(&quot;</span>;<br>                tokens[k].value = <span class="hljs-number">0.0d</span>;<br>                i++;<br>                k++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                tokens[k].type = <span class="hljs-string">&quot;R_BRACKET&quot;</span>;<br>                tokens[k].lexeme = <span class="hljs-string">&quot;)&quot;</span>;<br>                tokens[k].value = <span class="hljs-number">0.0d</span>;<br>                i++;<br>                k++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-number">9</span> || chars[i] == <span class="hljs-string">&#x27;\n&#x27;</span> || chars[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                <span class="hljs-comment">//tokens[k].type=&quot;WHITE_SPACE&quot;;</span><br>                <span class="hljs-comment">//tokens[k].lexeme+=chars[i];</span><br>                <span class="hljs-comment">//tokens[k].value=0.0d;</span><br>                i++;<br>                <span class="hljs-comment">//k++;</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(chars[i] + <span class="hljs-string">&quot; 词法错误 &quot;</span> + <span class="hljs-string">&quot;位置：&quot;</span> + k);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        String functions[] = &#123;<span class="hljs-string">&quot;SIN&quot;</span>, <span class="hljs-string">&quot;COS&quot;</span>, <span class="hljs-string">&quot;TAN&quot;</span>, <span class="hljs-string">&quot;LN&quot;</span>, <span class="hljs-string">&quot;EXP&quot;</span>, <span class="hljs-string">&quot;SQRT&quot;</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> kk = <span class="hljs-number">0</span>; kk &lt; k; kk++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ii = <span class="hljs-number">0</span>; ii &lt; <span class="hljs-number">10</span>; ii++) &#123;<br>                <span class="hljs-keyword">if</span> (tokens[kk].lexeme.toUpperCase().equals(Token_Type[ii])) &#123;<br>                    tokens[kk].type = Token_Type[ii];<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ii = <span class="hljs-number">0</span>; ii &lt; functions.length; ii++) &#123;<br>                <span class="hljs-keyword">if</span> (tokens[kk].lexeme.toUpperCase().equals(functions[ii])) &#123;<br>                    tokens[kk].type = <span class="hljs-string">&quot;FUNC&quot;</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tokens[kk].lexeme.toUpperCase().equals(<span class="hljs-string">&quot;PI&quot;</span>)) &#123;<br>                tokens[kk].type = <span class="hljs-string">&quot;CONST_ID&quot;</span>;<br>                tokens[kk].value = <span class="hljs-number">3.1415926d</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tokens[kk].lexeme.toUpperCase().equals(<span class="hljs-string">&quot;E&quot;</span>)) &#123;<br>                tokens[kk].type = <span class="hljs-string">&quot;CONST_ID&quot;</span>;<br>                tokens[kk].value = <span class="hljs-number">2.71828d</span>;<br>            &#125;<br>        &#125;<br><br>        tokens[k].type=<span class="hljs-string">&quot;NONTOKEN&quot;</span>;<br>        tokens[k].value=<span class="hljs-number">0.0d</span>;<br>        tokens[k].lexeme=<span class="hljs-string">&quot;NONTOKEN&quot;</span>;<br>        <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k+<span class="hljs-number">1</span>; i++) &#123;<br>                System.out.print(tokens[i].type);<br>                System.out.print(<span class="hljs-string">&quot;    &quot;</span>);<br>                System.out.print(tokens[i].lexeme);<br>                System.out.print(<span class="hljs-string">&quot;    &quot;</span>);<br>                System.out.println(tokens[i].value);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux3.8.13编译内核的小问题</title>
    <link href="/2019/11/01/OS-Problems/"/>
    <url>/2019/11/01/OS-Problems/</url>
    
    <content type="html"><![CDATA[<h2 id="设备环境"><a href="#设备环境" class="headerlink" title="设备环境"></a>设备环境</h2><blockquote><p>Ubuntu 64位 16.04</p></blockquote><h2 id="编译内核时出现的问题"><a href="#编译内核时出现的问题" class="headerlink" title="编译内核时出现的问题"></a>编译内核时出现的问题</h2><p>最近在做操作系统的实验的第一个作业，编译内核。下载的是linux3.8.13的内核文件。</p><span id="more"></span><p>在基本的启动内核配置程序之后</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#make bzImage</span><br></code></pre></td></tr></table></figure><p>生成内核的镜像文件时发生了以下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs bash">lib/mpi/generic_mpih-mul1.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-mul1.o：在函数‘mpihelp_add’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/generic_mpih-mul1.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-mul1.o：在函数‘mpihelp_sub’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/generic_mpih-mul2.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-mul2.o：在函数‘mpihelp_add’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/generic_mpih-mul2.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-mul2.o：在函数‘mpihelp_sub’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/generic_mpih-mul3.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-mul3.o：在函数‘mpihelp_add’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/generic_mpih-mul3.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-mul3.o：在函数‘mpihelp_sub’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/generic_mpih-rshift.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-rshift.o：在函数‘mpihelp_add’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/generic_mpih-rshift.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-rshift.o：在函数‘mpihelp_sub’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/generic_mpih-sub1.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-sub1.o：在函数‘mpihelp_add’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/generic_mpih-sub1.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-sub1.o：在函数‘mpihelp_sub’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/generic_mpih-add1.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-add1.o：在函数‘mpihelp_add’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/generic_mpih-add1.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-add1.o：在函数‘mpihelp_sub’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/mpicoder.o：在函数‘mpihelp_add’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义</span><br><span class="hljs-string">lib/mpi/mpicoder.o：在函数‘mpihelp_sub_1’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义<br>lib/mpi/mpicoder.o：在函数‘mpihelp_sub’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义</span><br><span class="hljs-string">lib/mpi/mpicoder.o：在函数‘mpihelp_add_1’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义<br>lib/mpi/mpi-bit.o：在函数‘mpihelp_add’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义</span><br><span class="hljs-string">lib/mpi/mpi-bit.o：在函数‘mpihelp_sub_1’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义<br>lib/mpi/mpi-bit.o：在函数‘mpihelp_sub’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义</span><br><span class="hljs-string">lib/mpi/mpi-bit.o：在函数‘mpihelp_add_1’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义<br>lib/mpi/mpi-cmp.o：在函数‘mpihelp_add’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义</span><br><span class="hljs-string">lib/mpi/mpi-cmp.o：在函数‘mpihelp_sub_1’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义<br>lib/mpi/mpi-cmp.o：在函数‘mpihelp_sub’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义</span><br><span class="hljs-string">lib/mpi/mpi-cmp.o：在函数‘mpihelp_add_1’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义<br>lib/mpi/mpih-cmp.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义</span><br><span class="hljs-string">lib/mpi/mpih-cmp.o：在函数‘mpihelp_add’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/mpih-cmp.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义</span><br><span class="hljs-string">lib/mpi/mpih-cmp.o：在函数‘mpihelp_sub’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/mpih-div.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义</span><br><span class="hljs-string">lib/mpi/mpih-div.o：在函数‘mpihelp_add’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/mpih-div.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义</span><br><span class="hljs-string">lib/mpi/mpih-div.o：在函数‘mpihelp_sub’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/mpih-mul.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义</span><br><span class="hljs-string">lib/mpi/mpih-mul.o：在函数‘mpihelp_add’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/mpih-mul.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义</span><br><span class="hljs-string">lib/mpi/mpih-mul.o：在函数‘mpihelp_sub’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/mpi-pow.o：在函数‘mpihelp_add’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义</span><br><span class="hljs-string">lib/mpi/mpi-pow.o：在函数‘mpihelp_sub_1’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义<br>lib/mpi/mpi-pow.o：在函数‘mpihelp_sub’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义</span><br><span class="hljs-string">lib/mpi/mpi-pow.o：在函数‘mpihelp_add_1’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义<br>lib/mpi/mpiutil.o：在函数‘mpihelp_add’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义</span><br><span class="hljs-string">lib/mpi/mpiutil.o：在函数‘mpihelp_sub_1’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义<br>lib/mpi/mpiutil.o：在函数‘mpihelp_sub’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub<span class="hljs-string">&#x27;被多次定义</span><br><span class="hljs-string">lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义</span><br><span class="hljs-string">lib/mpi/mpiutil.o：在函数‘mpihelp_add_1’中：</span><br><span class="hljs-string">/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1&#x27;</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义<br>scripts/Makefile.build:440: recipe <span class="hljs-keyword">for</span> target <span class="hljs-string">&#x27;lib/mpi/mpi.o&#x27;</span> failed<br>make[2]: *** [lib/mpi/mpi.o] Error 1<br>scripts/Makefile.build:454: recipe <span class="hljs-keyword">for</span> target <span class="hljs-string">&#x27;lib/mpi&#x27;</span> failed<br>make[1]: *** [lib/mpi] Error 2<br>Makefile:791: recipe <span class="hljs-keyword">for</span> target <span class="hljs-string">&#x27;lib&#x27;</span> failed<br>make: *** [lib] Error 2<br></code></pre></td></tr></table></figure><p>这个问题是卡了我稍长时间的，网上的解答很少。</p><blockquote><p>其中有个方法是修改lib/mpi-inline.h 中 将extern inline修改为static inline，经测试无效，文件下定义的其他函数非static类型。<br>和同学交流发现他们都没出现此问题，就感觉是自己虚拟机的问题。最后发现其实是编译器版本较高，而内核版本太老，自己的ubuntu 16.04 默认的gcc是5.4版本的，将其退至4.9版本即可顺利编译。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get install -y gcc-4.9<br>$ <span class="hljs-built_in">cd</span> /usr/bin<br>$ sudo rm gcc<br>$ sudo ln -s gcc-4.9 gcc<br></code></pre></td></tr></table></figure><p>安装gcc4.9，再链接实现降级<br>最后gcc -v 检查版本号。</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PekingOJ 1363&amp;1125&amp;1564&amp;1511</title>
    <link href="/2019/10/29/PekingOJ/"/>
    <url>/2019/10/29/PekingOJ/</url>
    
    <content type="html"><![CDATA[<h2 id="这四题都是easy难度的，但还是很适合初学者好好练习的！【老师布置的题目原来不是按难度排序的-】"><a href="#这四题都是easy难度的，但还是很适合初学者好好练习的！【老师布置的题目原来不是按难度排序的-】" class="headerlink" title="这四题都是easy难度的，但还是很适合初学者好好练习的！【老师布置的题目原来不是按难度排序的..】"></a>这四题都是easy难度的，但还是很适合初学者好好练习的！【老师布置的题目原来不是按难度排序的..】</h2><span id="more"></span><h3 id="一、Stack"><a href="#一、Stack" class="headerlink" title="一、Stack"></a>一、Stack</h3><p>就是给定一个入栈顺序，去判断给定的出栈顺序可不可能实现<br>Sample Input</p><p>5<br>1 2 3 4 5<br>5 4 1 2 3<br>0<br>6<br>6 5 4 3 2 1<br>0<br>0<br>Sample Output</p><p>Yes<br>No</p><p>Yes</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>stack&lt;<span class="hljs-keyword">int</span>&gt; mystack;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Stackjudge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[<span class="hljs-number">1000</span>],<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(!mystack.<span class="hljs-built_in">empty</span>())&#123;<br>        mystack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">int</span> i,j;<br>    <span class="hljs-keyword">int</span> flag1=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> test;<br>    <span class="hljs-keyword">int</span> first=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;num+<span class="hljs-number">1</span>;i++)&#123;   <span class="hljs-comment">//算出第一位</span><br>        <span class="hljs-keyword">if</span>(i!=q[<span class="hljs-number">0</span>])&#123;<br>            mystack.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            first=i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!first)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;num;j++)&#123;<br>        <span class="hljs-keyword">if</span>(q[j]&gt;q[j<span class="hljs-number">-1</span>])&#123;<br>            <span class="hljs-keyword">for</span>(i=first+<span class="hljs-number">1</span>;i&lt;num+<span class="hljs-number">1</span>;i++)&#123;<br>                mystack.<span class="hljs-built_in">push</span>(i);<br>                <span class="hljs-keyword">if</span>(i==q[j])&#123;<br>                    mystack.<span class="hljs-built_in">pop</span>();<br>                    first=i;<br>                    flag1=<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!flag1)&#123;<br>                cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        flag1=<span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">if</span>(q[j]&lt;q[j<span class="hljs-number">-1</span>])&#123;<br>            test=mystack.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span>(test==q[j])&#123;<br>                mystack.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> Q[<span class="hljs-number">1000</span>];<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">int</span> num;<br>        cin&gt;&gt;num;<br>        <span class="hljs-keyword">if</span>(num==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            cin&gt;&gt;Q[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span>(Q[<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;num;i++)&#123;<br>                cin&gt;&gt;Q[i];<br>            &#125;<br>            <span class="hljs-built_in">Stackjudge</span>(Q,num);<br>        &#125;<br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、最短路径"><a href="#二、最短路径" class="headerlink" title="二、最短路径"></a>二、最短路径</h3><p>股票经纪人对谣言的过分反应是周知的。你受雇找一种在股市中散布谣言的方法，使之以最快的速度传播给所有的人。<br>你必须把谣言先传给一个最合适的人<br>输入：<br>3             //三个人 2 2 4 3 5  //1号人有2个联系人，和2号花时间4,和3号花时间5 2 1 2 3 6   //2号人…… 2 1 2 2 253 4 4 2 8 5 31 5 84 1 6 4 10 2 7 5 2<br>输出：<br>3 2  //先传给3号，最多花时间2 3 10</p><blockquote><p>分析：任意两点间求出最短路径(Floyd?) 。<br>找点：到任意点都有路径。“谣言传播”总耗时等于这些路径的最大值。<br>目标：使这个最大值最小的某个点。</p></blockquote><p>这题不太想做…直接给floyd的算法吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;n;k++)<br>     <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">for</span>( j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>           <span class="hljs-keyword">if</span> (d[i][j]&gt;d[i][k]+d[k][j])<br>               d[i][j]=d[i][k]+d[k][j]; <br>                <span class="hljs-comment">//d[i][j]=Min(d[i][j], d[i][k]+d[k][j]) </span><br><br></code></pre></td></tr></table></figure><h3 id="三、DFS"><a href="#三、DFS" class="headerlink" title="三、DFS"></a>三、DFS</h3><p>Sum it up<br>求出所有可能的加法可能<br><strong>Sample Input</strong></p><p>4 6 4 3 2 2 1 1<br>5 3 2 1 1<br>400 12 50 50 50 50 50 50 25 25 25 25 25 25<br>0 0</p><p><strong>Sample Output</strong></p><p>Sums of 4:<br>4<br>3+1<br>2+2<br>2+1+1<br>Sums of 5:<br>NONE<br>Sums of 400:<br>50+50+50+50+50+50+25+25+25+25<br>50+50+50+50+50+25+25+25+25+25+25</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,t,a[<span class="hljs-number">13</span>],b[<span class="hljs-number">13</span>],flag=<span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num,<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> sum)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(sum==<span class="hljs-number">0</span>)&#123;   <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;num;i++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;+%d&quot;</span>,b[i]);<br>        cout&lt;&lt;endl;<br>        flag=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=k;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>((i==k||a[i]!=a[i<span class="hljs-number">-1</span>])&amp;&amp;sum-a[i]&gt;=<span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//去重</span><br>            b[num]=a[i];<br>            <span class="hljs-built_in">dfs</span>(num+<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>,sum-a[i]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        cin&gt;&gt;t&gt;&gt;n;<br>        <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>&amp;&amp;n==<span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>            cin&gt;&gt;a[i];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sums of %d:\n&quot;</span>,t);<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,t);<br>        <span class="hljs-keyword">if</span>(f) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NONE\n&quot;</span>);<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h3 id="四、Dijkstra变形题"><a href="#四、Dijkstra变形题" class="headerlink" title="四、Dijkstra变形题"></a>四、Dijkstra变形题</h3><p><a href="https://www.cnblogs.com/ZJUT-jiangnan/p/3935745.html">POJ - 1511 Invitation Cards（Dijkstra变形题）</a><br>因为不太熟悉C++的容器，并且本题要求存储的数据量极大，二重矩阵十分浪费空间且运行时间不过关，需要使用其他的数据结构，所以参考了以下博客。<br>这道题主要就让自己知道怎样构建“数组链表”<br>这里就提取几行关键的数据结构代码，博客中没有注释，我稍微写了一点点注释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;edge&gt; map[maxn];   <span class="hljs-comment">//vector容器</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; P;   <br><br>map[a].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(a,b,c));  <span class="hljs-comment">//将一条边的信息链接在map[起始点]的最后面</span><br><br>priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; Q; <span class="hljs-comment">//dijkstra算法中构建Q优先队列</span><br>                                            <span class="hljs-comment">//&lt;Type,Container,Function&gt;</span><br><br>Q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">P</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));            <span class="hljs-comment">//源点是1，dist[1]=0</span><br><span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())&#123;<br>    <span class="hljs-keyword">int</span> v=Q.<span class="hljs-built_in">top</span>().second;     <span class="hljs-comment">// 这里开始看编号为v的这个点</span><br>    Q.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(visited[v])  <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//已经访问过的点就不再考虑了，这也就是为什么一旦边的权值有负数，此算法就没用了，因为还有可能从原来的路径绕路得到最短路径。有负值时我们采用Bellmam-Ford算法。</span><br>    visited[v]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;map[v].<span class="hljs-built_in">size</span>();i++)&#123;      <span class="hljs-comment">//这个size就是从v这个点有多少个边，遍历这些边，去做最短路径的替换</span><br>        edge e=map[v][i];<br>        <span class="hljs-keyword">if</span>(dist[e.t]&gt;dist[v]+e.c)&#123;<br>            dist[e.t]=dist[v]+e.c;<br>            Q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">P</span>(dist[e.t],e.t));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然本题还要求各个点到源点的最短距离，这时我们可以用一个思路：反图，我们将原图中的所有边的方向反转，此时对远点使用Dijkstra算法则可得到其余各点到源点的最短距离。 大家自己画张图就可以很好得理解啦！</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PekingUniversityOJ No.1222</title>
    <link href="/2019/10/18/PekingOJ%201222/"/>
    <url>/2019/10/18/PekingOJ%201222/</url>
    
    <content type="html"><![CDATA[<p>这是一个很经典的小游戏，在一个m*n的格子，每按一下一个格子，包括自己这个格子和上下左右共5个格子的灯都会转变状态（亮-&gt;暗/暗-&gt;亮） 记得不久之前和薛老师去玩一个以“未闻花名”为主题的密室里，也有这个游戏，我当时就瞎捣鼓，莫名其妙全点灭了，没想到这次做题竟然又遇到了这个游戏！</p><span id="more"></span><p>Description</p><p>In an extended version of the game Lights Out, is a puzzle with 5 rows of 6 buttons each (the actual puzzle has 5 rows of 5 buttons each). Each button has a light. When a button is pressed, that button and each of its (up to four) neighbors above, below, right and left, has the state of its light reversed. (If on, the light is turned off; if off, the light is turned on.) Buttons in the corners change the state of 3 buttons; buttons on an edge change the state of 4 buttons and other buttons change the state of 5. For example, if the buttons marked X on the left below were to be pressed,the display would change to the image on the right. </p><p>The aim of the game is, starting from any initial set of lights on in the display, to press buttons to get the display to a state where all lights are off. When adjacent buttons are pressed, the action of one button can undo the effect of another. For instance, in the display below, pressing buttons marked X in the left display results in the right display.Note that the buttons in row 2 column 3 and row 2 column 5 both change the state of the button in row 2 column 4,so that, in the end, its state is unchanged. </p><p>Note: </p><ol><li>It does not matter what order the buttons are pressed. </li><li>If a button is pressed a second time, it exactly cancels the effect of the first press, so no button ever need be pressed more than once. </li><li>As illustrated in the second diagram, all the lights in the first row may be turned off, by pressing the corresponding buttons in the second row. By repeating this process in each row, all the lights in the first<br>four rows may be turned out. Similarly, by pressing buttons in columns 2, 3 ?, all lights in the first 5 columns may be turned off.<br>Write a program to solve the puzzle.<br>Input</li></ol><p>The first line of the input is a positive integer n which is the number of puzzles that follow. Each puzzle will be five lines, each of which has six 0 or 1 separated by one or more spaces. A 0 indicates that the light is off, while a 1 indicates that the light is on initially.<br>Output</p><p>For each puzzle, the output consists of a line with the string: “PUZZLE #m”, where m is the index of the puzzle in the input file. Following that line, is a puzzle-like display (in the same format as the input) . In this case, 1’s indicate buttons that must be pressed to solve the puzzle, while 0 indicate buttons, which are not pressed. There should be exactly one space between each 0 or 1 in the output puzzle-like display.<br>Sample Input</p><p>2<br>0 1 1 0 1 0<br>1 0 0 1 1 1<br>0 0 1 0 0 1<br>1 0 0 1 0 1<br>0 1 1 1 0 0<br>0 0 1 0 1 0<br>1 0 1 0 1 1<br>0 0 1 0 1 1<br>1 0 1 1 0 0<br>0 1 0 1 0 0<br>Sample Output</p><p>PUZZLE #1<br>1 0 1 0 0 1<br>1 1 0 1 0 1<br>0 0 1 0 1 1<br>1 0 0 1 0 0<br>0 1 0 0 0 0<br>PUZZLE #2<br>1 0 0 1 1 1<br>1 1 0 0 0 0<br>0 0 0 1 0 0<br>1 1 0 1 0 1<br>1 0 1 1 0 1<br>Source</p><p>Greater New York 2002</p><h1 id="总体思路：二进制枚举-贪心"><a href="#总体思路：二进制枚举-贪心" class="headerlink" title="总体思路：二进制枚举+贪心"></a>总体思路：<strong>二进制枚举+贪心</strong></h1><h2 id="首先介绍一下二进制枚举算法"><a href="#首先介绍一下二进制枚举算法" class="headerlink" title="首先介绍一下二进制枚举算法"></a>首先介绍一下二进制枚举算法</h2><p>这里要了解位运算，尤其是按位与还有移位运算。</p><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><p>a&lt;&lt;b运算就是，将二进制a向左移b位，也就是a右边添上b个0。如2的二进制是10，向左移一位就是100，则为十进制4，不难发现左移n位，及等价于乘上2^n<br>那么下面的代码即可遍历0到2^(n-1)之内的数</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; n); i++);<br></code></pre></td></tr></table></figure><h3 id="按位与运算"><a href="#按位与运算" class="headerlink" title="按位与运算"></a>按位与运算</h3><p>运算规则：0&amp;0=0;  0&amp;1=0;   1&amp;0=0;    1&amp;1=1;<br>对于某个二进制数10100</p><blockquote><p>10100&amp;00001=00000<br>10100&amp;00010=00000<br>10100&amp;00100=00100<br>10100&amp;01000=00000<br>10100&amp;10000=10000<br>举上面的例子其实就是更好得解释二进制枚举<br>下面展示较完整的代码</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span>&lt;&lt;n); i++) <span class="hljs-comment">//从0～2^n-1个状态</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) <span class="hljs-comment">//遍历二进制的每一位</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(i &amp; (<span class="hljs-number">1</span> &lt;&lt; j))<span class="hljs-comment">//判断二进制第j位是否存在</span><br>        &#123;<br>        .............<span class="hljs-comment">//如果第j位存在，则改变相应状态变量【做题用】</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于这个题目，我们其实只要二进制枚举第一行灯的按压状态，而之后的每一行直接运用贪心算法即可，即上一行哪个灯亮，就按对应下一行的灯，保证上一行的灯全暗。<br>其实有个小疑问，是否会出现一种初始状态，出现无解的情况呢。<br>下面附上全部代码，由于北大oj编译器版本较老，声明的数组维度中不能出现变量，所以代码oj是显示compile error的，但思路和解决方法我认为是没问题的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> press[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>];<br><span class="hljs-keyword">int</span> puzzle[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>];<br><span class="hljs-keyword">int</span> countt=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tanxin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> puzzle[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>])</span></span>&#123;     <span class="hljs-comment">//贪心算法</span><br>    <span class="hljs-keyword">int</span> i,j,flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">6</span>;j++)&#123;<br>            <span class="hljs-keyword">if</span>(puzzle[i][j]==<span class="hljs-number">1</span>)&#123;<br>                press[i+<span class="hljs-number">1</span>][j]=<span class="hljs-number">1</span>;<br>                puzzle[i+<span class="hljs-number">1</span>][j]=(puzzle[i+<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span>(j!=<span class="hljs-number">0</span>)&#123;            <span class="hljs-comment">//第一列</span><br>                    puzzle[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]=(puzzle[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(j!=<span class="hljs-number">5</span>)&#123;            <span class="hljs-comment">//最后一列</span><br>                    puzzle[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=(puzzle[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">3</span>)&#123;            <span class="hljs-comment">//倒数第二行</span><br>                    puzzle[i+<span class="hljs-number">2</span>][j]=(puzzle[i+<span class="hljs-number">2</span>][j]+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">6</span>;j++)&#123;               <span class="hljs-comment">//仅需判断最后一行是否全0即可，因为是贪心算法做的</span><br>        <span class="hljs-keyword">if</span>(puzzle[<span class="hljs-number">4</span>][j]==<span class="hljs-number">1</span>)&#123;<br>            flag=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag)&#123;<br>        countt++;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;PUZZLE #&quot;</span>&lt;&lt;countt&lt;&lt;endl;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">6</span>;j++)&#123;<br><br>                std::cout&lt;&lt;press[i][j]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>            <br>            &#125;<br>            std::cout&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> map[][<span class="hljs-number">6</span>])</span></span>&#123;   <span class="hljs-comment">//枚举第一行，贪心剩余几行</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> modd;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">64</span>;i++)&#123;        <span class="hljs-comment">//i&lt;(1&lt;&lt;6)</span><br>            <span class="hljs-built_in">memcpy</span>(puzzle,map,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(puzzle));<br>            <span class="hljs-built_in">memset</span>(press,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(press));<br>            <span class="hljs-keyword">for</span>(modd=<span class="hljs-number">0</span>;modd&lt;<span class="hljs-number">6</span>;modd++)&#123;<br>                <span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;modd))&#123;<span class="hljs-comment">//1&lt;&lt;mod 除了向左移的那一位1，剩余的都是0，所以我们就可以得到那一位是不是1</span><br>                        puzzle[<span class="hljs-number">0</span>][modd]=(<span class="hljs-number">1</span>+puzzle[<span class="hljs-number">0</span>][modd])%<span class="hljs-number">2</span>;<br>                        puzzle[<span class="hljs-number">1</span>][modd]=(<span class="hljs-number">1</span>+puzzle[<span class="hljs-number">1</span>][modd])%<span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">if</span>(modd!=<span class="hljs-number">0</span>)&#123;<br>                            puzzle[<span class="hljs-number">0</span>][modd<span class="hljs-number">-1</span>]=(<span class="hljs-number">1</span>+puzzle[<span class="hljs-number">0</span>][modd<span class="hljs-number">-1</span>])%<span class="hljs-number">2</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span>(modd!=<span class="hljs-number">5</span>)&#123;<br>                            puzzle[<span class="hljs-number">0</span>][modd+<span class="hljs-number">1</span>]=(<span class="hljs-number">1</span>+puzzle[<span class="hljs-number">0</span>][modd+<span class="hljs-number">1</span>])%<span class="hljs-number">2</span>;<br>                        &#125;<br>                        press[<span class="hljs-number">0</span>][modd]=<span class="hljs-number">1</span>;<br>                    &#125;<br>            &#125;<br>            <span class="hljs-built_in">tanxin</span>(puzzle);        <span class="hljs-comment">//判断</span><br>        &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> times=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> m,i,j;<br>    std::cin&gt;&gt;times;<br>    m=<span class="hljs-number">5</span>*times;<br>    <span class="hljs-keyword">int</span> puzzlee[m][<span class="hljs-number">6</span>];<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">6</span>;j++)&#123;<br>            std::cin&gt;&gt;puzzlee[i][j];<br>        &#125;<br>    &#125;<br>            <br>   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;times;i++)<br>        <span class="hljs-built_in">solve</span>(puzzlee+i*<span class="hljs-number">5</span>);     <span class="hljs-comment">//每一次迭代，指向puzzle数组的next5行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因为是课上老师捎带提过的题目，思路很快就出来了，但在coding阶段主要就遇到了原来不曾用过的二进制枚举问题。我一开始的想法是通过把第一行六列所有的组合通过一个状态矩阵的判重循环出来，但其实有很大的漏洞。后来我就想到我可以求{0,1,2,3,4,5}的幂集，即构造一个二叉树，左右子树分别对应“取，舍”两种状态，然后分别对6个元素一一做取舍，最后的子树即位这2^6个集合…但，有点麻烦。求出幂集后还得变为相应二进制状态。最后查阅资料学习了二进制枚举，解决了这道题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PekingUniversityOJ No.1979</title>
    <link href="/2019/10/17/PekingOJ%201979/"/>
    <url>/2019/10/17/PekingOJ%201979/</url>
    
    <content type="html"><![CDATA[<p>这学期一时兴起选修选了个acm课，其实就想补补自己的数据结构和算法，大学前两年下来感觉代码功底不够扎实，希望借此机会巩固加强一下代码能力，算法题我主要以C++来实现，因为自己C++没有系统的学习过，就以练代学吧！</p><span id="more"></span><h3 id="本题是一道很简单的搜索题，也正好是课上刚巩固的内容。这里我使用的是广度优先搜索，单纯因为想练练广搜的算法实现。"><a href="#本题是一道很简单的搜索题，也正好是课上刚巩固的内容。这里我使用的是广度优先搜索，单纯因为想练练广搜的算法实现。" class="headerlink" title="本题是一道很简单的搜索题，也正好是课上刚巩固的内容。这里我使用的是广度优先搜索，单纯因为想练练广搜的算法实现。"></a>本题是一道很简单的搜索题，也正好是课上刚巩固的内容。这里我使用的是广度优先搜索，单纯因为想练练广搜的算法实现。</h3><p>Description</p><p>There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles. </p><p>Write a program to count the number of black tiles which he can reach by repeating the moves described above.<br>Input</p><p>The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20. </p><p>There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows. </p><p>‘.’ - a black tile<br>‘#’ - a red tile<br>‘@’ - a man on a black tile(appears exactly once in a data set)<br>The end of the input is indicated by a line consisting of two zeros.<br>Output</p><p>For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).<br>Sample Input</p><p>6 9<br>….#.<br>…..#<br>……<br>……<br>……<br>……<br>……<br>#@…#<br>.#..#.<br>11 9<br>.#………<br>.#.#######.<br>.#.#…..#.<br>.#.#.###.#.<br>.#.#..@#.#.<br>.#.#####.#.<br>.#…….#.<br>.#########.<br>………..<br>11 6<br>..#..#..#..<br>..#..#..#..<br>..#..#..###<br>..#..#..#@.<br>..#..#..#..<br>..#..#..#..<br>7 7<br>..#.#..<br>..#.#..<br>###.###<br>…@…<br>###.###<br>..#.#..<br>..#.#..<br>0 0<br>Sample Output：</p><p>45<br>59<br>6<br>13</p><p>Source：</p><p>Japan 2004 Domestic</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">//  main.cpp</span><br><span class="hljs-comment">//  PekingOJ</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  Created by leo on 2019/10/18.</span><br><span class="hljs-comment">//  Copyright © 2019 leo. All rights reserved.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>queue&lt;<span class="hljs-keyword">int</span>&gt; qq;<br><br><span class="hljs-keyword">int</span> countt;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;      <span class="hljs-comment">//a和b数组定义了上下左右“走”的规则 课上老师讲了道例题是象棋马的搜索，只要修改这两个数组即可</span><br><span class="hljs-keyword">int</span> b[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">char</span> map[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];           <span class="hljs-comment">//最大是一个20*w20的盘子</span><br><span class="hljs-keyword">bool</span> mp[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];            <span class="hljs-comment">//防止状态重复</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">in</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n)</span>    <span class="hljs-comment">//判断是否有越界</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">return</span> (a&gt;=<span class="hljs-number">0</span>&amp;&amp;a&lt;=n<span class="hljs-number">-1</span>&amp;&amp;b&gt;=<span class="hljs-number">0</span>&amp;&amp;b&lt;=m<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n)</span></span>&#123;      <span class="hljs-comment">//广度优先搜索主要就借助队列来实现</span><br>    qq.<span class="hljs-built_in">push</span>(x);<br>    qq.<span class="hljs-built_in">push</span>(y);<br>    <span class="hljs-keyword">int</span> k;<br>    <span class="hljs-keyword">int</span> x_coordinate,y_coordinate;<br>    <span class="hljs-keyword">while</span>(!qq.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        x_coordinate=qq.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-comment">//std::cout&lt;&lt;x_coordinate&lt;&lt;endl;</span><br>        qq.<span class="hljs-built_in">pop</span>();<br>        y_coordinate=qq.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-comment">//std::cout&lt;&lt;y_coordinate&lt;&lt;endl;</span><br>        qq.<span class="hljs-built_in">pop</span>();<br>        countt=countt+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;<br>            <span class="hljs-keyword">if</span>(map[x_coordinate+a[k]][y_coordinate+b[k]]==<span class="hljs-string">&#x27;.&#x27;</span>&amp;&amp;!mp[x_coordinate+a[k]][y_coordinate+b[k]]&amp;&amp;<span class="hljs-built_in">in</span>(x_coordinate+a[k],y_coordinate+b[k],m,n))<br>            &#123;<br>                mp[x_coordinate+a[k]][y_coordinate+b[k]]=<span class="hljs-literal">true</span>;<br>                qq.<span class="hljs-built_in">push</span>(x_coordinate+a[k]);<br>                qq.<span class="hljs-built_in">push</span>(y_coordinate+b[k]);<br>            &#125;<br>        &#125;<br>         <br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m,n;<br><br>    <span class="hljs-keyword">int</span> enter_x=<span class="hljs-number">0</span>,enter_y=<span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">while</span>(std::cin&gt;&gt;m&gt;&gt;n)<br>        &#123;<br><br>            countt=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>&amp;&amp;n==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> e=<span class="hljs-number">0</span>;e&lt;n;e++)              <span class="hljs-comment">//初始化用于判重的矩阵</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r=<span class="hljs-number">0</span>;r&lt;m;r++)<br>                    mp[e][r]=<span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>                    std::cin&gt;&gt;map[i][j];<br>                    <span class="hljs-keyword">if</span> (map[i][j]==<span class="hljs-string">&#x27;@&#x27;</span>)&#123;<br>                        enter_x=i;<br>                        enter_y=j;<br>                        mp[i][j]=<span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>    <span class="hljs-comment">//std::cout&lt;&lt;enter_x&lt;&lt;enter_y;</span><br>    <span class="hljs-comment">//std::cout&lt;&lt;map[enter_x][enter_y];</span><br>        <span class="hljs-built_in">bfs</span>(enter_x,enter_y,m,n);<br>        std::cout&lt;&lt;countt&lt;&lt;endl;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>很久没有写算法题了，代码自认为写得就不是很好看，其实中间还有很多可以改变的地方。看过别人写的这道题的代码。不使用单独的判重数组，每次访问到队列中的某个节点后将此节点上的内容改为‘#’，也就没法再次访问了，也是很好的想法。不过我还是倾向去将各个模块分割，重复状态的判断我认为还是在搜索算法里是一个很重要的模块。</p><h3 id="coding期间出现的问题"><a href="#coding期间出现的问题" class="headerlink" title="coding期间出现的问题"></a>coding期间出现的问题</h3><p>忘记初始化判重数组【一开始我也没写bool in函数】，导致在从第二次及以后的瓦片读取后计算可能会出错（遗留下来的map会影响下一张map）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac下如何创建博客</title>
    <link href="/2019/10/16/creatblog/"/>
    <url>/2019/10/16/creatblog/</url>
    
    <content type="html"><![CDATA[<p>拥有了博客，虽然网上有很多很棒的教程了，但我这里想简略记录一下我自己创建博客的操作过程。这篇主要是写给自己看的。</p><span id="more"></span><h2 id="Leo"><a href="#Leo" class="headerlink" title="Leo"></a>Leo</h2><h3 id="我电脑已经装有nvm，可直接用nvm安装node的稳定版本"><a href="#我电脑已经装有nvm，可直接用nvm安装node的稳定版本" class="headerlink" title="我电脑已经装有nvm，可直接用nvm安装node的稳定版本"></a>我电脑已经装有nvm，可直接用nvm安装node的稳定版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ nvm install 12.5.0<br></code></pre></td></tr></table></figure><h3 id="安装hexo，并部署到git-page的deployer"><a href="#安装hexo，并部署到git-page的deployer" class="headerlink" title="安装hexo，并部署到git page的deployer"></a>安装hexo，并部署到git page的deployer</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> hexo-cli -g <br>$ npm <span class="hljs-keyword">install</span> hexo-deployer-git --save<br></code></pre></td></tr></table></figure><h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init iblog<br></code></pre></td></tr></table></figure><p>这里我因为网络原因经常卡住，导致创造了很多遍iblog文件，这里会出现一个问题，在自动安装dependecies时报出npm ERR! cb() never called!的错误<br>这里需要清除你的npm缓存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo npm cache clean -f<br></code></pre></td></tr></table></figure><p>很有意思，会得到一个提醒 “希望你知道你在做什么”<br>之后到网络好的地方安装就完成了</p><h3 id="创建github-io仓库并配置SSH密码"><a href="#创建github-io仓库并配置SSH密码" class="headerlink" title="创建github.io仓库并配置SSH密码"></a>创建github.io仓库并配置SSH密码</h3><p>我很早就创建好了，注意仓库名必须为 userName.github.io，我的用户名是LeoMarsX，即LeoMarsX.github.io<br>查看是否有SSH密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -al ~/.ssh<br>$ No such file or directory<br></code></pre></td></tr></table></figure><p>生成SSH密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C<span class="hljs-string">&quot;your_email&quot;</span><br>//your_email:这是github注册时填的邮箱<br></code></pre></td></tr></table></figure><p>添加SSH</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-add ~/.ssh/id_rsa <br></code></pre></td></tr></table></figure><p>查看SSH</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ cat /Users/UserName/.ssh/id_rsa.pub<br>//UserName :电脑用户名<br></code></pre></td></tr></table></figure><p>然后将查看到的SSH复制到github中    （先Edit profile，然后点击New SSH key）<br><img src="/picture/test1.png" alt="点击New SSH key"></p><p>测试看是否测试成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh -T git@github.com<br>Hi XXXX You<span class="hljs-string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></code></pre></td></tr></table></figure><h3 id="将本地的Hexo文件更新到GitHub仓库中"><a href="#将本地的Hexo文件更新到GitHub仓库中" class="headerlink" title="将本地的Hexo文件更新到GitHub仓库中"></a>将本地的Hexo文件更新到GitHub仓库中</h3><p>到iblog这个根目录打开_config.ymlb配置文件，拉到最下面更改配置信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy:<br><span class="hljs-built_in">type</span>: git<br>repo: https://github.com/userName/userName.github.io.git<br>branch: master<br></code></pre></td></tr></table></figure><p>注意 这里的所有冒号之后一定都要有一个空格</p><h3 id="快成功啦！"><a href="#快成功啦！" class="headerlink" title="快成功啦！"></a>快成功啦！</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g  //generation生成<br>$ hexo d  //deploy配置<br>//如果这时候报错了,执行下面这行代码，再重新输入hexo d<br>$ npm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><p>就可以登陆访问网站啦</p><h2 id="怎么写博客呢"><a href="#怎么写博客呢" class="headerlink" title="怎么写博客呢"></a>怎么写博客呢</h2><p>打开创建的iblog文件夹，其中的source/_posts文件里的markdown文件就是刚刚打开的hexo默认的第一篇文章的文件代码，自己进行修改内容就可以写自己的文章啦。直接新建一个md文件就可以新建一篇文章了。</p><h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>在github里搜索 hexo themes即可看到很多优秀的前端工程师做的主题，根据他们提供的指南进行安装就可以让自己的博客更好看了！</p>]]></content>
    
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇博客</title>
    <link href="/2019/10/15/hello-world/"/>
    <url>/2019/10/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>终于有了自己的一个博客啦！折腾了一个下午吧，后面整理一下把搭建这个博客的教程，遇到的问题整理下来。</p><span id="more"></span><h2 id="Leo"><a href="#Leo" class="headerlink" title="Leo"></a>Leo</h2><h3 id="Really-Exicted"><a href="#Really-Exicted" class="headerlink" title="Really Exicted."></a>Really Exicted.</h3><figure class="highlight css"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs css">Gonna <span class="hljs-selector-tag">to</span> be <span class="hljs-selector-tag">a</span> great person.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
