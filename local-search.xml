<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CMU15-445课程知识点复习 &amp; 总结</title>
    <link href="/2022/01/26/CMU15-445%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/01/26/CMU15-445%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>本文将进行CMU15-445的知识点巩固与复习。</p><p>复习点参考<code>博主：西部小笼包</code>的整理，我进行了参考并加入了一点自己的见解。</p><a id="more"></a>    <h2 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h2><h5 id="1-为什么需要数据库系统？文件系统不够吗？"><a href="#1-为什么需要数据库系统？文件系统不够吗？" class="headerlink" title="1. 为什么需要数据库系统？文件系统不够吗？"></a>1. 为什么需要数据库系统？文件系统不够吗？</h5><p>首先是更好得解耦，对所需存储的数据的建模（不同场景不同模型）这些逻辑可与物理存储层分离。并且类似查询检查保证数据一致性的逻辑也可以与业务代码分离。</p><p>其次磁盘IO是比较昂贵的，相较于基于操作系统mmap等机制对于内存磁盘的交互，数据库系统拥有更多的信息去更好地决定何时将内存页刷入磁盘。数据库会有一个Buffer Pool Manager组件进行管理，制定专属的淘汰策略。</p><h5 id="2-数据库底层是如何存储的？"><a href="#2-数据库底层是如何存储的？" class="headerlink" title="2. 数据库底层是如何存储的？"></a>2. 数据库底层是如何存储的？</h5><p>数据库的存储为了移植性一般基于文件系统。DBMS 通常将自己的所有数据作为一个或多个文件存储在磁盘中，而 OS 只当它们是普通文件，并不知道如何解读这些文件。</p><p>数据库会按照Page为存储单位进行存储（类似文件系统Block的概念）。每个 Page 带着一个唯一的 id。数据库会用一个间接层做通过PageID &lt;—&gt; 物理实际地址的映射。</p><p>数据库会有一个storage manager模块负责读写磁盘上的对应Page，同时保持较好的空间和时间的局部性。数据文件在底层会有不同的组织形式，比较常见的是无序的HEAP FILE， 或者是有序的聚集索引（B树），还有一种是HASH FILE。</p><h5 id="3-HEAP-FILE-内部是怎么组织变成一个数据库的？"><a href="#3-HEAP-FILE-内部是怎么组织变成一个数据库的？" class="headerlink" title="3.HEAP FILE 内部是怎么组织变成一个数据库的？"></a>3.HEAP FILE 内部是怎么组织变成一个数据库的？</h5><p>这里不讨论链表的方式，主要讨论页目录（Page Directory）的方式。</p><p>这种方式会有一些页目录会记录全部数据文件的位置，同时也记录了每一个页的FREE SLOT数量（即使用情况）。</p><p>具体数据页的存储有两种方式，一种记录数据本身采用Slotted Page（下左图），另一种记录操作数据的日志（定期会压缩日志）。</p><table><thead><tr><th align="center"><img src="/picture/Database/slotted_page.png" srcset="/img/loading.gif" lazyload style="zoom:20%;"></th><th align="center"><img src="/picture/Database/log_structed_page.png" srcset="/img/loading.gif" lazyload style="zoom:20%;"></th></tr></thead></table><p>对于Slotted Page，每一个TUPLE 在DBMS里会即会有以page_id + offset/slot的二元组唯一定位。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h5 id="4-Hash表主要关注什么？静态、动态HASH算法有哪些区别是什么？"><a href="#4-Hash表主要关注什么？静态、动态HASH算法有哪些区别是什么？" class="headerlink" title="4.Hash表主要关注什么？静态、动态HASH算法有哪些区别是什么？"></a>4.Hash表主要关注什么？静态、动态HASH算法有哪些区别是什么？</h5><p>Hash 函数的选择，就是在性能和冲突率之间的TRADE OFF。另外就是冲突之后的策略选择。其实是在开一个更大的表和找到其他地方去插KEY的TRADE OFF。</p><p>静态Hash算法（要求事先知道存多少元素，否则就需要在一定时间对整个表做扩容和缩容然后rehash）：</p><ol><li>线性扫描</li><li>Robin（目的是让每次扫描次数差不多）</li><li>Cuckoo（两张表）</li></ol><p>动态扩容的Hash算法：</p><ol><li>Chained Hash （桶满了加桶）</li><li>Extenible Hash（桶满了后增加hash匹配位数，变相增加桶数）</li><li>Linear Hash（维护一个指针指向下一个被拆分的桶）</li></ol><table><thead><tr><th><img src="/picture/Database/chained_hash.png" srcset="/img/loading.gif" lazyload style="zoom:20%;"></th><th><img src="/picture/Database/extenible_hash.png" srcset="/img/loading.gif" lazyload style="zoom:20%;"></th><th><img src="/picture/Database/linear_hash.png" srcset="/img/loading.gif" lazyload style="zoom:20%;"></th></tr></thead></table><h5 id="5-B-树有哪些性质？"><a href="#5-B-树有哪些性质？" class="headerlink" title="5. B+树有哪些性质？"></a>5. B+树有哪些性质？</h5><ol><li>他是完美平衡的，所有叶子节点的深度一致。</li><li>每个非根节点至少是半满的。（如果最多有M个孩子，那么至少会有[M / 2 - 1, M - 1]个key ）</li><li>每个内部节点有K个KEY，就会有K + 1个孩子。</li></ol><h5 id="6-B-树的设计策略：B树节点的SIZE如何选择？合并阈值？"><a href="#6-B-树的设计策略：B树节点的SIZE如何选择？合并阈值？" class="headerlink" title="6. B+树的设计策略：B树节点的SIZE如何选择？合并阈值？"></a>6. B+树的设计策略：B树节点的SIZE如何选择？合并阈值？</h5><p>一般存储设备IO开销越大，速度越慢，节点就需要越大。具体情境下的最优大小由 workload 决定。</p><p>对于节点的合并有些 DBMS 选择延迟 merge 操作的发生时间，甚至可以利用其它进程来负责周期性地重建 table index。</p><h5 id="7-B-树有哪些常见优化？"><a href="#7-B-树有哪些常见优化？" class="headerlink" title="7. B+树有哪些常见优化？"></a>7. B+树有哪些常见优化？</h5><p>1． 前缀压缩，如果这个节点的STRING 都是以ABC，开头，可以把这个ABC提出来，这样之后的信息都会少，就能存更多。</p><p>2． 后缀截断【较常用】。如果后缀的信息没有区分度，则在中间节点的时候可以砍掉。</p><p>3． 指针调整，如果一个PAGE已经再BUFFER POOL 里PINNED了，我们可以存直接的指针来代替原来存的PAGE ID。来避免去PAGE TABLE 查ADDRESS。</p><p>4． 批量插入【常用】。如果一开始你就知道要插的所有KEY，可以对他们先排序，然后对这些KEY去构建INDEX BOTTOM UP。这样性能最好。</p><h5 id="8-什么是隐式索引，局部索引，覆盖索引，包含索引-index-include-column-？"><a href="#8-什么是隐式索引，局部索引，覆盖索引，包含索引-index-include-column-？" class="headerlink" title="8. 什么是隐式索引，局部索引，覆盖索引，包含索引(index include column)？"></a>8. 什么是隐式索引，局部索引，覆盖索引，包含索引(index include column)？</h5><blockquote><p>Todo…</p></blockquote><h5 id="9-什么是Latch-Crabbing，此方法是如何加锁索引的？"><a href="#9-什么是Latch-Crabbing，此方法是如何加锁索引的？" class="headerlink" title="9. 什么是Latch Crabbing，此方法是如何加锁索引的？"></a>9. 什么是Latch Crabbing，此方法是如何加锁索引的？</h5><p>首先拿父PAGE的LATCH， 然后拿孩子的LATCH。如果父节点是SAFE（不会引起分裂、合并操作）的则释放父PAGE的LATCH。</p><p>查的时候，拿到孩子的读锁就可以释放父亲的读锁。</p><p>删增的时候，拿写锁，如果某一个孩子是SAFE的，可以释放祖先持有的全部锁</p><p>其余一个优化是可以先假设叶子节点是安全的，在一开始可以只上读锁。如果发现这个假设是错的，再重头来一遍写锁。</p><p>如果要同时支持LEFT-&gt;RIGHT， TOP-&gt;BOTTM <strong>两个方向</strong>的节点查找，当发现锁被占有了，最好的方式是等一小会然后杀掉自己，重头开始。</p><p>另一个优化是把PARENT节点的更新延迟到下次获取写锁的时候再更新（通过一个全局变量记录需要更新的节点）。</p><h2 id="排序、聚合和Join"><a href="#排序、聚合和Join" class="headerlink" title="排序、聚合和Join"></a>排序、聚合和Join</h2><h5 id="10-如果有108个页，内存只能容下5页，如何做硬盘外排序？"><a href="#10-如果有108个页，内存只能容下5页，如何做硬盘外排序？" class="headerlink" title="10. 如果有108个页，内存只能容下5页，如何做硬盘外排序？"></a>10. 如果有108个页，内存只能容下5页，如何做硬盘外排序？</h5><p>首先每次放进内存5个页，对5个页排序，写到磁盘的一个文件里。这样最后会有22个文件。</p><p>下一次开始做K路归并，把4个文件放进去BUFFER里，然后流式读文件。还余下的一个文件的位置是用来当PQ，每次输出一个最小的写进磁盘。这样搞完之后。就还有22/4 = 6个文件。</p><p>下一步同样，变成2个文件。最后合到一个有序文件。</p><img src="/picture/Database/2-way.png" srcset="/img/loading.gif" lazyload style="zoom:20%;"><h5 id="11-GROUP-BY-、DISTINCT-应该怎么做？"><a href="#11-GROUP-BY-、DISTINCT-应该怎么做？" class="headerlink" title="11. GROUP BY 、DISTINCT 应该怎么做？"></a>11. GROUP BY 、DISTINCT 应该怎么做？</h5><p>一般有两种聚合方法，一种是Sorting Aggregation，另一种是Hashing Aggregation。</p><p>当然排序聚合需要做一遍</p><h5 id="12-Join如何做？"><a href="#12-Join如何做？" class="headerlink" title="12. Join如何做？"></a>12. Join如何做？</h5><blockquote><p>Todo…</p></blockquote><h2 id="CMU15-445课程总结"><a href="#CMU15-445课程总结" class="headerlink" title="CMU15-445课程总结"></a>CMU15-445课程总结</h2>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫踩坑</title>
    <link href="/2022/01/23/%E7%88%AC%E8%99%AB%E8%B8%A9%E5%9D%91/"/>
    <url>/2022/01/23/%E7%88%AC%E8%99%AB%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>本篇博客主要记录一点自己做某汽车平台二手车报价爬取的一些小坑。</p><a id="more"></a><blockquote><p>request.get可能返回空值或是错误值。</p></blockquote><p>   基本可以这样处理：</p><p>   while 1:</p><p>​       抓！</p><p>   ​    if 抓取为空或者错误值:</p><p>   ​        sleep + continue</p><blockquote><p>频繁访问可能会返回要验证的页面。</p></blockquote><p>   简单的做法就是sleep</p><p>   复杂点可以找一些免费的高匿级别的代理IP，然后每次爬取的时候轮询即可。</p><blockquote><p>request返回时并没有返回动态加载的页面。</p></blockquote><p>   直接找对应的动态加载的页面取请求内容</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP Malloc Lab &amp; Shell Lab</title>
    <link href="/2021/10/20/CSAPP%E9%83%A8%E5%88%86Lab%E6%80%BB%E7%BB%93/"/>
    <url>/2021/10/20/CSAPP%E9%83%A8%E5%88%86Lab%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.S081 backtrace &amp; Alarm &amp; Lazy...</title>
    <link href="/2021/10/20/MIT6.S081%E9%83%A8%E5%88%86Lab%E6%80%BB%E7%BB%93/"/>
    <url>/2021/10/20/MIT6.S081%E9%83%A8%E5%88%86Lab%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统进程管理</title>
    <link href="/2021/08/13/OS%E8%BF%9B%E7%A8%8B/"/>
    <url>/2021/08/13/OS%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p><strong>目录</strong></p><ol><li>进程地址空间</li><li>进程切换</li><li>进程调度<a id="more"></a>了解进程管理，首先就要了解什么进程，为什么会有进程这个概念。（<strong>计算机领域产生的概念/技术大多要从其解决的问题出发进行研究</strong>）<br>在计算机刚诞生的时候，我们利用CPU运行程序这个静态资源，反复做计算的任务，这时还用不到进程。慢慢得随着计算能力的提升，一台计算机在处理复杂任务时可能需要“同时”执行不同的程序，这时，如果没有一个描述程序运行时状态的结构，难以去切换不同程序的执行（无法保存运行状态），进程便因此诞生了。<h2 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h2>了解了进程的基本概念和诞生初衷，就知道进程是一个应用程序运行时刻的实例，它的目的就是操作系统用于管理和运行多个应用程序的；从之前我们研究的内存管理角度看，操作系统是给应用程序提供服务的。所以，从这两个角度看，进程必须要有一个地址空间，这个地址空间至少包括两部分内容：一部分是内核，一部分是用户的应用程序。<br><img src="/picture/OS/2-1.jpg" srcset="/img/loading.gif" lazyload alt="进程地址结构"><br>上图中有 8 个进程，每个进程拥有 x86 CPU 的整个虚拟地址空间，这个虚拟地址空间被分成了两个部分，上半部分是所有进程都共享的内核部分 ，里面放着一份内核代码和数据，下半部分是应用程序，分别独立，互不干扰。<strong>其实所谓的用户态和内核态切换就要将用户页表切换为内核页表，从而运行内核代码</strong><br>细化的整个进程地址空间则由下图所示。<br><img src="/picture/OS/2-2.jpg" srcset="/img/loading.gif" lazyload alt="进程地址结构细化示意图"><br>这里带 * 号是每个进程都有独立一份，有了这样的设计结构，多个进程就能并发运行了。</li></ol><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>还记得上一部分在进程地址空间中的机器上下文结构嘛，这个部分会保存该进程下一次运行的开始地址与下一次运行时的内核栈地址。内核栈会保存各个CPU寄存器的值，当然也保存了内核函数的调用路径。在切换回原进程时，便会将原本保存在内核栈中的CPU数据pop弹出。<br>进程切换时只用两部即可完成1.保存进程的上下文结构，2.通过修改CR3页表地址切换资源（进程的虚拟地址空间）<br><img src="/picture/OS/2-3.jpg" srcset="/img/loading.gif" lazyload alt="进程切换示意图"><br><strong>总结一下</strong>切换方式：首先，我们把当前进程的通用寄存器保存到当前进程的内核栈中；然后，保存 CPU 的 RSP 寄存器到当前进程的机器上下文结构中，并且读取保存在下一个进程机器上下文结构中的 RSP 的值，把它存到 CPU 的 RSP 寄存器中；接着，调用一个函数切换 MMU 页表；最后，从下一个进程的内核栈中恢复下一个进程的通用寄存器。</p><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>进程调度算法的设计是决定性能的一个关键。进程调度算法种类也非常多，这里不会详细介绍各个算法的优劣，主要介绍进程调度的机制。<br>首先<strong>为什么需要进程调度？</strong><br>第一，CPU 同一时刻只能运行一个进程，而 CPU 个数总是比进程个数少，这就需要让多进程共用一个 CPU，每个进程在这个 CPU 上运行一段时间。第二点原因，当一个进程不能获取某种资源，导致它不能继续运行时，就应该让出 CPU。当然你也可以把第一点中的 CPU 时间，也归纳为一种资源，这样就合并为一点：进程拿不到资源就要让出 CPU。<br>管理进程、调度进程就需要知道进程有哪些状态，从而组织进程。<br> <img src="/picture/OS/2-4.jpg" srcset="/img/loading.gif" lazyload alt="进程状态切换示意图"><br> 其次如何组织进程？最简单的办法就是使用链表数据结构，而且我们的进程有优先级，所以我们可以设计成每个优先级对应一个链表头。<br> 然后就是进程调度器，主要思路就是确定当前正在运行的进程，然后选择下一个将要运行的进程（通过相应的调度算法选取进程，例如根据各个进程的优先级或等待时间），最后从当前运行的进程，切换到下一个将要运行的进程。<br> 根据这个思路我们就发现，内核的进程调度器需要有主动权才能实现其功能，但进程自己一般不会主动让出CPU（除非要等待资源)，那么<strong>如何让进程调度器得到控制权呢？</strong> 其实我们的机器会有一个设备去定时发送中断信号，此时控制权就从进程转交给了内核，内核根据相应算法计算出下一个要调用的进程进行进程切换即可。本文不准备讨论相应算法，Linux支持多种调度器：CFS、RT、Dealine、Idle等，有机会单独讲解调度器算法。</p><h4 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h4><p><a href="https://time.geekbang.org/column/intro/100078401" target="_blank" rel="noopener">极客时间LMOS操作系统</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统内存管理</title>
    <link href="/2021/08/07/OS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2021/08/07/OS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>自实习结束已有近9个月没有更新博客了，这段时间主要在进行毕业设计和毕业旅行噗，毕设做的微服务相关内容暂时不准备整理至博客上。暑假主要稳固基础知识（计算机组成原理、操作系统、计算机网络、数据库原理），弥补本科的缺陷。接下来会更新关于操作系统内存、进程、设备IO、文件系统的内容分享。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><strong>目录</strong></p><ol><li>物理地址与虚拟地址</li><li>内存分段与分页管理</li><li>内存组织、分配与释放</li><li>小块内存的管理</li><li>虚拟内存技术</li><li>垃圾收集<a id="more"></a><h2 id="物理地址与虚拟地址"><a href="#物理地址与虚拟地址" class="headerlink" title="物理地址与虚拟地址"></a>物理地址与虚拟地址</h2>在CPU实模式下（16位），程序对于内存的访问直接使用物理地址。随着地址线增多，程序并发要求变高，程序与程序之间地址冲突的各种问题就急需解决了。我们给每个程序一样的虚拟地址空间，通过翻译单元（硬件MMU）将虚拟地址翻译成物理地址。</li></ol><p><strong>那么如何设计这个映射关系表呢</strong>但是如果通过一一映射的地址翻译表。在32 位地址空间下，4GB 虚拟地址的地址关系转换表就会把整个 32 位物理地址空间用完，这显然不行。要是结合前面的保护模式下分段方式呢，地址关系转换表中存放：一个虚拟段基址对应一个物理段基址，这样看似可以，但是因为段长度各不相同，所以依然不可取。综合刚才的分析，系统设计者最后采用一个折中的方案，即把虚拟地址空间和物理地址空间都分成同等大小的块，也称为页，按照虚拟页和物理页进行转换。根据软件配置不同，这个页的大小可以设置为 4KB、2MB、4MB、1GB，这样就进入了现代内存管理模式——分页模型。<br><img src="/picture/OS/1.jpg" srcset="/img/loading.gif" lazyload alt="分页模型"><br>一直存在内存中的地址关系转换表也就是我们熟悉的页表，其基地址放置在CR3寄存器当中，所以当程序切换（进程切换时）也要修改CR3寄存器的值。最后，当CPU接受到虚拟地址时，将虚拟地址与页表首地址传入MMU即可返回真正的物理地址。</p><h2 id="内存分段与分页管理"><a href="#内存分段与分页管理" class="headerlink" title="内存分段与分页管理"></a>内存分段与分页管理</h2><p>前文已经讨论了一部分选择分段还是分页管理内存的问题，但还不足够。（我认为，分页是真正起效的内存管理模式，分段只是逻辑上的划分起到的作用极小甚至没有）。为何这么说，那得从分段的历史说起，分段最开始是从Intel的8086CPU，受限于价格和技术水平，当时的CPU和寄存器的宽度仍然为16位。那时还是直接访问物理地址的，为了便利地实现多道程序并发运行，也就需要支持对各个程序进行重定位，因为如果不支持重定位，凡是涉及到内存访问的地方都需要将地址硬编码，进而必须把某个程序加载到内存的固定区间。有了分段机制，程序中只需要使用基于段的相对地址，然后更改段基址，就可以方便地对程序进行重定位。当然，在8086CPU中，分段除了服务于重定位的目的，还有其他的作用。具体地说，8086CPU的地址线宽度是20位，可寻址的最大内存空间是1MB，但寄存器这些都是16位， 它是通过段加偏移的方式生成20位的地址，从而实现对1MB内存空间的寻址的。我们经常谈的程序可执行文件的分段，例如代码段数据段这些，在最开始其实就是为了跟上面描述的硬件上的内存分段机制对应，并且逻辑上能够更清晰有序地构造程序的组织结构。<br>但是分段管理从表示方式和状态确定角度、内存碎片、内存和硬盘的数据交换效率（段长度不同，很可能导致系统性能抖动）考虑来看均有很大的缺点，当然段最大的问题还是<strong>使得虚拟内存难以实施</strong>。虚拟内存会在之后的段落详细描述。<br>目前Linux的分段更多的是一种历史包袱，而不是能够提供多大实际作用的内存管理机制。</p><h4 id="分页管理下的MMU页表原理"><a href="#分页管理下的MMU页表原理" class="headerlink" title="分页管理下的MMU页表原理"></a>分页管理下的MMU页表原理</h4><p><img src="/picture/OS/2.jpg" srcset="/img/loading.gif" lazyload alt="虚拟地址翻译过程"><br>从上面可以看出，一个虚拟地址被分成从左至右四个位段。第一个位段索引顶级页目录中一个项，该项指向一个中级页目录，然后用第二个位段去索引中级页目录中的一个项，该项指向一个页目录，再用第三个位段去索引页目录中的项，该项指向一个物理页地址，最后用第四个位段作该物理页内的偏移去访问物理内存。这就是 MMU 的工作流程。<br><strong>为什么要分成这么多级的页表呢？</strong> 主要为了节省内存，页表也是需要占用空间的，一级页表是必须放在主存之中的，但页表分级之后二级页表便可以存储在磁盘之中，不用占用内存空间。同时，如果一级页表的某些页项为空，则对应的二级页表也无需进行创建。</p><h2 id="内存组织、分配与释放"><a href="#内存组织、分配与释放" class="headerlink" title="内存组织、分配与释放"></a>内存组织、分配与释放</h2><p>这部分将详细介绍与设计一个实际的分页内存管理。此部分参考LMOS操作系统课程。<br>首先要想好页的数据结构需要包含哪些信息：页的状态、页的地址、页的分配记数，页的类型、页的链表。其中链表是方便挂入其他组织页面的数据结构之中所用。<br><img src="/picture/OS/3.jpg" srcset="/img/loading.gif" lazyload alt="页面组织"><br>dm_mdmlielst 数组挂载连续 msadsc_t 结构的数量等于用 1 左移其数组下标，如数组下标为 3，那结果就是 8（1&lt;&lt;3）个连续的 msadsc_t 结构。因此页面数统统都是 2 的倍数，这样就能实现页内存对齐，减少内存分配时的碎片。同时，2的倍数意味着可以用位操作进行相应计算工作，这比乘法操作要节省较多的CPU时钟。<br>根据这个页面的组织结构，即可设计出相应的页面分配算法。<br><img src="/picture/OS/4.jpg" srcset="/img/loading.gif" lazyload alt="页面分配"><br>假设现在需要分配一个页面。</p><ol><li>根据一个页面的请求，会返回 m_mdmlielst 数组中的第 0 个 bafhlst_t 结构。</li><li>如果第 0 个 bafhlst_t 结构中有 msadsc_t 结构就直接返回，若没有 msadsc_t 结构，就会继续查找 m_mdmlielst 数组中的第 1 个 bafhlst_t 结构。</li><li>如果第 1 个 bafhlst_t 结构中也没有 msadsc_t 结构，就会继续查找 m_mdmlielst 数组中的第 2 个 bafhlst_t 结构。</li><li>如果第 2 个 bafhlst_t 结构中有 msadsc_t 结构，记住第 2 个 bafhlst_t 结构中对应是 4 个连续的 msadsc_t 结构。这时让这 4 个连续的 msadsc_t 结构从第 2 个 bafhlst_t 结构中脱离。</li><li>把这 4 个连续的 msadsc_t 结构，对半分割成 2 个双 msadsc_t 结构，把其中一个双 msadsc_t 结构挂载到第 1 个 bafhlst_t 结构中。</li><li>把剩下一个双 msadsc_t 结构，继续对半分割成两个单 msadsc_t 结构，把其中一个单 msadsc_t 结构挂载到第 0 个 bafhlst_t 结构中，剩下一个单 msadsc_t 结构返回给请求者，完成内存分配。<br>页面释放算法即是分配的逆算法，这里就不再阐述了。</li></ol><h2 id="小块内存的管理"><a href="#小块内存的管理" class="headerlink" title="小块内存的管理"></a>小块内存的管理</h2><p>内存是非常宝贵的，如果程序申请的内存远远小于一个页面的大小，此时该如何分配内存呢？<br>这部分直接介绍Linux的Slab分配器，我们来看看Linux是如何解决这个问题的。<br><img src="/picture/OS/5.jpg" srcset="/img/loading.gif" lazyload alt="SLAB对象分配示意图"><br>在 SLAB 分配器中，它把一个内存页面或者一组连续的内存页面，划分成大小相同的块，其中这一个小的内存块就是 SLAB 对象，但是这一组连续的内存页面中不只是 SLAB 对象，还有 SLAB 管理头和着色区。这个着色区也是一块动态的内存块，建立 SLAB 时才会设置它的大小，目的是为了错开不同 SLAB 中的对象地址，降低硬件 Cache 行中的地址争用，以免导致 Cache 抖动效应，整个系统性能下降。<br>最后提及一下Slab对象的大小：Slab分配最小位32B，最大分配单元依赖体系架构。</p><h2 id="虚拟内存技术"><a href="#虚拟内存技术" class="headerlink" title="虚拟内存技术"></a>虚拟内存技术</h2><p>一个英语往往拥有很大的连续地址空间，并且每个应用都是一样的，只有在运行时才能分配到真正的物理内存，在操作系统中这称为虚拟内存。<br>虚拟地址就是逻辑上的一个数值，而虚拟地址空间就是一堆数值的集合。通常情况下，32 位的处理器有 0～0xFFFFFFFF 的虚拟地址空间，而 64 位的虚拟地址空间则更大，有 0～0xFFFFFFFFFFFFFFFF 的虚拟地址空间。<br>虚拟地址空间某种角度也可以称为进程地址空间，关于进程地址空间的描述将留到下一篇操作系统进程中详解。<br>对于虚拟内存技术，便会存在页面存在内存之中与页面存在磁盘之中的区别。虚拟地址传入CPU后查询页表的过程中自然也就存在页命中与页丢失两种情况。下图展示了页命中的情况，图摘自CSAPP。<br><img src="/picture/OS/6.jpg" srcset="/img/loading.gif" lazyload alt="页命中"><br>如果页缺失，则将调用内核中的缺页异常处理程序，该程序会选择一个牺牲页将其复制回磁盘（这里也涉及很多调换算法，常见的有LRU算法等），接下来将缺失的页面换到内存中。当异常处理程序返回时，CPU会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重新发送到地址翻译硬件。此时就能页命中了。<br>或许到此就会产生一个感觉，虚拟内存技术效率有点低，因为不命中的惩罚很大，我们担心页面调度会破坏程序性能。实际上，虚拟内存工作得相当得好，这主要归功于<strong>局部性</strong>，关于局部性就不多说啦。</p><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>垃圾收集器将内存视为一张有向可达图，其中具有两种节点：</p><ol><li>根节点（Root Node）：对应于不在堆中但包含指向堆中的指针，可以是寄存器、栈中变量或全局变量等等。</li><li>堆节点（Heap Node）：对应于堆中的一个已分配的块。<br><img src="/picture/OS/7.jpg" srcset="/img/loading.gif" lazyload alt="垃圾收集器"><br>对于像ML和Java语言，其对指针创建和使用有严格的要求，由此来构建十分精确的可达图，所以能回收所有垃圾。而对于像C和C++这样的语言，垃圾收集器无法维护十分精确的可达图，只能正确地标记所有可达节点，而有一些不可达节点会被错误地标记为可达的，所以会遗留部分垃圾，这种垃圾收集器称为保守的垃圾收集器。<br>下面介绍具体的垃圾收集流程。<strong>Mark&amp;Sweep垃圾收集器</strong>由标记阶段与清除阶段组成，标记阶段标记出根节点的所有可达和以分配的后继，而后面的清除阶段释放每个未被标记的已分配块。块头部中空闲的低位中的一位通常用来表示这个块是否被标记了。<br>标记阶段为每个根节点都调用一次mark函数，首先会判断输入p是否为指针，如果是则返回p指向的堆节点b，然后判断b是否被标记，如果没有，则对其进行标记，并返回b中不包含头部的以字为单位的长度，这样就能依次遍历b中每个字是否指向其他堆节点，再递归地进行标记。这是对图进行DFS。<br>清除阶段会调用一次sweep函数，它会在所有堆节点上反复循环，如果堆节点b是已标记的，则消除它的标记，如果是未标记的已分配堆节点，则将其释放，然后指向b的后继节点。<br><img src="/picture/OS/8.jpg" srcset="/img/loading.gif" lazyload alt="Mark&amp;Sweep示例"></li></ol><h4 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h4><p><a href="https://time.geekbang.org/column/intro/100078401" target="_blank" rel="noopener">极客时间LMOS操作系统</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XX实习总结</title>
    <link href="/2020/11/01/XX%E5%AE%9E%E4%B9%A0/"/>
    <url>/2020/11/01/XX%E5%AE%9E%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>这个博客主要就记录自己在XX3个月实习的经历。总结一个月一做。<br>9.25 - 12.18</p><h2 id="职位"><a href="#职位" class="headerlink" title="职位"></a>职位</h2><p>算法工程师</p><a id="more"></a><p>——————————————————————————————————————————</p><h2 id="第一个月"><a href="#第一个月" class="headerlink" title="第一个月"></a>第一个月</h2><p>首先非常感谢wc老师、zc、lhs，让我在XX感受到了很不错的同事氛围，真的很温馨很棒。</p><h4 id="两个选择"><a href="#两个选择" class="headerlink" title="两个选择"></a>两个选择</h4><blockquote><p>1.Java开发，负责开发日志聚类后，用户“关注”某些模版后详细展示该模版的信息的功能<br>2.算法设计，负责对日志流l流向Query容器的行为进行动态扩缩容算法设计</p></blockquote><p>其实自己研究生也不是很想做算法，未来还是想做开发岗方向，但基于两个因素，一是自己没有学习过SpringBoot框架，对Kafka、Zookeeper、ES、Redis、etcd都不太了解，而且，自己身处XXX，部署环境在云端，k8s、容器等知识也都不是很会，实在是压力有点大。 二是自己的导师是做AI算法的，感觉可以学到更多东西。所以权衡了一下还是选择了偏向算法的岗位。</p><p>在这里就真的觉得自己运气不错，别的实习生可能会面临调岗，但我自己竟然可以有选择的余地，真的很棒。</p><h4 id="开始工作"><a href="#开始工作" class="headerlink" title="开始工作"></a>开始工作</h4><p>其实已经到了10.12号，我才确定了自己的方向<br>对于算法的任务，首先就是要对数据有理解，有深刻的理解！我们能拿到什么数据，该怎么分析这些数据，这就是第一步：看懂数据。<br>然后对于数据，尤其在公司里，一定会和其他同事有所沟通交流，为了让别的同事能理解我们所做的工作，我们需要一个demo去展示。 <strong>其实数据可视化展示也可以帮助我们自己更好得理解数据！可视化其实也是一个很有深度的研究领域。</strong><br>最后可以不断对自己的算法进行优化，这种优化会在demo中有所体现。<br>对于我的这个项目，可以比较轻松的从普罗米修斯上获取到现网监控数据，所以不用担心数据的问题。<br>对于算法而言，参照一些论文，Google对于类似问题采用的是<strong>贪心算法</strong>，其实也达到了一个不错的效果，所以我们的想法就是MVP（最小可行性产品）就想采用贪心算法。<br>对于可视化，我才用python Flask+pyecharts绘制，确实都是从头学起，不过flask非常简单，主要要学习的其实是Javascript的DOM还有Jquery框架的使用。</p><p>————————————————————————————————————————————</p><blockquote><p>获取数据+数据预处理</p></blockquote><p>写爬虫，爬普罗的数据，其实出现很多问题。AOM限流，难以爬取，暂时沟通还没得到解决方案。</p><p>其实数据结构的设计，我们到底要存储什么样的数据，怎样存储感觉是非常有学问的。但其实自己真的理解不深刻，也不知道自己写的好不好… 这点是很难受的<br>例如路由表的存储结构<br>一开始我准备像快照一样存储，就分为routing_table和operation_table，定期生成一个完整的routing_table。但导师说这样我得单独开一个线程来做这个工作，消耗太大。最后就采取了单表存储流的所有路由信息。查询时只要挑选各个流距离查询时间最近的那条路由信息即可获得路由表。但其实这样的结构我也不知道未来放入ES中好不好查询，或许未来还得改数据结构..</p><blockquote><p>数据分析</p></blockquote><p>以往路由的变更点、异常点分析<br>日志流流量分布<br>Topic流量分布</p><p>其实自己不是很喜欢做这个，做得有点难受</p><blockquote><p>UI（这个伴随着整个项目的生命周期，各个阶段都有相应的可视化展示）<br>做UI前，要思考，要注意展示的点。<br>而此项目，其实就是要注重原来现网的检测数据和自己的算法数据的这种对比感！<br>所以用横向条形图，左侧现网右侧算法，这样对比度更加强烈来进行展示。</p></blockquote><p><strong><em>其实这个月…最后有点懈怠了，很多事情明明知道怎么做好，却没有去做，尤其是数据分析的部分…胶片做的非常烂</em></strong></p><h4 id="和导师的聊天的部分记录"><a href="#和导师的聊天的部分记录" class="headerlink" title="和导师的聊天的部分记录"></a>和导师的聊天的部分记录</h4><ol><li>Python学习路线 Python编程从入门到实践 -&gt; Effective Python/Python Cookbook -&gt; Fluent Python<br>学习了高效的python写法，<strong>一定要去改曾经自己写过的代码</strong>，去实现。不然，习惯是很难改变的，好代码的习惯要好好培养。</li><li>做技术可以2-3年就跳槽，但想做管理不要跳。XX的管理不是别的，一定是<strong>老人</strong>。</li><li>2021年，选择一门语言强化，可以再选择另一门语言做深入</li><li>在XX这样公司,以后就不可能有两周的旅行了，好好去玩玩</li><li>不要说这个方法 <strong>“也行”</strong> 多质疑，真的</li><li>Balsamiq Mockup 画图，做胶片的好帮手～</li><li>外企会对你的职业生涯做规划，告诉你未来给你选择。而在XX3年不知道未来是怎样的。</li><li>刚进入公司，尤其是XX这样的公司 前半年一定要拼命加班！这样有可能会进入升职的“快速通道”</li></ol><p>——————————————————————————————————————————————————————————————第二次编辑</p><h2 id="11-01-12-18"><a href="#11-01-12-18" class="headerlink" title="11.01 - 12.18"></a>11.01 - 12.18</h2><p>为什么提前终止了实习呢…导师在12月初转岗去了另外一个地方，我自然感觉远程指导和面对面还是有相当大的差距。当然公司内部也经历了两次存储架构的改变，自己的心也有些累了。感觉暂时也学不到什么了，做出来的东西没有什么使用价值。于是提前两周结束了实习。</p><h3 id="日志存储出现新的架构"><a href="#日志存储出现新的架构" class="headerlink" title="日志存储出现新的架构"></a>日志存储出现新的架构</h3><h4 id="为何改变架构？"><a href="#为何改变架构？" class="headerlink" title="为何改变架构？"></a>为何改变架构？</h4><ul><li>写入和查询在某种情况下时矛盾的<ul><li>要想查询性能高，要求ES索引足够小（同样的日志流量，索引小意味着索引会变多）</li><li>写入性能高，要求同时写入的索引不能太多</li></ul></li></ul><ul><li>当前索引现状（问题）<ul><li>大量日志流量较小，产生了大量的小流量索引，则服务写入能力上不去（500个索引，总流量不超过2MB/s）</li><li>某个流量巨大，但节点最多处理60MB/m，分裂为多个索引时，查询性能无法保证</li><li>某个流量变动大的时候，没有自动路由（因为我还在做，但实际情况因为拿不到相应数据，并且指标只有size/num，节点的索引数这种指标也无法拿到，这在分析当中是非常受限的），需要人肉运维</li><li>自动路由机制要考虑的因素太多，实现较为复杂（考虑因素：query节点负荷、索引个数、日志流组流量分布情况、query分裂参数等）</li></ul></li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><img src="/picture/sharding.png" srcset="/img/loading.gif" lazyload alt="基本Sharding方案"></p><ul><li>建立stream到shard数据流的动态均衡映射<ul><li>将大象流与老鼠流合并或切分为统一固定流量的shard数据流</li><li>日志流按照租户遍历映射到指定大小的shard中</li><li>实时动态调整shard和日志流的映射关系（流量波动）<ul><li>Move次数少</li><li>超过shard流量阈值的数据流切分到不同节点</li><li>小于shard流量阈值的租户数据在同一个shard内</li><li>…（具体可以用贪心BFD…）</li></ul></li></ul></li><li>利用自动路由算法将shard路由到不同的query消费族（自动路由就变成了一个经典装箱问题）<ul><li>query根据分配到自身的shard数据流建立shard到index的一一映射关系，自身不再做shard分裂，仅做线程间均衡</li></ul></li></ul><p><strong>缺点</strong></p><ul><li>数据非租户级隔离</li><li>未命中场景查询效率会更加劣化（各种租户查询会落在同一个索引，大小租户的查询会互相影响）<ul><li><strong>解决方案</strong><ul><li>标记历史查询条件</li><li>shard流映射时大小租户做区分</li></ul></li></ul></li></ul><p><strong>优点</strong></p><ul><li>写入性能达到最优（因为shard与query映射固定，索引数量控制在一个固定的数值下）</li><li>查询性能可做到基线化</li><li>分配和路由算法更简单</li></ul><h3 id="Sharding-UI"><a href="#Sharding-UI" class="headerlink" title="Sharding UI"></a>Sharding UI</h3><p>这次直接使用echarts画了，其实更加方便了，因为echarts文档更加丰富翔实。</p><p><strong>UI设计目标</strong></p><ul><li>同时体现query流量分布均匀情况与shard流量分布</li></ul><p><strong>UI设计思路</strong></p><ul><li>查看了各个现网region的query数量，基本在20-30+的数量，乘上10也就是200-300+的shard，所以想直接呈现分布情况（除非用华夫饼图，但不够详细）不太可能。</li><li>query和shard存在映射关系，这个关系可以绑定在点击query就显示流向这个query的10个shard的流量分布</li></ul><p><strong>最终实现</strong></p><ul><li>正轴：query流量分布画柱状图（20-30个bar）</li><li>负轴：各个query内的10个shard流量方差</li><li>交互：点击query的bar，可以显示query内10个shard的流量分布柱状图（10个bar）<br>这样可以在一目了然query和shard的分布情况。也不丢失任何数据具体情况。</li></ul><br><h3 id="突然…导师告知要转岗…"><a href="#突然…导师告知要转岗…" class="headerlink" title="突然…导师告知要转岗…"></a>突然…导师告知要转岗…</h3><h4 id="整合demo"><a href="#整合demo" class="headerlink" title="整合demo"></a>整合demo</h4><ul><li>将以前实习生的自动基线的代码（基于Django）整合到我们ilog（基于Flask）里<br>整合其实也是一个重构的过程，在整合中其实就发现，什么样的代码易于整合，什么样的代码几乎要重写。这也是我未来要有所注意，要去研究的。<br>为了做自动基线的存储也学了一下ElasticSearch的使用，这东西怪好用的，未来学学底层原理。</li></ul><h4 id="为老师Crux功能做个简单的UI测试"><a href="#为老师Crux功能做个简单的UI测试" class="headerlink" title="为老师Crux功能做个简单的UI测试"></a>为老师Crux功能做个简单的UI测试</h4><p>主要借助BootstrapTable进行表格的呈现（同时该支持父子表）</p><h4 id="把所有项目部署在196节点上"><a href="#把所有项目部署在196节点上" class="headerlink" title="把所有项目部署在196节点上"></a>把所有项目部署在196节点上</h4><p>python这语言真是不能更新，不小心更新，anaconda都崩溃了…<br>下班前最后跑服务还是nohup …… &amp;让服务跑在后台吧，以防ssh各种莫名其妙的原因断了</p><h4 id="自己来设计sharding-init算法-rebalance等各个调度策略算法"><a href="#自己来设计sharding-init算法-rebalance等各个调度策略算法" class="headerlink" title="自己来设计sharding_init算法+rebalance等各个调度策略算法"></a>自己来设计sharding_init算法+rebalance等各个调度策略算法</h4><p>第一次接触到了cplex（这个要付费），之后尝试了一些类似scip，glpk等开源的算规划问题的数学工具<br>基本上做这种研究问题就是分三步</p><ol><li>用cplex跑一下我们要优化的目标函数（看模型、程序有没有大问题）</li><li>优化模型，简化目标函数，让cplex跑得更加流畅？例如将非线性目标规划转换成线性的（保证极值点不变）。其实这个时候如果cplex解的快，就可以端到端用cplex引擎。</li><li>如果觉得cplex跑得太慢，就可以用一些heuristic的方法缩短时间（当然精度有所欠缺，保留在一个可以接受的范围就行）。这种heuristic的方法更多就是对自己的目标，有更加特性化的解决方法。这完成了，一篇优化论文就完成啦。</li></ol><p>自己借鉴了一些VM Migration的论文去考虑shard的调度。<br>主要参考Multi-objective optimization for rebalancing virtual machine placement此篇<br>这个实习总结的文章就不专注于论文本身了，其实我觉得这论文也没有什么深挖的必要。<br>总之，我们做调度要考虑以下四个问题:</p><ul><li>如何初始化映射关系</li><li>新增的流怎么分配</li><li>如何rebalance（如何判断unbalance）</li><li>shard超过阈值后如何迁移</li></ul><p>其实蛮难的这些问题…无奈导师走了，实习还是得结束了，其实这些问题是算法的核心问题。做了一堆UI来验证算法的可行性但算法只写了简单的贪心装箱…哎，一大遗憾啊。<br>Todo…. 毕设时再进行一些相关研究</p><h3 id="和导师（或同事）的聊天的部分记录"><a href="#和导师（或同事）的聊天的部分记录" class="headerlink" title="和导师（或同事）的聊天的部分记录"></a>和导师（或同事）的聊天的部分记录</h3><ol><li>做PPT当个处女座吧，展示20页，backup这种过程中生产的胶片可能至少有50页（这种更详细的内容很适合做凝缩后的数据支撑）</li><li>不要说 <strong>“我原来怎么想的”</strong>，请写下来。在脑子的东西是靠不住的模糊的。</li><li>说话，或者写句子。先说论点，再说论据。</li><li>设计一个方法时，预设太多，往往最后的功能就很有限了</li><li>工程师一定要软硬结合来考虑性能</li><li>一个印度四十多岁做业务的，在别人讲完需求后，会紧接着先讲一遍要做的业务，再由此衍生出其他场景去质问提需求的人为什么做，为什么不做。<strong>其实我觉得就是做工程或者做算法，都一定要好好去理解业务！！</strong></li><li>做工程，很多时候要专注模型问题，这是最难的也是最重要的。</li><li>数据怎么存很大程度归决于数据怎么用。</li><li>在公司里，还是必须得有不错的定位问题的能力。</li></ol><h2 id="实习总结"><a href="#实习总结" class="headerlink" title="实习总结"></a>实习总结</h2><p>加过班，熬过夜，生过病，在公司睡过觉。但早上闹钟没响干脆请假这种事也干过。<br>导师转岗，自己也无奈提前离职。<br>不过还是学到了公司的很多为人处事。<br>技术确实没学到什么新的（前端/巩固了python）不过这段时间在学校估计浪费也会很严重吧hh。<br>第一次实习，面对全新的环境，还是收获很大的，说不上来。 对未来的路更坚定了吧！</p><p><strong>部门比公司更重要</strong></p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>软件开发者大会，听了以下一些领域的大牛的演讲…继续摸索吧…</p><ul><li>Serverless</li><li>分布式数据库/云数据库</li><li>区块链</li><li>重构与建模…</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>感悟与记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>保研夏令营预推免总结</title>
    <link href="/2020/10/28/%E4%BF%9D%E7%A0%94%E5%88%86%E4%BA%AB/"/>
    <url>/2020/10/28/%E4%BF%9D%E7%A0%94%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<p>其实距离保研上岸已经一个学期多过去啦，不过实习时确实有一点忙，一直没功夫写一个保研的总结。拖了很久感觉还是得总结一下，希望能对大家有所帮助。</p><h2 id="个人情况介绍"><a href="#个人情况介绍" class="headerlink" title="个人情况介绍"></a>个人情况介绍</h2><p>211网络工程 卓越班 rank （3/32）<br>3段水科研 + </p><h2 id="夏令营-预推免入营情况"><a href="#夏令营-预推免入营情况" class="headerlink" title="夏令营+预推免入营情况"></a>夏令营+预推免入营情况</h2><h4 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h4><p><strong><em>TODO…..</em></strong></p><a id="more"></a>]]></content>
    
    
    
    <tags>
      
      <tag>感悟与记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云平台管理系统</title>
    <link href="/2020/08/26/%E4%BA%91%E5%B9%B3%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/08/26/%E4%BA%91%E5%B9%B3%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>实现功能非常简单，就是调用各个云计算平台如(openstack,cloudstack)的API接口，对不同平台进行一个统一的管理。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>学长将openstack部署在了内网之上，所以我将前端部署在跳板机上，后端部署在openstack控制节点之上从而方便日志功能查看的实现。其余功能还是调用API实现。 </p><h4 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h4><blockquote><p>服务器搭建<br>layui框架使用<br>cURL简介<br>正则表达式与php正则使用<br>整体框架设计</p></blockquote><p><strong><em>TODO…..</em></strong></p><a id="more"></a>]]></content>
    
    
    
    <tags>
      
      <tag>小东西</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信安大赛作品使用指南</title>
    <link href="/2020/06/14/Jade%E4%BF%A1%E5%AE%89%E5%A4%A7%E8%B5%9B%E6%95%99%E7%A8%8B/"/>
    <url>/2020/06/14/Jade%E4%BF%A1%E5%AE%89%E5%A4%A7%E8%B5%9B%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>本作品基于JADE（Java智能体开发框架）,是一个实现共识算法的通信框架。</p><h3 id="JADE简介"><a href="#JADE简介" class="headerlink" title="JADE简介"></a>JADE简介</h3><p>JADE是基于Java 语言的Agent开发框架，是由TILAB 开发的开放源代码的自由软件。JADE是多Agent开发框架，遵循FIPA规范，它提供了基本的命名服务，黄业服务，通讯机制等，可以有效地与其它Java开发平台和技术集成。 JADE架构适应性很强，不仅可以在受限资源环境中运行，而且与其他复杂架构集成到一起，比如：Net和Java EE。它包括一个Agent赖以生存的运行环境，开发Agent应用的类库和用来调试和配置的一套图形化的工具，简化了一个多Agent系统的开发过程。</p><a id="more"></a><h3 id="JADE功能"><a href="#JADE功能" class="headerlink" title="JADE功能"></a>JADE功能</h3><p>JADE为多Agent系统提供了以下功能: </p><blockquote><p>(1)Agent管理系统(Agent Management System，简称AMS)，负责控制平台内Agent的活动、 生存周期及外部应用程序与平台的交互，规范Agent在平台上用独一无二的名字来标识；<br>(2)目录服务器(Dilectoly Facilitatol，简称DF)，负责对平台内的Agent提供黄页服务，注册服务类型以供查找；<br>(3)消息传送系统，也称为Agent交流通道(Agent Communication Channel，简称ACC)，控制平台内或不同平台之间的消息传输、消息编码、消息解析等。<br>JADE定义了Agentclass作为其他Agent的父类，其他Agent均继承自Agentclass。Agentclass中定义了setup方法，用于初始化Agent；定义了takeDown方法，用于结束Agent的运行；定义了doDelete方法，用于终止Agent；定义了Behaviour类以及addBehaviour方法用于添加Agent任务。为了保证Agent的分布式计算和协作机制，JADE构建行为池(Behaviour Pool)来存储所有添加的Behaviour，这些Behaviour呈队列排列，按照进入行为池的顺序依次被调用。Behaviour方法被调用时，首先执行Action方法，然后判断Done函数返回的布尔值，如果为真则将Behaviour移出行为池，继续下一个Behaviour的执行。JADE提供了这样一个基类，其他Agent所需要做的是重载setup，action，done，takeDown 这几个方法来实现特定的功能模块。</p></blockquote><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p><strong>安装JADE前需要先安装jdk并配置好Java环境</strong></p><p>从JADE的官方网站JADE官网上下载JADE的最新版本，目前最新的是4.5.0，我下载的是包含全部文件的JADE-all-4.5.0.zip，先解压这个压缩包，解压得到的文件夹中的所有压缩包也解压到各自的文件夹。建立文件夹起名为jade（存放位置和命名自己喜欢和习惯即可），用来存放JADE的相关文件，我把刚才解压缩的四个文件夹都拷贝到在这个jade文件夹中。<br>四个文件夹说明： </p><blockquote><p>JADE-bin-4.5.0（存放JADE的核心部件，它是JADE框架平台的支持文件）<br>JADE-doc-4.5.0（存放JADE的说明文档，其中包括各种程序说明与教程资料）<br>JADE-examples-4.5.0（存放 JADE 的实例源代码）<br>JADE-src-4.5.0（存放JADE框架平台的源代码，JADE为开源项目）</p></blockquote><h3 id="Eclipse开发"><a href="#Eclipse开发" class="headerlink" title="Eclipse开发"></a>Eclipse开发</h3><p>Window-&gt;Preferences-&gt;Java-&gt;Build Path-&gt;User Libraries新建库，命名为jade，添加jade.jar进这个jade库里<br>新建工程，命名为jade，右击工程，Build Path-&gt;Configure Build Path-&gt;Libraries-&gt;Add Library-&gt;User Library，然后将jade库添加进去<br>在src目录下新建文件夹jadetest，然后将本作品的文件导入<br><img src="/picture/JADE/1.png" srcset="/img/loading.gif" lazyload alt="Run Configurations"></p><p>右击AgentSelector.java，选择Run As，选择Run Configurations，选择Java Application，点击添加，Name起名为：Run In JADE（可任意），Project名不变，Main Class起名为：jade.Boot（固定，不可改变），Argument中Program arguments起名为：-gui selector:jadetest.AgentSelector（如果只想打开GUI管理器而不运行程序，则只要-gui即可），其中，selector为智能体的名字，jadetest为包名，AgentSeletor为类名。其他默认即可，配置完成，点击Run，运行如下：</p><p><img src="/picture/JADE/2.png" srcset="/img/loading.gif" lazyload alt="GUI"></p><p>可以看到创建出来的selector智能体。这里的selector是用来确定通信过程中哪个Agent智能体为主节点。<br>右击Main-Container点击Start New Agent即可创建一个新的Agent智能体。</p><p><img src="/picture/JADE/3.png" srcset="/img/loading.gif" lazyload alt="创建新的Agent"></p><p>这里Class Name选择jadetest.NodeAgent，点击OK创建好一个Agent：</p><p><img src="/picture/JADE/4.png" srcset="/img/loading.gif" lazyload alt="作品运行UI"></p><p>点击帮助了解作品使用方法</p><p><img src="/picture/JADE/5.png" srcset="/img/loading.gif" lazyload alt="帮助"></p>]]></content>
    
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PekingUniversityOJ No.1485</title>
    <link href="/2019/11/29/PekingOJ1485/"/>
    <url>/2019/11/29/PekingOJ1485/</url>
    
    <content type="html"><![CDATA[<p>这是一道很典型的动态规划问题。<br>动态规划在上课的时候说实话没怎么理解其精髓，于是挑一道典型题来练一下。</p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Description</p><p>The fastfood chain McBurger owns several restaurants along a highway. Recently, they have decided to build several depots along the highway, each one located at a restaurant and supplying several of the restaurants with the needed ingredients. Naturally, these depots should be placed so that the average distance between a restaurant and its assigned depot is minimized. You are to write a program that computes the optimal positions and assignments of the depots. </p><p>To make this more precise, the management of McBurger has issued the following specification: You will be given the positions of n restaurants along the highway as n integers d1 &lt; d2 &lt; … &lt; dn (these are the distances measured from the company’s headquarter, which happens to be at the same highway). Furthermore, a number k (k &lt;= n) will be given, the number of depots to be built. </p><p>The k depots will be built at the locations of k different restaurants. Each restaurant will be assigned to the closest depot, from which it will then receive its supplies. To minimize shipping costs, the total distance sum, defined as </p><p>n<br>∑ |di - (position of depot serving restaurant i)|<br>i=1 </p><p>must be as small as possible. </p><p>Write a program that computes the positions of the k depots, such that the total distance sum is minimized.<br>Input</p><p>The input file contains several descriptions of fastfood chains. Each description starts with a line containing the two integers n and k. n and k will satisfy 1 &lt;= n &lt;= 200, 1 &lt;= k &lt;= 30, k &lt;= n. Following this will n lines containing one integer each, giving the positions di of the restaurants, ordered increasingly. </p><p>The input file will end with a case starting with n = k = 0. This case should not be processed.<br>Output</p><p>For each chain, first output the number of the chain. Then output an optimal placement of the depots as follows: for each depot output a line containing its position and the range of restaurants it serves. If there is more than one optimal solution, output any of them. After the depot descriptions output a line containing the total distance sum, as defined in the problem text. </p><p>Output a blank line after each test case.<br>Sample Input</p><p>6 3<br>5<br>6<br>12<br>19<br>20<br>27<br>0 0<br>Sample Output</p><p>Chain 1<br>Depot 1 at restaurant 2 serves restaurants 1 to 3<br>Depot 2 at restaurant 4 serves restaurants 4 to 5<br>Depot 3 at restaurant 6 serves restaurant 6<br>Total distance sum = 8</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>动态规划的核心是要找到一个递推方程。<br>而这道题则需要局部最优状态的递推方程。考虑到局部最优状态mindis[i][j]，表示前i个餐馆<br>分配j个仓库的最短距离。那么，当我们增加一个仓库时：<br>计算MIN(mindis[l][j]+第l+1到第i个餐馆分配一个仓库的最短距离)其中j&lt;l&lt;i<br>则得到mindis[i][j+1]</p><blockquote><p>其实总结起来递推方程即为mindis[i][j]=MIN(mindis[l][j-1]+onedepot[l+1][i])</p></blockquote><p>其中onedepot[l+1][i]代表第l+1个餐馆到第i个餐馆只安排一个仓库的最短距离，而这个最短距离是很好算的<br>最短距离一定是仓库放在中间餐馆时的距离，偶数个餐馆则中间两个餐馆的任意一个都可以。<br>这里只需要求（i+j）/2留下的整数即可。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> n,k;<br><span class="hljs-keyword">int</span> countt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> restaurant[<span class="hljs-number">200</span>],mindis[<span class="hljs-number">200</span>][<span class="hljs-number">30</span>],onedepot[<span class="hljs-number">200</span>][<span class="hljs-number">200</span>];<br><span class="hljs-keyword">int</span> from[<span class="hljs-number">200</span>][<span class="hljs-number">30</span>],to[<span class="hljs-number">200</span>][<span class="hljs-number">30</span>],depot[<span class="hljs-number">200</span>][<span class="hljs-number">30</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(j&lt;=<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> counttt=result(from[i][j]<span class="hljs-number">-1</span>,j<span class="hljs-number">-1</span>); <span class="hljs-comment">//from[i][j]-1就是去掉最后一个仓库分配的餐馆，剩下的最“右”一个餐馆</span><br>    <span class="hljs-comment">//我原来竟然想result(i-t;j-1)这里t去从1开始尝试，直到to[i-t][j-1]=i-t为止...好蠢</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Depot %d at restaurant %d serves "</span>,counttt,depot[i][j]);<br>    <span class="hljs-keyword">if</span>(from[i][j]==to[i][j])<span class="hljs-built_in">printf</span>(<span class="hljs-string">"restaurant %d\n"</span>,from[i][j]);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"restaurants %d to %d\n"</span>,from[i][j],to[i][j]);<br>    <span class="hljs-keyword">return</span> counttt+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">memset</span>(restaurant,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(restaurant));<br>        <span class="hljs-built_in">memset</span>(mindis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(mindis));<br>        <span class="hljs-built_in">memset</span>(onedepot,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(onedepot));<br>        <span class="hljs-keyword">int</span> i,j,l,temp;<br>        countt++;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;k;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>&amp;&amp;k==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-built_in">cin</span>&gt;&gt;restaurant[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;       <span class="hljs-comment">//计算出所有dept 其中onedepot[i][j]代表第i--j个餐厅放置一个仓库的最短距离</span><br>            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                <span class="hljs-keyword">for</span>(l=i;l&lt;=j;l++)&#123;<br>                    onedepot[i][j]=onedepot[i][j]+<span class="hljs-built_in">abs</span>(restaurant[(i+j)/<span class="hljs-number">2</span>]-restaurant[l]);<br>                &#125;<br><br>               <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;"  "&lt;&lt;j&lt;&lt;"   "&lt;&lt;onedepot[i][j]&lt;&lt;endl;</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            mindis[i][<span class="hljs-number">0</span>]=<span class="hljs-number">100000</span>;  <span class="hljs-comment">//递归方程的初始化</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=i&amp;&amp;j&lt;=k;j++)&#123;<br>                mindis[i][j]=<span class="hljs-number">100000</span>;<span class="hljs-comment">//首先将初始值赋为MAX</span><br>                <span class="hljs-keyword">for</span>(l=j<span class="hljs-number">-1</span>;l&lt;i;l++)&#123;<br>                    temp=mindis[l][j<span class="hljs-number">-1</span>]+onedepot[l+<span class="hljs-number">1</span>][i]; <span class="hljs-comment">//mindis[i][j]=min(mindis[l][j-1]+onedepot[l+1][i])</span><br>                    <span class="hljs-keyword">if</span>(temp&lt;mindis[i][j])&#123;<br>                        mindis[i][j]=temp;<br>                        from[i][j]=l+<span class="hljs-number">1</span>;<br>                        to[i][j]=i;<br>                        depot[i][j]=(l+<span class="hljs-number">1</span>+i)/<span class="hljs-number">2</span>;<br>                        <br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Chain %d\n"</span>,countt);<br>        result(n,k);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Total distance sum = %d\n\n"</span>,mindis[n][k]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>语义分析器</title>
    <link href="/2019/11/19/compiler3/"/>
    <url>/2019/11/19/compiler3/</url>
    
    <content type="html"><![CDATA[<h1 id="语义分析器的构造"><a href="#语义分析器的构造" class="headerlink" title="语义分析器的构造"></a>语义分析器的构造</h1><h2 id="语法制导翻译绘制函数图形"><a href="#语法制导翻译绘制函数图形" class="headerlink" title="语法制导翻译绘制函数图形"></a>语法制导翻译绘制函数图形</h2><blockquote><p>表达式值的计算：深度优先后序遍历语法树<br>图形的绘制：画出每个坐标点</p></blockquote><a id="more"></a><h3 id="绘图所需的语义处理"><a href="#绘图所需的语义处理" class="headerlink" title="绘图所需的语义处理"></a>绘图所需的语义处理</h3><p>1.从origin、rot和scale中得到坐标变换所需的信息；<br>2.for_draw语句根据t的每一个值进行如下处理：</p><ul><li>计算被绘制点的横、纵坐标值；</li><li>根据坐标变换信息进行坐标变换，得到实际坐标；</li><li>根据点的实际坐标画出该点。</li></ul><h3 id="语法制导翻译的基本步骤"><a href="#语法制导翻译的基本步骤" class="headerlink" title="语法制导翻译的基本步骤"></a>语法制导翻译的基本步骤</h3><ul><li>为文法符号设计属性；</li><li>设计语义规则中所需的辅助函数；</li><li>为产生式设计语义规则。</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>文法：ScaleStatment  → SCALE IS<br>      L_BRACKET Expression COMMA Expression R_BRACKET<br>可简写为：S → SCALE IS (E,E)<br>            它的作用是提供横、纵坐标的比例因子。<br>因此需要：<br>设计属性：.x和.y，分别保存比例因子；<br>设计计算表达式值的辅助函数：<br>    GetExprValue(nptr)，它返回表达式树的值；<br>设计语义规则：<br>S → SCALE IS (E1,E2) S.x:=GetExprValue(E1.nptr);<br>                    S.y:=GetExprValue(E2.nptr);</p><h4 id="几个关键变量及需构建的函数"><a href="#几个关键变量及需构建的函数" class="headerlink" title="几个关键变量及需构建的函数"></a>几个关键变量及需构建的函数</h4><p>&lt;1&gt; 全程变量：<br>double Parameter=0;            // 为参数T分配的变量<br>double Origin_x=0.0, Origin_y=0.0;// 用于记录平移距离<br>double Rot_ang=0.0;            // 用于记录旋转角度<br>double Scale_x=1, Scale_y=1;        // 用于记录比例因子</p><p>&lt;2&gt; 辅助语义函数<br>a) 计算表达式的值：深度优先后序遍历语法树<br>double GetExprValue(…root);<br>b) 计算点的坐标值：首先获取坐标值，然后进行坐标变换<br>static void CalcCoord(….);<br>c) 绘制一个点(与环境有关):            【这里我java里就没有此绘制函数，主要思路是存下所有的点借助JFrame和JPanel绘制所有的点】<br>void DrawPixel(….);<br>d) 循环绘制所有的点：<br>void DrawLoop(  double Start,<br>                 double End,<br>                   double Step,<br>                   …);<br>e)计算点的坐标：<br>static void CalcCoord (…)；<br>要计算原始坐标、比例变换、旋转变换、平移变换</p><h2 id="语法分析器-语义分析器的代码"><a href="#语法分析器-语义分析器的代码" class="headerlink" title="语法分析器+语义分析器的代码"></a>语法分析器+语义分析器的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> javax.swing.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tree</span> </span>&#123;                     <span class="hljs-comment">//语法树的类,</span><br>    String type=<span class="hljs-string">""</span>;<br>    <span class="hljs-keyword">int</span> rank;<br>    <span class="hljs-keyword">int</span> left=-<span class="hljs-number">1</span>;   <span class="hljs-comment">//T、FUNC都有特殊含义</span><br>    <span class="hljs-keyword">int</span> right=-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">double</span> constant=<span class="hljs-number">0.0</span>d;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coordinate</span></span>&#123;<br>    <span class="hljs-keyword">double</span> x;<br>    <span class="hljs-keyword">double</span> y;<br>&#125;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YuFa_Analyzer</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">JFrame</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Draw2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JFrame</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Draw2</span><span class="hljs-params">()</span><br>        </span>&#123;<br>            MyPanel2 mp= <span class="hljs-keyword">new</span> MyPanel2();<br>            <span class="hljs-keyword">this</span>.add(mp);<br>            <span class="hljs-keyword">this</span>.setSize(<span class="hljs-number">500</span>, <span class="hljs-number">500</span>);<br>            <span class="hljs-keyword">this</span>.setDefaultCloseOperation(EXIT_ON_CLOSE);<br>            <span class="hljs-keyword">this</span>.setVisible(<span class="hljs-keyword">true</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//定义一个panel、用于绘制和实现图像</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPanel2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JPanel</span><br>    </span>&#123;<br>        <span class="hljs-comment">//覆盖jpanel的paint方法</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">paint</span><span class="hljs-params">(Graphics g)</span><br>        </span>&#123;<br>            <span class="hljs-comment">//调用父类函数进行初始化，绝对不可少</span><br>            <span class="hljs-keyword">super</span>.paint(g);<br>            <span class="hljs-comment">//System.out.println("我开始画了！");</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;Dian;i++) &#123;<br>                g.drawOval((<span class="hljs-keyword">int</span>)coord[i].x, (<span class="hljs-keyword">int</span>)(Origin_y-(coord[i].y-Origin_y)), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> blank=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> Dian=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> current=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> sum;<br>    <span class="hljs-keyword">static</span> OutputToken Liu=<span class="hljs-keyword">new</span> OutputToken();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> Parameter=<span class="hljs-number">0</span>;            <span class="hljs-comment">// 为参数T分配的变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> Origin_x=<span class="hljs-number">0.0</span>, Origin_y=<span class="hljs-number">0.0</span>;<span class="hljs-comment">// 用于记录平移距离</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> Rot_ang=<span class="hljs-number">0.0</span>;            <span class="hljs-comment">// 用于记录旋转角度</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> Scale_x=<span class="hljs-number">1</span>, Scale_y=<span class="hljs-number">1</span>;        <span class="hljs-comment">// 用于记录比例因子</span><br>    <span class="hljs-keyword">static</span> Coordinate[] coord=<span class="hljs-keyword">new</span> Coordinate[<span class="hljs-number">10000</span>];<br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-title">YuFa_Analyzer</span><span class="hljs-params">()</span><br>    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) <span class="hljs-comment">//对象需要分别初始化</span><br>        &#123;<br>            coord[j] = <span class="hljs-keyword">new</span> Coordinate();<br>        &#125;<br>        Draw2 demo=<span class="hljs-keyword">new</span> Draw2();<br>    &#125;<br><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">YuFa</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        sum=Liu.Cifa_Analyzer();<br><br>        Tree point[]=<span class="hljs-keyword">new</span> Tree[sum+<span class="hljs-number">1</span>]; <span class="hljs-comment">//最后一位留来创造识别 负数来填补的零</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; sum; j++) <span class="hljs-comment">//对象需要分别初始化</span><br>        &#123;<br>            point[j] = <span class="hljs-keyword">new</span> Tree();<br>            point[j].rank=j;<br>            point[j].type=Liu.tokens[j].type;<br>        &#125;<br>        point[sum]=<span class="hljs-keyword">new</span> Tree();<br>        point[sum].rank=sum;<br>        point[sum].type=<span class="hljs-string">"CONST_ID"</span>;<br>        point[sum].right=-<span class="hljs-number">2</span>;<br><br>        Program(point);<br><br>        <span class="hljs-comment">/*for(int i=0;i&lt;sum+1;i++)&#123;<br>            System.out.println(point[i].type+"  "+point[i].left+"  "+point[i].right+"   "+point[i].constant+"   "+point[i].rank);<br>        &#125;<br>        */</span><br><br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Program</span><span class="hljs-params">(Tree point[])</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!Liu.tokens[current].lexeme.equals(<span class="hljs-string">"NONTOKEN"</span>)) &#123;<br>        Statement(point);<br>        MatchToken(<span class="hljs-string">"SEMICO"</span>);<br>        <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(<span class="hljs-string">"COMMENT"</span>))&#123;<br>            MatchToken(<span class="hljs-string">"COMMENT"</span>);<br>        &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Statement</span><span class="hljs-params">(Tree point[])</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(<span class="hljs-string">"ORIGIN"</span>))&#123;<br>            current++;<br>            OriginStatement(point);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(<span class="hljs-string">"SCALE"</span>))&#123;<br>            current++;<br>            ScaleStatement(point);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(<span class="hljs-string">"ROT"</span>))&#123;<br>            current++;<br>            RotStatement(point);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(<span class="hljs-string">"FOR"</span>))&#123;<br>            current++;<br>            ForStatement(point);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            System.out.println(Liu.tokens[current].type+<span class="hljs-string">" 语法错误  "</span>+current);<br>            System.exit(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OriginStatement</span><span class="hljs-params">(Tree point[])</span></span>&#123;<br>        MatchToken(<span class="hljs-string">"IS"</span>);<br>        MatchToken(<span class="hljs-string">"L_BRACKET"</span>);<br>        <span class="hljs-keyword">int</span> x=Expression(point);<br>        System.out.println();<br>        PrintTree(point,x,<span class="hljs-number">0</span>);<br>        Origin_x=GetExprValue(point,x);<br>        MatchToken(<span class="hljs-string">"COMMA"</span>);<br>        <span class="hljs-keyword">int</span> y=Expression(point);<br>        PrintTree(point,y,<span class="hljs-number">0</span>);<br>        Origin_y=GetExprValue(point,y);<br>        MatchToken(<span class="hljs-string">"R_BRACKET"</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ScaleStatement</span><span class="hljs-params">(Tree point[])</span></span>&#123;<br>        MatchToken(<span class="hljs-string">"IS"</span>);<br>        MatchToken(<span class="hljs-string">"L_BRACKET"</span>);<br>        <span class="hljs-keyword">int</span> x=Expression(point);<br>        PrintTree(point,x,<span class="hljs-number">0</span>);<br>        Scale_x=GetExprValue(point,x);<br>        MatchToken(<span class="hljs-string">"COMMA"</span>);<br>        <span class="hljs-keyword">int</span> y=Expression(point);<br>        PrintTree(point,y,<span class="hljs-number">0</span>);<br>        Scale_y=GetExprValue(point,y);<br>        MatchToken(<span class="hljs-string">"R_BRACKET"</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RotStatement</span><span class="hljs-params">(Tree point[])</span></span>&#123;<br>        MatchToken(<span class="hljs-string">"IS"</span>);<br>        <span class="hljs-keyword">int</span> x=Expression(point);<br>        PrintTree(point,x,<span class="hljs-number">0</span>);<br>        Rot_ang=GetExprValue(point,x);<br>        <span class="hljs-comment">//System.out.println("根为:"+x);</span><br>        <span class="hljs-comment">//System.out.println("Rot为:"+Rot_ang);</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ForStatement</span><span class="hljs-params">(Tree point[])</span></span>&#123;<br>        <span class="hljs-keyword">int</span> a,b,c,d,e;<br>        MatchToken(<span class="hljs-string">"T"</span>);<br>        MatchToken(<span class="hljs-string">"FROM"</span>);<br>        a=Expression(point);<br>        PrintTree(point,a,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">double</span> Start=GetExprValue(point,a);<br>        MatchToken(<span class="hljs-string">"TO"</span>);<br>        b=Expression(point);<br>        PrintTree(point,b,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">double</span> End=GetExprValue(point,b);<br>        MatchToken(<span class="hljs-string">"STEP"</span>);<br>        c=Expression(point);<br>        PrintTree(point,c,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">double</span> Step=GetExprValue(point,c);<br>        MatchToken(<span class="hljs-string">"DRAW"</span>);<br>        MatchToken(<span class="hljs-string">"L_BRACKET"</span>);<br>        d=Expression(point);<span class="hljs-comment">//x坐标</span><br>        PrintTree(point,d,<span class="hljs-number">0</span>);<br>        MatchToken(<span class="hljs-string">"COMMA"</span>);<br>        e=Expression(point);    <span class="hljs-comment">//y坐标</span><br>        PrintTree(point,e,<span class="hljs-number">0</span>);<br>        MatchToken(<span class="hljs-string">"R_BRACKET"</span>);<br><br>        DrawLoop(Start,End,Step,d,e,point);   <span class="hljs-comment">//开始画画！！</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Expression</span><span class="hljs-params">(Tree point[])</span></span>&#123;<br>        <span class="hljs-keyword">int</span> left,right;<br>        left=Term(point);<br>        <span class="hljs-keyword">while</span>(Liu.tokens[current].type.equals(<span class="hljs-string">"PLUS"</span>)||Liu.tokens[current].type.equals(<span class="hljs-string">"MINUS"</span>))&#123;<br>            <span class="hljs-comment">//point[current].type=Liu.tokens[current].type;</span><br>            <span class="hljs-keyword">int</span> mark=current;<br>            MatchToken(Liu.tokens[current].type);<br>            right=Term(point);<br>            MakeNode(point,mark,left,right);<br>            left=mark;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Term</span><span class="hljs-params">(Tree point[])</span></span>&#123;<br>        <span class="hljs-keyword">int</span> left,right;<br>        left=Factor(point);<br>        <span class="hljs-keyword">while</span>(Liu.tokens[current].type.equals(<span class="hljs-string">"MUL"</span>)||Liu.tokens[current].type.equals(<span class="hljs-string">"DIV"</span>)) &#123;<br>            <span class="hljs-keyword">int</span> mark = current;<br>            MatchToken(Liu.tokens[current].type);<br>            right = Factor(point);<br>            MakeNode(point, mark, left, right);<br>            left = mark;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Factor</span><span class="hljs-params">(Tree point[])</span></span>&#123;<br>        <span class="hljs-keyword">int</span> left,right;<br>        <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(<span class="hljs-string">"PLUS"</span>)||Liu.tokens[current].type.equals(<span class="hljs-string">"MINUS"</span>))&#123;<br>            left=current;<br>            MatchToken(Liu.tokens[current].type);<br>            right=Factor(point);<br>            MakeNode(point,left,sum,right);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            left=component(point);<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">component</span><span class="hljs-params">(Tree point[])</span></span>&#123;<br>        <span class="hljs-keyword">int</span> left,right,mark;<br>        left=Atom(point);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (Liu.tokens[current].type.equals(<span class="hljs-string">"POWER"</span>)) &#123;<br>                mark = current;<br>                MatchToken(<span class="hljs-string">"POWER"</span>);<br>                right = component(point);<br>                MakeNode(point, mark, left, right);<br>                left=mark;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Atom</span><span class="hljs-params">(Tree point[])</span></span>&#123;<br>        <span class="hljs-keyword">int</span> left,right,mark;<br>        left=<span class="hljs-number">0</span>;<span class="hljs-comment">//无奈的初始化</span><br>        <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(<span class="hljs-string">"CONST_ID"</span>))&#123;<br>            left=current;<br>            mark=current;<br>            MatchToken(<span class="hljs-string">"CONST_ID"</span>);<br>            MakeNode(point,mark,left,left);<span class="hljs-comment">//常数的left right参数没啥用</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(<span class="hljs-string">"T"</span>))&#123;<br>            left=current;<br>            mark=current;<br>            MatchToken(<span class="hljs-string">"T"</span>);<br>            MakeNode(point,mark,left,left);<span class="hljs-comment">//T的left right参数没啥用</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(<span class="hljs-string">"FUNC"</span>))&#123;<br>            left=current;<br>            mark=current;<br>            MatchToken(<span class="hljs-string">"FUNC"</span>);<br>            MatchToken(<span class="hljs-string">"L_BRACKET"</span>);<br>            right=Expression(point);<br>            MatchToken(<span class="hljs-string">"R_BRACKET"</span>);<br>            MakeNode(point,mark,left,right);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(<span class="hljs-string">"L_BRACKET"</span>))&#123;<br>            MatchToken(<span class="hljs-string">"L_BRACKET"</span>);<br>            <span class="hljs-comment">//mark=current;</span><br>            left=Expression(point);<br>            MatchToken(<span class="hljs-string">"R_BRACKET"</span>);<br><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            System.out.println(Liu.tokens[current].type+<span class="hljs-string">"  WRONG1  "</span>+current);<br>            System.exit(<span class="hljs-number">0</span>);<span class="hljs-comment">//出错了</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br><br><br><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeNode</span><span class="hljs-params">(Tree point[],<span class="hljs-keyword">int</span> mark,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<span class="hljs-comment">//制作节点，并且只要判断left和right值相不相等，就能知道哪些Token在Expression中，这里程序其实没用上...</span><br>        <span class="hljs-keyword">if</span>(point[mark].type.equals(<span class="hljs-string">"CONST_ID"</span>))&#123;<br>            point[mark].constant=Liu.tokens[mark].value;<br>            point[mark].right=-<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[mark].type.equals(<span class="hljs-string">"T"</span>))&#123; <span class="hljs-comment">//制定一个规则表示T</span><br>            point[mark].left=-<span class="hljs-number">100</span>;<br>            point[mark].right=-<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[mark].type.equals(<span class="hljs-string">"FUNC"</span>))&#123;  <span class="hljs-comment">//制定一个规则来表示不同的func，其实没啥用...</span><br>            <span class="hljs-comment">//"SIN", "COS", "TAN", "LN", "EXP", "SQRT"</span><br>            <span class="hljs-keyword">if</span>(Liu.tokens[mark].lexeme.toUpperCase().equals(<span class="hljs-string">"COS"</span>))&#123;<br>                point[mark].left=-<span class="hljs-number">2</span>;<br>                point[mark].right=right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[mark].lexeme.toUpperCase().equals(<span class="hljs-string">"SIN"</span>))&#123;<br>                point[mark].left=-<span class="hljs-number">3</span>;<br>                point[mark].right=right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[mark].lexeme.toUpperCase().equals(<span class="hljs-string">"TAN"</span>))&#123;<br>                point[mark].left=-<span class="hljs-number">4</span>;<br>                point[mark].right=right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[mark].lexeme.toUpperCase().equals(<span class="hljs-string">"LN"</span>))&#123;<br>                point[mark].left=-<span class="hljs-number">5</span>;<br>                point[mark].right=right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[mark].lexeme.toUpperCase().equals(<span class="hljs-string">"EXP"</span>))&#123;<br>                point[mark].left=-<span class="hljs-number">6</span>;<br>                point[mark].right=right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Liu.tokens[mark].lexeme.toUpperCase().equals(<span class="hljs-string">"SQRT"</span>))&#123;<br>                point[mark].left=-<span class="hljs-number">7</span>;<br>                point[mark].right=right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            point[mark].left=left;<br>            point[mark].right=right;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MatchToken</span><span class="hljs-params">(String token)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(Liu.tokens[current].type.equals(token))&#123;<br>            current++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(Liu.tokens[current].type+<span class="hljs-string">" Match WRRRRROOOOONG! "</span>+current);<br>            System.exit(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">GetExprValue</span><span class="hljs-params">(Tree[] point, <span class="hljs-keyword">int</span> root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">"PLUS"</span>))&#123;<br>            <span class="hljs-keyword">return</span> GetExprValue(point,point[root].left)+GetExprValue(point,point[root].right);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">"MINUS"</span>))&#123;<br>            <span class="hljs-keyword">return</span> GetExprValue(point,point[root].left)-GetExprValue(point,point[root].right);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">"MUL"</span>))&#123;<br>            <span class="hljs-keyword">return</span> GetExprValue(point,point[root].left)*GetExprValue(point,point[root].right);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">"DIV"</span>))&#123;<br>            <span class="hljs-keyword">return</span> GetExprValue(point,point[root].left)/GetExprValue(point,point[root].right);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">"POWER"</span>))&#123;<br>            <span class="hljs-keyword">return</span> Math.pow(GetExprValue(point,point[root].left),GetExprValue(point,point[root].right));<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">"FUNC"</span>))&#123;<br>            <span class="hljs-keyword">switch</span>(point[root].left)&#123;<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">2</span>:<br>                    <span class="hljs-keyword">return</span> Math.cos(GetExprValue(point,point[root].right));<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">3</span>:<br>                    <span class="hljs-keyword">return</span> Math.sin(GetExprValue(point,point[root].right));<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">4</span>:<br>                    <span class="hljs-keyword">return</span> Math.tan(GetExprValue(point,point[root].right));<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">5</span>:<br>                    <span class="hljs-keyword">return</span> Math.log(GetExprValue(point,point[root].right));<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">6</span>:<br>                    <span class="hljs-keyword">return</span> Math.exp(GetExprValue(point,point[root].right));<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">7</span>:<br>                    <span class="hljs-keyword">return</span> Math.sqrt(GetExprValue(point,point[root].right));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">"CONST_ID"</span>))&#123;<br>            <span class="hljs-keyword">return</span> point[root].constant;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">"T"</span>))&#123;<br>            <span class="hljs-keyword">return</span> Parameter;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">"计算Expression出错"</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>d;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>d;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawLoop</span><span class="hljs-params">(<span class="hljs-keyword">double</span> Start,<br>                         <span class="hljs-keyword">double</span> End,<br>                         <span class="hljs-keyword">double</span> Step,<br>                         <span class="hljs-keyword">int</span> x,<br>                         <span class="hljs-keyword">int</span> y,<br>                         Tree point[])</span></span>&#123;<br><br>        <span class="hljs-keyword">for</span>(Parameter=Start;Parameter&lt;=End;Parameter+=Step)&#123;<br>            coord[Dian]=CalcCoord(point,coord[Dian],x,y);<br>            Dian++;<br>        &#125;<br>        System.out.println(<span class="hljs-string">"有几个点！！："</span>+Dian);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Coordinate <span class="hljs-title">CalcCoord</span><span class="hljs-params">(Tree point[],Coordinate coord,<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">double</span> local_x,local_y,temp;<br>        local_x=GetExprValue(point,x);<br>        local_y=GetExprValue(point,y);<br>        local_x*=Scale_x;<br>        local_y*=Scale_y;<br>        temp=local_x*Math.cos(Rot_ang)+local_y*Math.sin(Rot_ang);<br>        local_y=local_y*Math.cos(Rot_ang)-local_x*Math.sin(Rot_ang);<br>        local_x=temp;<br>        local_x+=Origin_x;<br>        local_y+=Origin_y;<br>        coord.x=local_x;<br>        coord.y=local_y;<br>        <span class="hljs-keyword">return</span> coord;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">PrintTree</span><span class="hljs-params">(Tree point[],<span class="hljs-keyword">int</span> root,<span class="hljs-keyword">int</span> k)</span><br>    </span>&#123;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            System.out.print(<span class="hljs-string">'\t'</span>);<br>        &#125;<br>        k++;<br>        System.out.println(point[root].type);<br>        <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">"PLUS"</span>))&#123;<br>            PrintTree(point,point[root].left,k);<br>            PrintTree(point,point[root].right,k);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">"MINUS"</span>))&#123;<br>            PrintTree(point,point[root].left,k);<br>            PrintTree(point,point[root].right,k);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">"MUL"</span>))&#123;<br>            PrintTree(point,point[root].left,k);<br>            PrintTree(point,point[root].right,k);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">"DIV"</span>))&#123;<br>            PrintTree(point,point[root].left,k);<br>            PrintTree(point,point[root].right,k);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">"POWER"</span>))&#123;<br>            PrintTree(point,point[root].left,k);<br>            PrintTree(point,point[root].right,k);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">"FUNC"</span>))&#123;<br>            <span class="hljs-keyword">switch</span>(point[root].left)&#123;<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">2</span>:<br>                    PrintTree(point,point[root].right,k);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">3</span>:<br>                    PrintTree(point,point[root].right,k);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">4</span>:<br>                    PrintTree(point,point[root].right,k);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">5</span>:<br>                    PrintTree(point,point[root].right,k);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">6</span>:<br>                    PrintTree(point,point[root].right,k);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> -<span class="hljs-number">7</span>:<br>                    PrintTree(point,point[root].right,k);<br>                    <span class="hljs-keyword">break</span>;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">"CONST_ID"</span>))&#123;<br><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(point[root].type.equals(<span class="hljs-string">"T"</span>))&#123;<br><br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>语法分析器</title>
    <link href="/2019/11/10/compiler2/"/>
    <url>/2019/11/10/compiler2/</url>
    
    <content type="html"><![CDATA[<h1 id="语法分析器的构造"><a href="#语法分析器的构造" class="headerlink" title="语法分析器的构造"></a>语法分析器的构造</h1><p>两个任务：</p><blockquote><p>为句子（表达式）构造语法树；<br>检查程序（语句）中的语法错误。</p></blockquote><a id="more"></a><p>主要工作：</p><blockquote><p>设计函数绘图语言的文法，使其适合递归下降分析；<br>设计语法树的节点，用于存放表达式的语法树；<br>设计递归下降子程序，分析句子并构造表达式的语法树；<br>设计测试程序和测试用例，检验分析器是否正确。</p></blockquote><h2 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h2><p>Program   → ε| Program Statement SEMICO</p><p>Statement →  OriginStatment | ScaleStatment<br>        |  RotStatment    | ForStatment</p><p>OriginStatment → ORIGIN IS </p><p>L_BRACKET Expression COMMA Expression R_BRACKET</p><p>ScaleStatment  → SCALE IS </p><p>L_BRACKET Expression COMMA Expression R_BRACKET</p><p>RotStatment → ROT IS Expression</p><p>ForStatment → FOR T<br>   FROM Expression<br>   TO   Expression<br>   STEP Expression<br>   DRAW L_BRACKET Expression COMMA Expression R_BRACKET</p><p>Expression<br>  → Expression PLUS Expression<br>  |  Expression MINUS Expression<br>  |  Expression MUL Expression<br>  |  Expression DIV Expression<br>  |  PLUS Expression<br>  |  MINUS Expression<br>  |  Expression POWER Expression<br>  |  CONST_ID<br>  |  T<br>  |  FUNC L_BRACKET  Expression  R_BRACKET<br>  |  L_BRACKET  Expression  R_BRACKET</p><h2 id="消除二义性"><a href="#消除二义性" class="headerlink" title="消除二义性"></a>消除二义性</h2><p>表达式中的运算                       结合性       非终结符<br> PLUS、MINUS（二元）        左结合       Expression<br> MUL、DIV                              左结合       Term<br> PLUS、MINUS（一元）        右结合       Factor<br> POWER                                  右结合       Component<br>（原子表达式）                           无          Atom</p><p>Expression<br>  → Expression PLUS Expression<br>  |  Expression MINUS Expression<br>  |  Expression MUL Expression<br>  |  Expression DIV Expression<br>  |  PLUS Expression<br>  |  MINUS Expression<br>  |  Expression POWER Expression<br>  |  CONST_ID<br>  |  T<br>  |  FUNC L_BRACKET  Expression  R_BRACKET<br>  |  L_BRACKET  Expression  R_BRACKET</p><blockquote><p>要引入非终结符来体现优先性还有结合性</p></blockquote><h3 id="无二义性的表达式文法"><a href="#无二义性的表达式文法" class="headerlink" title="无二义性的表达式文法"></a>无二义性的表达式文法</h3><p>Expression → Expression PLUS Term<br>        | Expression MINUS Term<br>        | Term<br>Term       → Term MUL Factor<br>        | Term DIV Factor<br>        | Factor<br>Factor     → PLUS Factor<br>        | MINUS Factor<br>        | Component<br>Component  → Atom POWER Component<br>        | Atom<br>Atom       → CONST_ID<br>        |  T<br>        |  FUNC L_BRACKET  Expression  R_BRACKET<br>        |  L_BRACKET  Expression  R_BRACKET</p><h2 id="消除左递归和提取左因子"><a href="#消除左递归和提取左因子" class="headerlink" title="消除左递归和提取左因子"></a>消除左递归和提取左因子</h2><blockquote><p>这样在递归下降分析中不会无限循环寻找左子树</p></blockquote><p><strong>消除Expression和Term 的左递归</strong><br>Expression → Term  Expression’<br>Expression’→ PLUS Term Expression’<br>            | MINUS Term Expression’<br>            |ε</p><p>Term  → Factor Term’<br>Term’ → MUL Factor Term’<br>       | DIV Factor Term’<br>       |ε</p><h2 id="改写左结合的产生式为EBNF形式（避免子程序调用）"><a href="#改写左结合的产生式为EBNF形式（避免子程序调用）" class="headerlink" title="改写左结合的产生式为EBNF形式（避免子程序调用）"></a>改写左结合的产生式为EBNF形式（避免子程序调用）</h2><p>递归子程序仅要求产生式没有左递归。</p><h3 id="改写Program产生式："><a href="#改写Program产生式：" class="headerlink" title="改写Program产生式："></a>改写Program产生式：</h3><p>Program → Statement SEMICO Program |ε的子程序：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Program</span><span class="hljs-params">()</span><br></span>&#123; <span class="hljs-keyword">if</span> (token == NONTOKEN) <span class="hljs-keyword">return</span>;    <br>  Statement(); MathchToken(SEMICO); Program();<br>&#125;<br></code></pre></td></tr></table></figure><p>改写为EBNF形式，以减少不必要的子程序调用。<br>Program  → { Statement SEMICO }的子程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Program</span><span class="hljs-params">()</span><br></span>&#123;  <span class="hljs-keyword">while</span> (token != NONTOKEN) <br>   &#123; Statement(); MathchToken(SEMICO); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="改写Expression产生式："><a href="#改写Expression产生式：" class="headerlink" title="改写Expression产生式："></a>改写Expression产生式：</h3><p>Expression  →Term  Expression’<br>Expression’ → PLUS Term Expression’<br>             | MINUS Term Expression’ |ε </p><p>Expression’→(PLUS|MINUS)Term Expression’|ε<br>Program    →  Statement SEMICO Program |ε </p><p>Expression’ →     {(PLUS|MINUS)Term }<br>Expression → Term {(PLUS|MINUS)Term }<br>Expression的递归子程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Expression</span><span class="hljs-params">()</span><br></span>&#123;    Term();<br>         <span class="hljs-keyword">while</span> (token==PLUS || token==MINUS) <br>    &#123; MathchToken(token); Term();&#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="最终Expression"><a href="#最终Expression" class="headerlink" title="最终Expression"></a>最终Expression</h3><p>Expression     → Term  { ( PLUS | MINUS) Term }<br>Term           → Factor { ( MUL | DIV ) Factor }<br>Factor      → PLUS Factor | MINUS Factor | Component<br>Component     → Atom [POWER Component]<br>Atom → CONST_ID<br>            | T<br>            | FUNC L_BRACKET Expression R_BRACKET<br>            | L_BRACKET Expression R_BRACKET </p><h2 id="构造Expression的语法树"><a href="#构造Expression的语法树" class="headerlink" title="构造Expression的语法树"></a>构造Expression的语法树</h2><p>通过构建语法树，才可在语义分析时通过遍历二叉树计算表达式的值。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>叶节点：常数、参数T等。<br>两个孩子的内部节点：二元运算如Plus、Mul等。<br>                                    一元加：+5转化为5；<br>                                    一元减：-5转化为0-5。<br>一个孩子的内部节点：函数调用，如cos(t)等。<br><img src="/picture/Tree.png" srcset="/img/loading.gif" lazyload alt="示例"></p><blockquote><p>其实用c/c++做会较为简单，因为指针的存在二叉树很方便。java这里我构建了一个类，其中left,right是左子树或右子树的数组序，其实还是通过数组的序来确定这颗树的。</p></blockquote><p>这里代码在语义分析处附上，因为我将语义分析紧接着语法分析做了。因为比较方便,不用重复创建使用Tokens。</p>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>词法分析器</title>
    <link href="/2019/11/05/compiler1/"/>
    <url>/2019/11/05/compiler1/</url>
    
    <content type="html"><![CDATA[<h1 id="绘图语言介绍"><a href="#绘图语言介绍" class="headerlink" title="绘图语言介绍"></a>绘图语言介绍</h1><p>&lt;1&gt; 实现简单函数绘图的语句</p><ul><li>循环绘图（FOR-DRAW）</li><li>比例设置（SCALE）</li><li>角度旋转（ROT）</li><li>坐标平移（ORIGIN）</li><li>注释        （– 或 //）<a id="more"></a></li></ul><hr><p>&lt;2&gt; 屏幕（窗口）的坐标系</p><ul><li>左上角为原点</li><li>x方向从左向右增长</li><li>y方向从上到下增长(与一般的坐标系方向相反)</li></ul><hr><p>&lt;3&gt; 函数绘图源程序举例<br>————— 函数f(t)=t的图形<br>origin is (100, 300);    – 设置原点的偏移量<br>rot is 0;            – 设置旋转角度(不旋转)<br>scale is (1, 1);        – 设置横坐标和纵坐标的比例<br>for T from 0 to 200 step 1 draw (t, 0);<br>                – 横坐标的轨迹（纵坐标为0）<br>for T from 0 to 150 step 1 draw (0, -t);<br>                – 纵坐标的轨迹（横坐标为0）<br>for T from 0 to 120 step 1 draw (t, -t);<br>                – 函数f(t)=t的轨迹<br>//默认值：<br>//  origin is (0, 0)<br>// rot is 0;<br>// scale is (1, 1)</p><blockquote><p>FOR T FROM 起点 TO 终点 STEP 步长 DRAW(横坐标, 纵坐标);</p></blockquote><blockquote><p>令T从起点到终点、每次改变一个步长，绘制出由(横坐标，纵坐标)所规定的点的轨迹。</p></blockquote><blockquote><p>FOR T FROM 0 TO 2*PI STEP PI/50 DRAW (cos(T), sin(T));</p></blockquote><blockquote><p>该语句的作用是令T从0到2*PI、步长 PI/50，绘制出各个点的坐标(cos(T)，sin(T))，即一个单位圆。</p></blockquote><p>语句满足下述规定(原则)：<br>&lt;1&gt;各类语句可以按任意次序书写，且语句以分号结尾。源程序中的语句以它们出现的先后顺序处。<br>&lt;2&gt;ORIGIN、ROT和SCALE语句只影响其后的绘图语句，且遵循最后出现的语句有效的原则。例如，若有下述ROT语句序列：     ROT IS 0.7 ；<br>                                            ROT IS 1.57 ；<br>则随后的绘图语句将按1.57而不是0.7弧度旋转。<br>&lt;3&gt;无论ORIGIN、ROT和SCALE语句的出现顺序如何，图形的变换顺序总是：比例变换→旋转变换→平移变换<br>&lt;4&gt; 语言对大小写不敏感，例如for、For、FOR等，均被认为是同一个保留字。<br>&lt;5&gt; 语句中表达式的值均为双精度类型，旋转角度单位为弧度且为逆时针旋转，平移单位为点。  </p><h2 id="词法分析器的构造"><a href="#词法分析器的构造" class="headerlink" title="词法分析器的构造"></a>词法分析器的构造</h2><blockquote><p>步骤：正规式－NFA－DFA－最小DFA－编写程序－测试 </p></blockquote><p>三个任务</p><blockquote><p>滤掉源程序中的无用成分<br>输出记号供语法分析器使用<br>识别非法输入，并将其标记为“出错记号”。</p></blockquote><p>记号的组成：记号的<strong>类别</strong>和<strong>属性</strong></p><p><strong><em>本简易编译器使用java来构造</em></strong><br>public class Token {<br>    public String type=””;     //类别<br>    public String lexeme=””; //词义，这里是输入的字符串<br>    public double value;  //如果是常数则为常数的值，否则无意义<br>}</p><h4 id="函数绘图语言中记号的分类与表示"><a href="#函数绘图语言中记号的分类与表示" class="headerlink" title="函数绘图语言中记号的分类与表示"></a>函数绘图语言中记号的分类与表示</h4><p>private static final String[] Token_Type = {<br>        “ORIGIN”, “SCALE”, “ROT”, “IS”,      // 保留字（一字一码）<br>        “TO”, “STEP”, “DRAW”, “FOR”, “FROM”, //保留字<br>        “T”,                  // 参数<br>        “SEMICO”, “L_BRACKET”, “R_BRACKET”, “COMMA”,// 分隔符<br>        “PLUS”, “MINUS”, “MUL”, “DIV”, “POWER”,        // 运算符<br>        “FUNC”,                  // 函数（调用）<br>        “CONST_ID”,              // 常数<br>        “NONTOKEN”,              // 空记号（源程序结束）<br>        “ERRTOKEN”              //出错记号（非法符号）<br>};</p><h4 id="正规式"><a href="#正规式" class="headerlink" title="正规式"></a>正规式</h4><p>letter    = [a-zA-Z]<br>digit    = [0-9] </p><p>COMMENT       = “//“|”–”<br>WHITE_SPACE     = (“ “|\t|\n)+<br>SEMICO        = “;”<br>L_BRACKET     = “(“<br>R_BRACKET     = “)”<br>COMMA         = “,”<br>PLUS          = “+”<br>MINUS         = “-“<br>MUL          = “*”<br>DIV           = “/“<br>POWER         = “<em>*”<br>CONST_ID        = digit+(“.” digit</em>)?<br>ID            = letter+<br>（去除注释与白空有11个正规式）</p><h4 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h4><p><img src="/picture/DFA.png" srcset="/img/loading.gif" lazyload alt="DFA"></p><h3 id="程序思路及代码"><a href="#程序思路及代码" class="headerlink" title="程序思路及代码"></a>程序思路及代码</h3><p>思路非常简单，单个单个读取字符，根据DFA匹配，并赋值给Token，以产生记号流给予语法分析器分析。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Token</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String type=<span class="hljs-string">""</span>;<br>    <span class="hljs-keyword">public</span> String lexeme=<span class="hljs-string">""</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> value;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OutputToken</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Token[] tokens = <span class="hljs-keyword">new</span> Token[<span class="hljs-number">1000</span>];<span class="hljs-comment">//开辟数组空间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] Token_Type = &#123;<br>            <span class="hljs-string">"ORIGIN"</span>, <span class="hljs-string">"SCALE"</span>, <span class="hljs-string">"ROT"</span>, <span class="hljs-string">"IS"</span>,      <span class="hljs-comment">// 保留字（一字一码）</span><br>            <span class="hljs-string">"TO"</span>, <span class="hljs-string">"STEP"</span>, <span class="hljs-string">"DRAW"</span>, <span class="hljs-string">"FOR"</span>, <span class="hljs-string">"FROM"</span>, <span class="hljs-comment">//保留字</span><br>            <span class="hljs-string">"T"</span>,                  <span class="hljs-comment">// 参数</span><br>            <span class="hljs-string">"SEMICO"</span>, <span class="hljs-string">"L_BRACKET"</span>, <span class="hljs-string">"R_BRACKET"</span>, <span class="hljs-string">"COMMA"</span>,<span class="hljs-comment">// 分隔符</span><br>            <span class="hljs-string">"PLUS"</span>, <span class="hljs-string">"MINUS"</span>, <span class="hljs-string">"MUL"</span>, <span class="hljs-string">"DIV"</span>, <span class="hljs-string">"POWER"</span>,        <span class="hljs-comment">// 运算符</span><br>            <span class="hljs-string">"FUNC"</span>,                  <span class="hljs-comment">// 函数（调用）</span><br>            <span class="hljs-string">"CONST_ID"</span>,              <span class="hljs-comment">// 常数</span><br>            <span class="hljs-string">"NONTOKEN"</span>,              <span class="hljs-comment">// 空记号（源程序结束）</span><br>            <span class="hljs-string">"ERRTOKEN"</span>              <span class="hljs-comment">//出错记号（非法符号）</span><br>    &#125;;<br><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Cifa_Analyzer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        String pathName = <span class="hljs-string">"/Users/leo/Desktop/test.txt"</span>;<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(pathName);<br>        BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(fis));<br>        String temp = <span class="hljs-string">""</span>;<br>        String string2 = <span class="hljs-string">""</span>;<br>        <span class="hljs-keyword">while</span> ((temp = br.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>            string2 = string2 + temp + <span class="hljs-string">'\n'</span>;<br>        &#125;<br>        <span class="hljs-keyword">char</span>[] chars = string2.toCharArray();<br><span class="hljs-comment">//        OutputToken test=new OutputToken(string);</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) <span class="hljs-comment">//对象需要分别初始化</span><br>        &#123;<br>            tokens[j] = <span class="hljs-keyword">new</span> Token();<br>        &#125;<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; string2.length(); ) &#123;<br>            <span class="hljs-keyword">if</span> ((chars[i] &gt;= <span class="hljs-number">65</span> &amp;&amp; chars[i] &lt;= <span class="hljs-number">90</span>) || (chars[i] &lt;= <span class="hljs-number">122</span> &amp;&amp; chars[i] &gt;= <span class="hljs-number">97</span>)) &#123;<br>                tokens[k].type += <span class="hljs-string">"ID"</span>;<br>                tokens[k].lexeme = tokens[k].lexeme + chars[i];<br>                tokens[k].value = <span class="hljs-number">0.0</span>d;<br>                i++;<br>                <span class="hljs-keyword">while</span> ((chars[i] &gt;= <span class="hljs-number">65</span> &amp;&amp; chars[i] &lt;= <span class="hljs-number">90</span>) || (chars[i] &lt;= <span class="hljs-number">122</span> &amp;&amp; chars[i] &gt;= <span class="hljs-number">97</span>)) &#123;<br>                    tokens[k].lexeme = tokens[k].lexeme + chars[i];<br>                    i++;<br>                &#125;<br>                k++;<br>            &#125;   <span class="hljs-comment">//letter</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[i] &gt;= <span class="hljs-number">48</span> &amp;&amp; chars[i] &lt;= <span class="hljs-number">57</span>) &#123;<br>                tokens[k].type = <span class="hljs-string">"CONST_ID"</span>;<br>                tokens[k].lexeme = tokens[k].lexeme + chars[i];<br>                i++;<br>                <span class="hljs-keyword">while</span> (chars[i] &gt;= <span class="hljs-number">48</span> &amp;&amp; chars[i] &lt;= <span class="hljs-number">57</span>) &#123;<br>                    tokens[k].lexeme = tokens[k].lexeme + chars[i];<br>                    i++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">'.'</span>) &#123;<br>                    tokens[k].lexeme = tokens[k].lexeme + chars[i];<br>                    i++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    tokens[k].value = Double.parseDouble(tokens[k].lexeme);<br>                    k++;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (chars[i] &gt;= <span class="hljs-number">48</span> &amp;&amp; chars[i] &lt;= <span class="hljs-number">57</span>) &#123;<br>                    <span class="hljs-keyword">while</span> (chars[i] &gt;= <span class="hljs-number">48</span> &amp;&amp; chars[i] &lt;= <span class="hljs-number">57</span>) &#123;<br>                        tokens[k].lexeme = tokens[k].lexeme + chars[i];<br>                        i++;<br>                    &#125;<br>                    tokens[k].value = Double.parseDouble(tokens[k].lexeme);<br>                    k++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    System.out.println(tokens[k].lexeme);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br><br>            &#125;<span class="hljs-comment">//digit</span><br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">'*'</span>) &#123;<br>                <span class="hljs-keyword">if</span> (chars[i + <span class="hljs-number">1</span>] == <span class="hljs-string">'*'</span>) &#123;<br>                    tokens[k].type = <span class="hljs-string">"POWER"</span>;<br>                    tokens[k].lexeme = <span class="hljs-string">"**"</span>;<br>                    tokens[k].value = <span class="hljs-number">0.0</span>d;<br>                    i = i + <span class="hljs-number">2</span>;<br>                    k++;<br><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    tokens[k].type = <span class="hljs-string">"MUL"</span>;<br>                    tokens[k].lexeme = <span class="hljs-string">"*"</span>;<br>                    tokens[k].value = <span class="hljs-number">0.0</span>d;<br>                    i++;<br>                    k++;<br>                &#125;<br>            &#125;<span class="hljs-comment">// MUL and POWER</span><br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">'/'</span>) &#123;<br>                <span class="hljs-keyword">if</span> (chars[i + <span class="hljs-number">1</span>] == <span class="hljs-string">'/'</span>) &#123;<br>                    <span class="hljs-comment">//tokens[k].type = "COMMENT";</span><br>                    <span class="hljs-comment">//tokens[k].lexeme = "//";</span><br>                    <span class="hljs-comment">//tokens[k].value = 0.0d;</span><br>                    i = i + <span class="hljs-number">2</span>;<br>                    <span class="hljs-comment">//k++;</span><br>                    <span class="hljs-keyword">while</span> (chars[i] != <span class="hljs-string">'\n'</span>) &#123;   <span class="hljs-comment">//直接跳到换行符之后</span><br>                        i++;<br>                        <span class="hljs-keyword">if</span> (i == string2.length()) &#123;<br>                            <span class="hljs-keyword">return</span> k;<br>                        &#125;<br>                    &#125;<br>                    i++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    tokens[k].type = <span class="hljs-string">"DIV"</span>;<br>                    tokens[k].lexeme = <span class="hljs-string">"/"</span>;<br>                    tokens[k].value = <span class="hljs-number">0.0</span>d;<br>                    i++;<br>                    k++;<br>                &#125;<br>            &#125;<span class="hljs-comment">// 注释或者除</span><br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">'-'</span>) &#123;<br>                <span class="hljs-keyword">if</span> (chars[i + <span class="hljs-number">1</span>] == <span class="hljs-string">'-'</span>) &#123;<br>                    tokens[k].type = <span class="hljs-string">"COMMENT"</span>;<br>                    tokens[k].lexeme = <span class="hljs-string">"--"</span>;<br>                    tokens[k].value = <span class="hljs-number">0.0</span>d;<br>                    i = i + <span class="hljs-number">2</span>;<br>                    k++;<br>                    <span class="hljs-keyword">while</span> (chars[i] != <span class="hljs-string">'\n'</span>) &#123;   <span class="hljs-comment">//直接跳到换行符之后</span><br>                        i++;<br>                        <span class="hljs-keyword">if</span> (i == string2.length()) &#123;<br>                            <span class="hljs-keyword">return</span> k;<br>                        &#125;<br>                    &#125;<br>                    i++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    tokens[k].type = <span class="hljs-string">"MINUS"</span>;<br>                    tokens[k].lexeme = <span class="hljs-string">"-"</span>;<br>                    tokens[k].value = <span class="hljs-number">0.0</span>d;<br>                    i++;<br>                    k++;<br>                &#125;<br>            &#125;<span class="hljs-comment">// 注释或者减</span><br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">'+'</span>) &#123;<br>                tokens[k].type = <span class="hljs-string">"PLUS"</span>;<br>                tokens[k].lexeme = <span class="hljs-string">"+"</span>;<br>                tokens[k].value = <span class="hljs-number">0.0</span>d;<br>                i++;<br>                k++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">','</span>) &#123;<br>                tokens[k].type = <span class="hljs-string">"COMMA"</span>;<br>                tokens[k].lexeme = <span class="hljs-string">","</span>;<br>                tokens[k].value = <span class="hljs-number">0.0</span>d;<br>                i++;<br>                k++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">';'</span>) &#123;<br>                tokens[k].type = <span class="hljs-string">"SEMICO"</span>;<br>                tokens[k].lexeme = <span class="hljs-string">";"</span>;<br>                tokens[k].value = <span class="hljs-number">0.0</span>d;<br>                i++;<br>                k++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">'('</span>) &#123;<br>                tokens[k].type = <span class="hljs-string">"L_BRACKET"</span>;<br>                tokens[k].lexeme = <span class="hljs-string">"("</span>;<br>                tokens[k].value = <span class="hljs-number">0.0</span>d;<br>                i++;<br>                k++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">')'</span>) &#123;<br>                tokens[k].type = <span class="hljs-string">"R_BRACKET"</span>;<br>                tokens[k].lexeme = <span class="hljs-string">")"</span>;<br>                tokens[k].value = <span class="hljs-number">0.0</span>d;<br>                i++;<br>                k++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-number">9</span> || chars[i] == <span class="hljs-string">'\n'</span> || chars[i] == <span class="hljs-string">' '</span>) &#123;<br>                <span class="hljs-comment">//tokens[k].type="WHITE_SPACE";</span><br>                <span class="hljs-comment">//tokens[k].lexeme+=chars[i];</span><br>                <span class="hljs-comment">//tokens[k].value=0.0d;</span><br>                i++;<br>                <span class="hljs-comment">//k++;</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(chars[i] + <span class="hljs-string">" 词法错误 "</span> + <span class="hljs-string">"位置："</span> + k);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        String functions[] = &#123;<span class="hljs-string">"SIN"</span>, <span class="hljs-string">"COS"</span>, <span class="hljs-string">"TAN"</span>, <span class="hljs-string">"LN"</span>, <span class="hljs-string">"EXP"</span>, <span class="hljs-string">"SQRT"</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> kk = <span class="hljs-number">0</span>; kk &lt; k; kk++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ii = <span class="hljs-number">0</span>; ii &lt; <span class="hljs-number">10</span>; ii++) &#123;<br>                <span class="hljs-keyword">if</span> (tokens[kk].lexeme.toUpperCase().equals(Token_Type[ii])) &#123;<br>                    tokens[kk].type = Token_Type[ii];<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ii = <span class="hljs-number">0</span>; ii &lt; functions.length; ii++) &#123;<br>                <span class="hljs-keyword">if</span> (tokens[kk].lexeme.toUpperCase().equals(functions[ii])) &#123;<br>                    tokens[kk].type = <span class="hljs-string">"FUNC"</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tokens[kk].lexeme.toUpperCase().equals(<span class="hljs-string">"PI"</span>)) &#123;<br>                tokens[kk].type = <span class="hljs-string">"CONST_ID"</span>;<br>                tokens[kk].value = <span class="hljs-number">3.1415926</span>d;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tokens[kk].lexeme.toUpperCase().equals(<span class="hljs-string">"E"</span>)) &#123;<br>                tokens[kk].type = <span class="hljs-string">"CONST_ID"</span>;<br>                tokens[kk].value = <span class="hljs-number">2.71828</span>d;<br>            &#125;<br>        &#125;<br><br>        tokens[k].type=<span class="hljs-string">"NONTOKEN"</span>;<br>        tokens[k].value=<span class="hljs-number">0.0</span>d;<br>        tokens[k].lexeme=<span class="hljs-string">"NONTOKEN"</span>;<br>        <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k+<span class="hljs-number">1</span>; i++) &#123;<br>                System.out.print(tokens[i].type);<br>                System.out.print(<span class="hljs-string">"    "</span>);<br>                System.out.print(tokens[i].lexeme);<br>                System.out.print(<span class="hljs-string">"    "</span>);<br>                System.out.println(tokens[i].value);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux3.8.13编译内核的小问题</title>
    <link href="/2019/11/01/OS-Problems/"/>
    <url>/2019/11/01/OS-Problems/</url>
    
    <content type="html"><![CDATA[<h2 id="设备环境"><a href="#设备环境" class="headerlink" title="设备环境"></a>设备环境</h2><blockquote><p>Ubuntu 64位 16.04</p></blockquote><h2 id="编译内核时出现的问题"><a href="#编译内核时出现的问题" class="headerlink" title="编译内核时出现的问题"></a>编译内核时出现的问题</h2><p>最近在做操作系统的实验的第一个作业，编译内核。下载的是linux3.8.13的内核文件。</p><a id="more"></a><p>在基本的启动内核配置程序之后</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#make bzImage</span><br></code></pre></td></tr></table></figure><p>生成内核的镜像文件时发生了以下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs bash">lib/mpi/generic_mpih-mul1.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义<br>lib/mpi/generic_mpih-mul1.o：在函数‘mpihelp_add’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/generic_mpih-mul1.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义<br>lib/mpi/generic_mpih-mul1.o：在函数‘mpihelp_sub’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/generic_mpih-mul2.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义<br>lib/mpi/generic_mpih-mul2.o：在函数‘mpihelp_add’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/generic_mpih-mul2.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义<br>lib/mpi/generic_mpih-mul2.o：在函数‘mpihelp_sub’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/generic_mpih-mul3.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义<br>lib/mpi/generic_mpih-mul3.o：在函数‘mpihelp_add’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/generic_mpih-mul3.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义<br>lib/mpi/generic_mpih-mul3.o：在函数‘mpihelp_sub’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/generic_mpih-rshift.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义<br>lib/mpi/generic_mpih-rshift.o：在函数‘mpihelp_add’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/generic_mpih-rshift.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义<br>lib/mpi/generic_mpih-rshift.o：在函数‘mpihelp_sub’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/generic_mpih-sub1.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义<br>lib/mpi/generic_mpih-sub1.o：在函数‘mpihelp_add’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/generic_mpih-sub1.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义<br>lib/mpi/generic_mpih-sub1.o：在函数‘mpihelp_sub’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/generic_mpih-add1.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义<br>lib/mpi/generic_mpih-add1.o：在函数‘mpihelp_add’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/generic_mpih-add1.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义<br>lib/mpi/generic_mpih-add1.o：在函数‘mpihelp_sub’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/mpicoder.o：在函数‘mpihelp_add’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/mpicoder.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义<br>lib/mpi/mpicoder.o：在函数‘mpihelp_sub’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/mpicoder.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义<br>lib/mpi/mpi-bit.o：在函数‘mpihelp_add’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/mpi-bit.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义<br>lib/mpi/mpi-bit.o：在函数‘mpihelp_sub’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/mpi-bit.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义<br>lib/mpi/mpi-cmp.o：在函数‘mpihelp_add’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/mpi-cmp.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义<br>lib/mpi/mpi-cmp.o：在函数‘mpihelp_sub’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/mpi-cmp.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义<br>lib/mpi/mpih-cmp.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义<br>lib/mpi/mpih-cmp.o：在函数‘mpihelp_add’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/mpih-cmp.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义<br>lib/mpi/mpih-cmp.o：在函数‘mpihelp_sub’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/mpih-div.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义<br>lib/mpi/mpih-div.o：在函数‘mpihelp_add’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/mpih-div.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义<br>lib/mpi/mpih-div.o：在函数‘mpihelp_sub’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/mpih-mul.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义<br>lib/mpi/mpih-mul.o：在函数‘mpihelp_add’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/mpih-mul.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义<br>lib/mpi/mpih-mul.o：在函数‘mpihelp_sub’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/mpi-pow.o：在函数‘mpihelp_add’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/mpi-pow.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义<br>lib/mpi/mpi-pow.o：在函数‘mpihelp_sub’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/mpi-pow.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义<br>lib/mpi/mpiutil.o：在函数‘mpihelp_add’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67: `mpihelp_add<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:67：第一次在此定义<br>lib/mpi/mpiutil.o：在函数‘mpihelp_sub_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82: `mpihelp_sub_1'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:82：第一次在此定义<br>lib/mpi/mpiutil.o：在函数‘mpihelp_sub’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110: `mpihelp_sub<span class="hljs-string">'被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:110：第一次在此定义<br>lib/mpi/mpiutil.o：在函数‘mpihelp_add_1’中：<br>/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39: `mpihelp_add_1'</span>被多次定义<br>lib/mpi/generic_mpih-lshift.o:/usr/src/linux-3.8.13/lib/mpi/mpi-inline.h:39：第一次在此定义<br>scripts/Makefile.build:440: recipe <span class="hljs-keyword">for</span> target <span class="hljs-string">'lib/mpi/mpi.o'</span> failed<br>make[2]: *** [lib/mpi/mpi.o] Error 1<br>scripts/Makefile.build:454: recipe <span class="hljs-keyword">for</span> target <span class="hljs-string">'lib/mpi'</span> failed<br>make[1]: *** [lib/mpi] Error 2<br>Makefile:791: recipe <span class="hljs-keyword">for</span> target <span class="hljs-string">'lib'</span> failed<br>make: *** [lib] Error 2<br></code></pre></td></tr></table></figure><p>这个问题是卡了我稍长时间的，网上的解答很少。</p><blockquote><p>其中有个方法是修改lib/mpi-inline.h 中 将extern inline修改为static inline，经测试无效，文件下定义的其他函数非static类型。<br>和同学交流发现他们都没出现此问题，就感觉是自己虚拟机的问题。最后发现其实是编译器版本较高，而内核版本太老，自己的ubuntu 16.04 默认的gcc是5.4版本的，将其退至4.9版本即可顺利编译。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get install -y gcc-4.9<br>$ <span class="hljs-built_in">cd</span> /usr/bin<br>$ sudo rm gcc<br>$ sudo ln -s gcc-4.9 gcc<br></code></pre></td></tr></table></figure><p>安装gcc4.9，再链接实现降级<br>最后gcc -v 检查版本号。</p>]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PekingOJ 1363&amp;1125&amp;1564&amp;1511</title>
    <link href="/2019/10/29/PekingOJ/"/>
    <url>/2019/10/29/PekingOJ/</url>
    
    <content type="html"><![CDATA[<h2 id="这四题都是easy难度的，但还是很适合初学者好好练习的！【老师布置的题目原来不是按难度排序的-】"><a href="#这四题都是easy难度的，但还是很适合初学者好好练习的！【老师布置的题目原来不是按难度排序的-】" class="headerlink" title="这四题都是easy难度的，但还是很适合初学者好好练习的！【老师布置的题目原来不是按难度排序的..】"></a>这四题都是easy难度的，但还是很适合初学者好好练习的！【老师布置的题目原来不是按难度排序的..】</h2><a id="more"></a><h3 id="一、Stack"><a href="#一、Stack" class="headerlink" title="一、Stack"></a>一、Stack</h3><p>就是给定一个入栈顺序，去判断给定的出栈顺序可不可能实现<br>Sample Input</p><p>5<br>1 2 3 4 5<br>5 4 1 2 3<br>0<br>6<br>6 5 4 3 2 1<br>0<br>0<br>Sample Output</p><p>Yes<br>No</p><p>Yes</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; mystack;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Stackjudge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[<span class="hljs-number">1000</span>],<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(!mystack.empty())&#123;<br>        mystack.pop();<br>    &#125;<br>    <span class="hljs-keyword">int</span> i,j;<br>    <span class="hljs-keyword">int</span> flag1=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> test;<br>    <span class="hljs-keyword">int</span> first=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;num+<span class="hljs-number">1</span>;i++)&#123;   <span class="hljs-comment">//算出第一位</span><br>        <span class="hljs-keyword">if</span>(i!=q[<span class="hljs-number">0</span>])&#123;<br>            mystack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            first=i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!first)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"No"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;num;j++)&#123;<br>        <span class="hljs-keyword">if</span>(q[j]&gt;q[j<span class="hljs-number">-1</span>])&#123;<br>            <span class="hljs-keyword">for</span>(i=first+<span class="hljs-number">1</span>;i&lt;num+<span class="hljs-number">1</span>;i++)&#123;<br>                mystack.push(i);<br>                <span class="hljs-keyword">if</span>(i==q[j])&#123;<br>                    mystack.pop();<br>                    first=i;<br>                    flag1=<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!flag1)&#123;<br>                <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"No"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        flag1=<span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">if</span>(q[j]&lt;q[j<span class="hljs-number">-1</span>])&#123;<br>            test=mystack.top();<br>            <span class="hljs-keyword">if</span>(test==q[j])&#123;<br>                mystack.pop();<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"No"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Yes"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> Q[<span class="hljs-number">1000</span>];<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">int</span> num;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;num;<br>        <span class="hljs-keyword">if</span>(num==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">cin</span>&gt;&gt;Q[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span>(Q[<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;num;i++)&#123;<br>                <span class="hljs-built_in">cin</span>&gt;&gt;Q[i];<br>            &#125;<br>            Stackjudge(Q,num);<br>        &#125;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、最短路径"><a href="#二、最短路径" class="headerlink" title="二、最短路径"></a>二、最短路径</h3><p>股票经纪人对谣言的过分反应是周知的。你受雇找一种在股市中散布谣言的方法，使之以最快的速度传播给所有的人。<br>你必须把谣言先传给一个最合适的人<br>输入：<br>3             //三个人 2 2 4 3 5  //1号人有2个联系人，和2号花时间4,和3号花时间5 2 1 2 3 6   //2号人…… 2 1 2 2 253 4 4 2 8 5 31 5 84 1 6 4 10 2 7 5 2<br>输出：<br>3 2  //先传给3号，最多花时间2 3 10</p><blockquote><p>分析：任意两点间求出最短路径(Floyd?) 。<br>找点：到任意点都有路径。“谣言传播”总耗时等于这些路径的最大值。<br>目标：使这个最大值最小的某个点。</p></blockquote><p>这题不太想做…直接给floyd的算法吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;n;k++)<br>     <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">for</span>( j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>           <span class="hljs-keyword">if</span> (d[i][j]&gt;d[i][k]+d[k][j])<br>               d[i][j]=d[i][k]+d[k][j]; <br>                <span class="hljs-comment">//d[i][j]=Min(d[i][j], d[i][k]+d[k][j])</span><br></code></pre></td></tr></table></figure><h3 id="三、DFS"><a href="#三、DFS" class="headerlink" title="三、DFS"></a>三、DFS</h3><p>Sum it up<br>求出所有可能的加法可能<br><strong>Sample Input</strong></p><p>4 6 4 3 2 2 1 1<br>5 3 2 1 1<br>400 12 50 50 50 50 50 50 25 25 25 25 25 25<br>0 0</p><p><strong>Sample Output</strong></p><p>Sums of 4:<br>4<br>3+1<br>2+2<br>2+1+1<br>Sums of 5:<br>NONE<br>Sums of 400:<br>50+50+50+50+50+50+25+25+25+25<br>50+50+50+50+50+25+25+25+25+25+25</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> n,t,a[<span class="hljs-number">13</span>],b[<span class="hljs-number">13</span>],flag=<span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num,<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> sum)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(sum==<span class="hljs-number">0</span>)&#123;   <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;num;i++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"+%d"</span>,b[i]);<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        flag=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=k;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>((i==k||a[i]!=a[i<span class="hljs-number">-1</span>])&amp;&amp;sum-a[i]&gt;=<span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//去重</span><br>            b[num]=a[i];<br>            dfs(num+<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>,sum-a[i]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;t&gt;&gt;n;<br>        <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>&amp;&amp;n==<span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>            <span class="hljs-built_in">cin</span>&gt;&gt;a[i];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Sums of %d:\n"</span>,t);<br>        dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,t);<br>        <span class="hljs-keyword">if</span>(f) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"NONE\n"</span>);<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、Dijkstra变形题"><a href="#四、Dijkstra变形题" class="headerlink" title="四、Dijkstra变形题"></a>四、Dijkstra变形题</h3><p><a href="https://www.cnblogs.com/ZJUT-jiangnan/p/3935745.html" target="_blank" rel="noopener">POJ - 1511 Invitation Cards（Dijkstra变形题）</a><br>因为不太熟悉C++的容器，并且本题要求存储的数据量极大，二重矩阵十分浪费空间且运行时间不过关，需要使用其他的数据结构，所以参考了以下博客。<br>这道题主要就让自己知道怎样构建“数组链表”<br>这里就提取几行关键的数据结构代码，博客中没有注释，我稍微写了一点点注释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;edge&gt; <span class="hljs-built_in">map</span>[maxn];   <span class="hljs-comment">//vector容器</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; P;   <br><br><span class="hljs-built_in">map</span>[a].push_back(edge(a,b,c));  <span class="hljs-comment">//将一条边的信息链接在map[起始点]的最后面</span><br><br>priority_queue&lt;P,<span class="hljs-built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt; Q; <span class="hljs-comment">//dijkstra算法中构建Q优先队列</span><br>                                            <span class="hljs-comment">//&lt;Type,Container,Function&gt;</span><br><br>Q.push(P(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));            <span class="hljs-comment">//源点是1，dist[1]=0</span><br><span class="hljs-keyword">while</span>(!Q.empty())&#123;<br>    <span class="hljs-keyword">int</span> v=Q.top().second;     <span class="hljs-comment">// 这里开始看编号为v的这个点</span><br>    Q.pop();<br>    <span class="hljs-keyword">if</span>(visited[v])  <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//已经访问过的点就不再考虑了，这也就是为什么一旦边的权值有负数，此算法就没用了，因为还有可能从原来的路径绕路得到最短路径。有负值时我们采用Bellmam-Ford算法。</span><br>    visited[v]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">map</span>[v].size();i++)&#123;      <span class="hljs-comment">//这个size就是从v这个点有多少个边，遍历这些边，去做最短路径的替换</span><br>        edge e=<span class="hljs-built_in">map</span>[v][i];<br>        <span class="hljs-keyword">if</span>(dist[e.t]&gt;dist[v]+e.c)&#123;<br>            dist[e.t]=dist[v]+e.c;<br>            Q.push(P(dist[e.t],e.t));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然本题还要求各个点到源点的最短距离，这时我们可以用一个思路：反图，我们将原图中的所有边的方向反转，此时对远点使用Dijkstra算法则可得到其余各点到源点的最短距离。 大家自己画张图就可以很好得理解啦！</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PekingUniversityOJ No.1222</title>
    <link href="/2019/10/18/PekingOJ%201222/"/>
    <url>/2019/10/18/PekingOJ%201222/</url>
    
    <content type="html"><![CDATA[<p>这是一个很经典的小游戏，在一个m*n的格子，每按一下一个格子，包括自己这个格子和上下左右共5个格子的灯都会转变状态（亮-&gt;暗/暗-&gt;亮） 记得不久之前和薛老师去玩一个以“未闻花名”为主题的密室里，也有这个游戏，我当时就瞎捣鼓，莫名其妙全点灭了，没想到这次做题竟然又遇到了这个游戏！</p><a id="more"></a><p>Description</p><p>In an extended version of the game Lights Out, is a puzzle with 5 rows of 6 buttons each (the actual puzzle has 5 rows of 5 buttons each). Each button has a light. When a button is pressed, that button and each of its (up to four) neighbors above, below, right and left, has the state of its light reversed. (If on, the light is turned off; if off, the light is turned on.) Buttons in the corners change the state of 3 buttons; buttons on an edge change the state of 4 buttons and other buttons change the state of 5. For example, if the buttons marked X on the left below were to be pressed,the display would change to the image on the right. </p><p>The aim of the game is, starting from any initial set of lights on in the display, to press buttons to get the display to a state where all lights are off. When adjacent buttons are pressed, the action of one button can undo the effect of another. For instance, in the display below, pressing buttons marked X in the left display results in the right display.Note that the buttons in row 2 column 3 and row 2 column 5 both change the state of the button in row 2 column 4,so that, in the end, its state is unchanged. </p><p>Note: </p><ol><li>It does not matter what order the buttons are pressed. </li><li>If a button is pressed a second time, it exactly cancels the effect of the first press, so no button ever need be pressed more than once. </li><li>As illustrated in the second diagram, all the lights in the first row may be turned off, by pressing the corresponding buttons in the second row. By repeating this process in each row, all the lights in the first<br>four rows may be turned out. Similarly, by pressing buttons in columns 2, 3 ?, all lights in the first 5 columns may be turned off.<br>Write a program to solve the puzzle.<br>Input</li></ol><p>The first line of the input is a positive integer n which is the number of puzzles that follow. Each puzzle will be five lines, each of which has six 0 or 1 separated by one or more spaces. A 0 indicates that the light is off, while a 1 indicates that the light is on initially.<br>Output</p><p>For each puzzle, the output consists of a line with the string: “PUZZLE #m”, where m is the index of the puzzle in the input file. Following that line, is a puzzle-like display (in the same format as the input) . In this case, 1’s indicate buttons that must be pressed to solve the puzzle, while 0 indicate buttons, which are not pressed. There should be exactly one space between each 0 or 1 in the output puzzle-like display.<br>Sample Input</p><p>2<br>0 1 1 0 1 0<br>1 0 0 1 1 1<br>0 0 1 0 0 1<br>1 0 0 1 0 1<br>0 1 1 1 0 0<br>0 0 1 0 1 0<br>1 0 1 0 1 1<br>0 0 1 0 1 1<br>1 0 1 1 0 0<br>0 1 0 1 0 0<br>Sample Output</p><p>PUZZLE #1<br>1 0 1 0 0 1<br>1 1 0 1 0 1<br>0 0 1 0 1 1<br>1 0 0 1 0 0<br>0 1 0 0 0 0<br>PUZZLE #2<br>1 0 0 1 1 1<br>1 1 0 0 0 0<br>0 0 0 1 0 0<br>1 1 0 1 0 1<br>1 0 1 1 0 1<br>Source</p><p>Greater New York 2002</p><h1 id="总体思路：二进制枚举-贪心"><a href="#总体思路：二进制枚举-贪心" class="headerlink" title="总体思路：二进制枚举+贪心"></a>总体思路：<strong>二进制枚举+贪心</strong></h1><h2 id="首先介绍一下二进制枚举算法"><a href="#首先介绍一下二进制枚举算法" class="headerlink" title="首先介绍一下二进制枚举算法"></a>首先介绍一下二进制枚举算法</h2><p>这里要了解位运算，尤其是按位与还有移位运算。</p><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><p>a&lt;&lt;b运算就是，将二进制a向左移b位，也就是a右边添上b个0。如2的二进制是10，向左移一位就是100，则为十进制4，不难发现左移n位，及等价于乘上2^n<br>那么下面的代码即可遍历0到2^(n-1)之内的数</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; n); i++);<br></code></pre></td></tr></table></figure><h3 id="按位与运算"><a href="#按位与运算" class="headerlink" title="按位与运算"></a>按位与运算</h3><p>运算规则：0&amp;0=0;  0&amp;1=0;   1&amp;0=0;    1&amp;1=1;<br>对于某个二进制数10100</p><blockquote><p>10100&amp;00001=00000<br>10100&amp;00010=00000<br>10100&amp;00100=00100<br>10100&amp;01000=00000<br>10100&amp;10000=10000<br>举上面的例子其实就是更好得解释二进制枚举<br>下面展示较完整的代码</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">cin</span> &gt;&gt; n;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span>&lt;&lt;n); i++) <span class="hljs-comment">//从0～2^n-1个状态</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) <span class="hljs-comment">//遍历二进制的每一位</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(i &amp; (<span class="hljs-number">1</span> &lt;&lt; j))<span class="hljs-comment">//判断二进制第j位是否存在</span><br>        &#123;<br>        .............<span class="hljs-comment">//如果第j位存在，则改变相应状态变量【做题用】</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于这个题目，我们其实只要二进制枚举第一行灯的按压状态，而之后的每一行直接运用贪心算法即可，即上一行哪个灯亮，就按对应下一行的灯，保证上一行的灯全暗。<br>其实有个小疑问，是否会出现一种初始状态，出现无解的情况呢。<br>下面附上全部代码，由于北大oj编译器版本较老，声明的数组维度中不能出现变量，所以代码oj是显示compile error的，但思路和解决方法我认为是没问题的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> press[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>];<br><span class="hljs-keyword">int</span> puzzle[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>];<br><span class="hljs-keyword">int</span> countt=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tanxin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> puzzle[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>])</span></span>&#123;     <span class="hljs-comment">//贪心算法</span><br>    <span class="hljs-keyword">int</span> i,j,flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">6</span>;j++)&#123;<br>            <span class="hljs-keyword">if</span>(puzzle[i][j]==<span class="hljs-number">1</span>)&#123;<br>                press[i+<span class="hljs-number">1</span>][j]=<span class="hljs-number">1</span>;<br>                puzzle[i+<span class="hljs-number">1</span>][j]=(puzzle[i+<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span>(j!=<span class="hljs-number">0</span>)&#123;            <span class="hljs-comment">//第一列</span><br>                    puzzle[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]=(puzzle[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(j!=<span class="hljs-number">5</span>)&#123;            <span class="hljs-comment">//最后一列</span><br>                    puzzle[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=(puzzle[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">3</span>)&#123;            <span class="hljs-comment">//倒数第二行</span><br>                    puzzle[i+<span class="hljs-number">2</span>][j]=(puzzle[i+<span class="hljs-number">2</span>][j]+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">6</span>;j++)&#123;               <span class="hljs-comment">//仅需判断最后一行是否全0即可，因为是贪心算法做的</span><br>        <span class="hljs-keyword">if</span>(puzzle[<span class="hljs-number">4</span>][j]==<span class="hljs-number">1</span>)&#123;<br>            flag=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag)&#123;<br>        countt++;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"PUZZLE #"</span>&lt;&lt;countt&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">6</span>;j++)&#123;<br><br>                <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;press[i][j]&lt;&lt;<span class="hljs-string">' '</span>;<br>            <br>            &#125;<br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">map</span>[][<span class="hljs-number">6</span>])</span></span>&#123;   <span class="hljs-comment">//枚举第一行，贪心剩余几行</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> modd;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">64</span>;i++)&#123;        <span class="hljs-comment">//i&lt;(1&lt;&lt;6)</span><br>            <span class="hljs-built_in">memcpy</span>(puzzle,<span class="hljs-built_in">map</span>,<span class="hljs-keyword">sizeof</span>(puzzle));<br>            <span class="hljs-built_in">memset</span>(press,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(press));<br>            <span class="hljs-keyword">for</span>(modd=<span class="hljs-number">0</span>;modd&lt;<span class="hljs-number">6</span>;modd++)&#123;<br>                <span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;modd))&#123;<span class="hljs-comment">//1&lt;&lt;mod 除了向左移的那一位1，剩余的都是0，所以我们就可以得到那一位是不是1</span><br>                        puzzle[<span class="hljs-number">0</span>][modd]=(<span class="hljs-number">1</span>+puzzle[<span class="hljs-number">0</span>][modd])%<span class="hljs-number">2</span>;<br>                        puzzle[<span class="hljs-number">1</span>][modd]=(<span class="hljs-number">1</span>+puzzle[<span class="hljs-number">1</span>][modd])%<span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">if</span>(modd!=<span class="hljs-number">0</span>)&#123;<br>                            puzzle[<span class="hljs-number">0</span>][modd<span class="hljs-number">-1</span>]=(<span class="hljs-number">1</span>+puzzle[<span class="hljs-number">0</span>][modd<span class="hljs-number">-1</span>])%<span class="hljs-number">2</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span>(modd!=<span class="hljs-number">5</span>)&#123;<br>                            puzzle[<span class="hljs-number">0</span>][modd+<span class="hljs-number">1</span>]=(<span class="hljs-number">1</span>+puzzle[<span class="hljs-number">0</span>][modd+<span class="hljs-number">1</span>])%<span class="hljs-number">2</span>;<br>                        &#125;<br>                        press[<span class="hljs-number">0</span>][modd]=<span class="hljs-number">1</span>;<br>                    &#125;<br>            &#125;<br>            tanxin(puzzle);        <span class="hljs-comment">//判断</span><br>        &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> times=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> m,i,j;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;times;<br>    m=<span class="hljs-number">5</span>*times;<br>    <span class="hljs-keyword">int</span> puzzlee[m][<span class="hljs-number">6</span>];<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">6</span>;j++)&#123;<br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;puzzlee[i][j];<br>        &#125;<br>    &#125;<br>            <br>   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;times;i++)<br>        solve(puzzlee+i*<span class="hljs-number">5</span>);     <span class="hljs-comment">//每一次迭代，指向puzzle数组的next5行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因为是课上老师捎带提过的题目，思路很快就出来了，但在coding阶段主要就遇到了原来不曾用过的二进制枚举问题。我一开始的想法是通过把第一行六列所有的组合通过一个状态矩阵的判重循环出来，但其实有很大的漏洞。后来我就想到我可以求{0,1,2,3,4,5}的幂集，即构造一个二叉树，左右子树分别对应“取，舍”两种状态，然后分别对6个元素一一做取舍，最后的子树即位这2^6个集合…但，有点麻烦。求出幂集后还得变为相应二进制状态。最后查阅资料学习了二进制枚举，解决了这道题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PekingUniversityOJ No.1979</title>
    <link href="/2019/10/17/PekingOJ%201979/"/>
    <url>/2019/10/17/PekingOJ%201979/</url>
    
    <content type="html"><![CDATA[<p>这学期一时兴起选修选了个acm课，其实就想补补自己的数据结构和算法，大学前两年下来感觉代码功底不够扎实，希望借此机会巩固加强一下代码能力，算法题我主要以C++来实现，因为自己C++没有系统的学习过，就以练代学吧！</p><h2 id="Leo"><a href="#Leo" class="headerlink" title="Leo"></a>Leo</h2><h3 id="本题是一道很简单的搜索题，也正好是课上刚巩固的内容。这里我使用的是广度优先搜索，单纯因为想练练广搜的算法实现。"><a href="#本题是一道很简单的搜索题，也正好是课上刚巩固的内容。这里我使用的是广度优先搜索，单纯因为想练练广搜的算法实现。" class="headerlink" title="本题是一道很简单的搜索题，也正好是课上刚巩固的内容。这里我使用的是广度优先搜索，单纯因为想练练广搜的算法实现。"></a>本题是一道很简单的搜索题，也正好是课上刚巩固的内容。这里我使用的是广度优先搜索，单纯因为想练练广搜的算法实现。</h3><a id="more"></a><p>Description</p><p>There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles. </p><p>Write a program to count the number of black tiles which he can reach by repeating the moves described above.<br>Input</p><p>The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20. </p><p>There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows. </p><p>‘.’ - a black tile<br>‘#’ - a red tile<br>‘@’ - a man on a black tile(appears exactly once in a data set)<br>The end of the input is indicated by a line consisting of two zeros.<br>Output</p><p>For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).<br>Sample Input</p><p>6 9<br>….#.<br>…..#<br>……<br>……<br>……<br>……<br>……<br>#@…#<br>.#..#.<br>11 9<br>.#………<br>.#.#######.<br>.#.#…..#.<br>.#.#.###.#.<br>.#.#..@#.#.<br>.#.#####.#.<br>.#…….#.<br>.#########.<br>………..<br>11 6<br>..#..#..#..<br>..#..#..#..<br>..#..#..###<br>..#..#..#@.<br>..#..#..#..<br>..#..#..#..<br>7 7<br>..#.#..<br>..#.#..<br>###.###<br>…@…<br>###.###<br>..#.#..<br>..#.#..<br>0 0<br>Sample Output：</p><p>45<br>59<br>6<br>13</p><p>Source：</p><p>Japan 2004 Domestic</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">//  main.cpp</span><br><span class="hljs-comment">//  PekingOJ</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  Created by leo on 2019/10/18.</span><br><span class="hljs-comment">//  Copyright © 2019 leo. All rights reserved.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; qq;<br><br><span class="hljs-keyword">int</span> countt;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;      <span class="hljs-comment">//a和b数组定义了上下左右“走”的规则 课上老师讲了道例题是象棋马的搜索，只要修改这两个数组即可</span><br><span class="hljs-keyword">int</span> b[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">char</span> <span class="hljs-built_in">map</span>[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];           <span class="hljs-comment">//最大是一个20*w20的盘子</span><br><span class="hljs-keyword">bool</span> mp[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];            <span class="hljs-comment">//防止状态重复</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">in</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n)</span>    <span class="hljs-comment">//判断是否有越界</span><br></span>&#123;<br>        <span class="hljs-keyword">return</span> (a&gt;=<span class="hljs-number">0</span>&amp;&amp;a&lt;=n<span class="hljs-number">-1</span>&amp;&amp;b&gt;=<span class="hljs-number">0</span>&amp;&amp;b&lt;=m<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n)</span></span>&#123;      <span class="hljs-comment">//广度优先搜索主要就借助队列来实现</span><br>    qq.push(x);<br>    qq.push(y);<br>    <span class="hljs-keyword">int</span> k;<br>    <span class="hljs-keyword">int</span> x_coordinate,y_coordinate;<br>    <span class="hljs-keyword">while</span>(!qq.empty())<br>    &#123;<br>        x_coordinate=qq.front();<br>        <span class="hljs-comment">//std::cout&lt;&lt;x_coordinate&lt;&lt;endl;</span><br>        qq.pop();<br>        y_coordinate=qq.front();<br>        <span class="hljs-comment">//std::cout&lt;&lt;y_coordinate&lt;&lt;endl;</span><br>        qq.pop();<br>        countt=countt+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>[x_coordinate+a[k]][y_coordinate+b[k]]==<span class="hljs-string">'.'</span>&amp;&amp;!mp[x_coordinate+a[k]][y_coordinate+b[k]]&amp;&amp;in(x_coordinate+a[k],y_coordinate+b[k],m,n))<br>            &#123;<br>                mp[x_coordinate+a[k]][y_coordinate+b[k]]=<span class="hljs-literal">true</span>;<br>                qq.push(x_coordinate+a[k]);<br>                qq.push(y_coordinate+b[k]);<br>            &#125;<br>        &#125;<br>         <br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m,n;<br><br>    <span class="hljs-keyword">int</span> enter_x=<span class="hljs-number">0</span>,enter_y=<span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;m&gt;&gt;n)<br>        &#123;<br><br>            countt=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>&amp;&amp;n==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> e=<span class="hljs-number">0</span>;e&lt;n;e++)              <span class="hljs-comment">//初始化用于判重的矩阵</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r=<span class="hljs-number">0</span>;r&lt;m;r++)<br>                    mp[e][r]=<span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>                    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;<span class="hljs-built_in">map</span>[i][j];<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>[i][j]==<span class="hljs-string">'@'</span>)&#123;<br>                        enter_x=i;<br>                        enter_y=j;<br>                        mp[i][j]=<span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>    <span class="hljs-comment">//std::cout&lt;&lt;enter_x&lt;&lt;enter_y;</span><br>    <span class="hljs-comment">//std::cout&lt;&lt;map[enter_x][enter_y];</span><br>        bfs(enter_x,enter_y,m,n);<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;countt&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>很久没有写算法题了，代码自认为写得就不是很好看，其实中间还有很多可以改变的地方。看过别人写的这道题的代码。不使用单独的判重数组，每次访问到队列中的某个节点后将此节点上的内容改为‘#’，也就没法再次访问了，也是很好的想法。不过我还是倾向去将各个模块分割，重复状态的判断我认为还是在搜索算法里是一个很重要的模块。</p><h3 id="coding期间出现的问题"><a href="#coding期间出现的问题" class="headerlink" title="coding期间出现的问题"></a>coding期间出现的问题</h3><p>忘记初始化判重数组【一开始我也没写bool in函数】，导致在从第二次及以后的瓦片读取后计算可能会出错（遗留下来的map会影响下一张map）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac下如何创建博客</title>
    <link href="/2019/10/16/creatblog/"/>
    <url>/2019/10/16/creatblog/</url>
    
    <content type="html"><![CDATA[<p>拥有了博客，虽然网上有很多很棒的教程了，但我这里想简略记录一下我自己创建博客的操作过程。这篇主要是写给自己看的。</p><h2 id="Leo"><a href="#Leo" class="headerlink" title="Leo"></a>Leo</h2><h3 id="我电脑已经装有nvm，可直接用nvm安装node的稳定版本"><a href="#我电脑已经装有nvm，可直接用nvm安装node的稳定版本" class="headerlink" title="我电脑已经装有nvm，可直接用nvm安装node的稳定版本"></a>我电脑已经装有nvm，可直接用nvm安装node的稳定版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ nvm install 12.5.0<br></code></pre></td></tr></table></figure><a id="more"></a><h3 id="安装hexo，并部署到git-page的deployer"><a href="#安装hexo，并部署到git-page的deployer" class="headerlink" title="安装hexo，并部署到git page的deployer"></a>安装hexo，并部署到git page的deployer</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ npm <span class="hljs-keyword">install</span> hexo-cli -g <br>$ npm <span class="hljs-keyword">install</span> hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init iblog<br></code></pre></td></tr></table></figure><p>这里我因为网络原因经常卡住，导致创造了很多遍iblog文件，这里会出现一个问题，在自动安装dependecies时报出npm ERR! cb() never called!的错误<br>这里需要清除你的npm缓存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo npm cache clean -f<br></code></pre></td></tr></table></figure><p>很有意思，会得到一个提醒 “希望你知道你在做什么”<br>之后到网络好的地方安装就完成了</p><h3 id="创建github-io仓库并配置SSH密码"><a href="#创建github-io仓库并配置SSH密码" class="headerlink" title="创建github.io仓库并配置SSH密码"></a>创建github.io仓库并配置SSH密码</h3><p>我很早就创建好了，注意仓库名必须为 userName.github.io，我的用户名是LeoMarsX，即LeoMarsX.github.io<br>查看是否有SSH密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -al ~/.ssh<br>$ No such file or directory<br></code></pre></td></tr></table></figure><p>生成SSH密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C<span class="hljs-string">"your_email"</span><br>//your_email:这是github注册时填的邮箱<br></code></pre></td></tr></table></figure><p>添加SSH</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-add ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure><p>查看SSH</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ cat /Users/UserName/.ssh/id_rsa.pub<br>//UserName :电脑用户名<br></code></pre></td></tr></table></figure><p>然后将查看到的SSH复制到github中    （先Edit profile，然后点击New SSH key）<br><img src="/picture/test1.png" srcset="/img/loading.gif" lazyload alt="点击New SSH key"></p><p>测试看是否测试成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh -T git@github.com<br>Hi XXXX You<span class="hljs-string">'ve successfully authenticated, but GitHub does not provide shell access.</span><br></code></pre></td></tr></table></figure><h3 id="将本地的Hexo文件更新到GitHub仓库中"><a href="#将本地的Hexo文件更新到GitHub仓库中" class="headerlink" title="将本地的Hexo文件更新到GitHub仓库中"></a>将本地的Hexo文件更新到GitHub仓库中</h3><p>到iblog这个根目录打开_config.ymlb配置文件，拉到最下面更改配置信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy:<br><span class="hljs-built_in">type</span>: git<br>repo: https://github.com/userName/userName.github.io.git<br>branch: master<br></code></pre></td></tr></table></figure><p>注意 这里的所有冒号之后一定都要有一个空格</p><h3 id="快成功啦！"><a href="#快成功啦！" class="headerlink" title="快成功啦！"></a>快成功啦！</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g  //generation生成<br>$ hexo d  //deploy配置<br>//如果这时候报错了,执行下面这行代码，再重新输入hexo d<br>$ npm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><p>就可以登陆访问网站啦</p><h2 id="怎么写博客呢"><a href="#怎么写博客呢" class="headerlink" title="怎么写博客呢"></a>怎么写博客呢</h2><p>打开创建的iblog文件夹，其中的source/_posts文件里的markdown文件就是刚刚打开的hexo默认的第一篇文章的文件代码，自己进行修改内容就可以写自己的文章啦。直接新建一个md文件就可以新建一篇文章了。</p><h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>在github里搜索 hexo themes即可看到很多优秀的前端工程师做的主题，根据他们提供的指南进行安装就可以让自己的博客更好看了！</p>]]></content>
    
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇博客</title>
    <link href="/2019/10/15/hello-world/"/>
    <url>/2019/10/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>终于有了自己的一个博客啦！折腾了一个下午吧，后面整理一下把搭建这个博客的教程，遇到的问题整理下来。</p><h2 id="Leo"><a href="#Leo" class="headerlink" title="Leo"></a>Leo</h2><h3 id="Really-Exicted"><a href="#Really-Exicted" class="headerlink" title="Really Exicted."></a>Really Exicted.</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs undefined">Gonna <span class="hljs-built_in">to</span> be <span class="hljs-keyword">a</span> great person.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
